// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef XMLDSIG_CORE_SCHEMA_H
#define XMLDSIG_CORE_SCHEMA_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace ds
{
  class CryptoBinary;
  class SignatureType;
  class SignatureValueType;
  class SignedInfoType;
  class CanonicalizationMethodType;
  class SignatureMethodType;
  class ReferenceType;
  class TransformsType;
  class TransformType;
  class DigestMethodType;
  class DigestValueType;
  class KeyInfoType;
  class KeyValueType;
  class RetrievalMethodType;
  class X509DataType;
  class X509IssuerSerialType;
  class PGPDataType;
  class SPKIDataType;
  class ObjectType;
  class ManifestType;
  class SignaturePropertiesType;
  class SignaturePropertyType;
  class HMACOutputLengthType;
  class DSAKeyValueType;
  class RSAKeyValueType;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

namespace ds
{
  class CryptoBinary: public ::xml_schema::Base64Binary
  {
    public:
    // Constructors.
    //
    CryptoBinary ();

    CryptoBinary (const ::xml_schema::Base64Binary&);

    CryptoBinary (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    CryptoBinary (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    CryptoBinary (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    CryptoBinary (const CryptoBinary& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual CryptoBinary*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~CryptoBinary ();
  };

  class SignatureType: public ::xml_schema::Type
  {
    public:
    // SignedInfo
    //
    typedef ::ds::SignedInfoType SignedInfoType;
    typedef ::xsd::cxx::tree::traits< SignedInfoType, char > SignedInfoTraits;

    const SignedInfoType&
    getSignedInfo () const;

    SignedInfoType&
    getSignedInfo ();

    void
    setSignedInfo (const SignedInfoType& x);

    void
    setSignedInfo (::std::unique_ptr< SignedInfoType > p);

    // SignatureValue
    //
    typedef ::ds::SignatureValueType SignatureValueType;
    typedef ::xsd::cxx::tree::traits< SignatureValueType, char > SignatureValueTraits;

    const SignatureValueType&
    getSignatureValue () const;

    SignatureValueType&
    getSignatureValue ();

    void
    setSignatureValue (const SignatureValueType& x);

    void
    setSignatureValue (::std::unique_ptr< SignatureValueType > p);

    // KeyInfo
    //
    typedef ::ds::KeyInfoType KeyInfoType;
    typedef ::xsd::cxx::tree::optional< KeyInfoType > KeyInfoOptional;
    typedef ::xsd::cxx::tree::traits< KeyInfoType, char > KeyInfoTraits;

    const KeyInfoOptional&
    getKeyInfo () const;

    KeyInfoOptional&
    getKeyInfo ();

    void
    setKeyInfo (const KeyInfoType& x);

    void
    setKeyInfo (const KeyInfoOptional& x);

    void
    setKeyInfo (::std::unique_ptr< KeyInfoType > p);

    // Object
    //
    typedef ::ds::ObjectType ObjectType;
    typedef ::xsd::cxx::tree::sequence< ObjectType > ObjectSequence;
    typedef ObjectSequence::iterator ObjectIterator;
    typedef ObjectSequence::const_iterator ObjectConstIterator;
    typedef ::xsd::cxx::tree::traits< ObjectType, char > ObjectTraits;

    const ObjectSequence&
    getObject () const;

    ObjectSequence&
    getObject ();

    void
    setObject (const ObjectSequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Constructors.
    //
    SignatureType (const SignedInfoType&,
                   const SignatureValueType&);

    SignatureType (::std::unique_ptr< SignedInfoType >,
                   ::std::unique_ptr< SignatureValueType >);

    SignatureType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    SignatureType (const SignatureType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual SignatureType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignatureType&
    operator= (const SignatureType& x);

    virtual 
    ~SignatureType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SignedInfoType > SignedInfo_;
    ::xsd::cxx::tree::one< SignatureValueType > SignatureValue_;
    KeyInfoOptional KeyInfo_;
    ObjectSequence Object_;
    IdOptional Id_;
  };

  class SignatureValueType: public ::xml_schema::Base64Binary
  {
    public:
    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Constructors.
    //
    SignatureValueType ();

    SignatureValueType (const ::xml_schema::Base64Binary&);

    SignatureValueType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    SignatureValueType (const SignatureValueType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual SignatureValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignatureValueType&
    operator= (const SignatureValueType& x);

    virtual 
    ~SignatureValueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    IdOptional Id_;
  };

  class SignedInfoType: public ::xml_schema::Type
  {
    public:
    // CanonicalizationMethod
    //
    typedef ::ds::CanonicalizationMethodType CanonicalizationMethodType;
    typedef ::xsd::cxx::tree::traits< CanonicalizationMethodType, char > CanonicalizationMethodTraits;

    const CanonicalizationMethodType&
    getCanonicalizationMethod () const;

    CanonicalizationMethodType&
    getCanonicalizationMethod ();

    void
    setCanonicalizationMethod (const CanonicalizationMethodType& x);

    void
    setCanonicalizationMethod (::std::unique_ptr< CanonicalizationMethodType > p);

    // SignatureMethod
    //
    typedef ::ds::SignatureMethodType SignatureMethodType;
    typedef ::xsd::cxx::tree::traits< SignatureMethodType, char > SignatureMethodTraits;

    const SignatureMethodType&
    getSignatureMethod () const;

    SignatureMethodType&
    getSignatureMethod ();

    void
    setSignatureMethod (const SignatureMethodType& x);

    void
    setSignatureMethod (::std::unique_ptr< SignatureMethodType > p);

    // Reference
    //
    typedef ::ds::ReferenceType ReferenceType;
    typedef ::xsd::cxx::tree::sequence< ReferenceType > ReferenceSequence;
    typedef ReferenceSequence::iterator ReferenceIterator;
    typedef ReferenceSequence::const_iterator ReferenceConstIterator;
    typedef ::xsd::cxx::tree::traits< ReferenceType, char > ReferenceTraits;

    const ReferenceSequence&
    getReference () const;

    ReferenceSequence&
    getReference ();

    void
    setReference (const ReferenceSequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Constructors.
    //
    SignedInfoType (const CanonicalizationMethodType&,
                    const SignatureMethodType&);

    SignedInfoType (::std::unique_ptr< CanonicalizationMethodType >,
                    ::std::unique_ptr< SignatureMethodType >);

    SignedInfoType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    SignedInfoType (const SignedInfoType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual SignedInfoType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignedInfoType&
    operator= (const SignedInfoType& x);

    virtual 
    ~SignedInfoType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CanonicalizationMethodType > CanonicalizationMethod_;
    ::xsd::cxx::tree::one< SignatureMethodType > SignatureMethod_;
    ReferenceSequence Reference_;
    IdOptional Id_;
  };

  class CanonicalizationMethodType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Algorithm
    //
    typedef ::xml_schema::Uri AlgorithmType;
    typedef ::xsd::cxx::tree::traits< AlgorithmType, char > AlgorithmTraits;

    const AlgorithmType&
    getAlgorithm () const;

    AlgorithmType&
    getAlgorithm ();

    void
    setAlgorithm (const AlgorithmType& x);

    void
    setAlgorithm (::std::unique_ptr< AlgorithmType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    CanonicalizationMethodType (const AlgorithmType&);

    CanonicalizationMethodType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    CanonicalizationMethodType (const CanonicalizationMethodType& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    virtual CanonicalizationMethodType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CanonicalizationMethodType&
    operator= (const CanonicalizationMethodType& x);

    virtual 
    ~CanonicalizationMethodType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
    ::xsd::cxx::tree::one< AlgorithmType > Algorithm_;
  };

  class SignatureMethodType: public ::xml_schema::Type
  {
    public:
    // HMACOutputLength
    //
    typedef ::ds::HMACOutputLengthType HMACOutputLengthType;
    typedef ::xsd::cxx::tree::optional< HMACOutputLengthType > HMACOutputLengthOptional;
    typedef ::xsd::cxx::tree::traits< HMACOutputLengthType, char > HMACOutputLengthTraits;

    const HMACOutputLengthOptional&
    getHMACOutputLength () const;

    HMACOutputLengthOptional&
    getHMACOutputLength ();

    void
    setHMACOutputLength (const HMACOutputLengthType& x);

    void
    setHMACOutputLength (const HMACOutputLengthOptional& x);

    void
    setHMACOutputLength (::std::unique_ptr< HMACOutputLengthType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Algorithm
    //
    typedef ::xml_schema::Uri AlgorithmType;
    typedef ::xsd::cxx::tree::traits< AlgorithmType, char > AlgorithmTraits;

    const AlgorithmType&
    getAlgorithm () const;

    AlgorithmType&
    getAlgorithm ();

    void
    setAlgorithm (const AlgorithmType& x);

    void
    setAlgorithm (::std::unique_ptr< AlgorithmType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    SignatureMethodType (const AlgorithmType&);

    SignatureMethodType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    SignatureMethodType (const SignatureMethodType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual SignatureMethodType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignatureMethodType&
    operator= (const SignatureMethodType& x);

    virtual 
    ~SignatureMethodType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    HMACOutputLengthOptional HMACOutputLength_;
    AnySequence any_;
    ::xsd::cxx::tree::one< AlgorithmType > Algorithm_;
  };

  class ReferenceType: public ::xml_schema::Type
  {
    public:
    // Transforms
    //
    typedef ::ds::TransformsType TransformsType;
    typedef ::xsd::cxx::tree::optional< TransformsType > TransformsOptional;
    typedef ::xsd::cxx::tree::traits< TransformsType, char > TransformsTraits;

    const TransformsOptional&
    getTransforms () const;

    TransformsOptional&
    getTransforms ();

    void
    setTransforms (const TransformsType& x);

    void
    setTransforms (const TransformsOptional& x);

    void
    setTransforms (::std::unique_ptr< TransformsType > p);

    // DigestMethod
    //
    typedef ::ds::DigestMethodType DigestMethodType;
    typedef ::xsd::cxx::tree::traits< DigestMethodType, char > DigestMethodTraits;

    const DigestMethodType&
    getDigestMethod () const;

    DigestMethodType&
    getDigestMethod ();

    void
    setDigestMethod (const DigestMethodType& x);

    void
    setDigestMethod (::std::unique_ptr< DigestMethodType > p);

    // DigestValue
    //
    typedef ::ds::DigestValueType DigestValueType;
    typedef ::xsd::cxx::tree::traits< DigestValueType, char > DigestValueTraits;

    const DigestValueType&
    getDigestValue () const;

    DigestValueType&
    getDigestValue ();

    void
    setDigestValue (const DigestValueType& x);

    void
    setDigestValue (::std::unique_ptr< DigestValueType > p);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // URI
    //
    typedef ::xml_schema::Uri URIType;
    typedef ::xsd::cxx::tree::optional< URIType > URIOptional;
    typedef ::xsd::cxx::tree::traits< URIType, char > URITraits;

    const URIOptional&
    getURI () const;

    URIOptional&
    getURI ();

    void
    setURI (const URIType& x);

    void
    setURI (const URIOptional& x);

    void
    setURI (::std::unique_ptr< URIType > p);

    // Type
    //
    typedef ::xml_schema::Uri TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    ReferenceType (const DigestMethodType&,
                   const DigestValueType&);

    ReferenceType (::std::unique_ptr< DigestMethodType >,
                   const DigestValueType&);

    ReferenceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    ReferenceType (const ReferenceType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual ReferenceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ReferenceType&
    operator= (const ReferenceType& x);

    virtual 
    ~ReferenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TransformsOptional Transforms_;
    ::xsd::cxx::tree::one< DigestMethodType > DigestMethod_;
    ::xsd::cxx::tree::one< DigestValueType > DigestValue_;
    IdOptional Id_;
    URIOptional URI_;
    TypeOptional Type_;
  };

  class TransformsType: public ::xml_schema::Type
  {
    public:
    // Transform
    //
    typedef ::ds::TransformType TransformType;
    typedef ::xsd::cxx::tree::sequence< TransformType > TransformSequence;
    typedef TransformSequence::iterator TransformIterator;
    typedef TransformSequence::const_iterator TransformConstIterator;
    typedef ::xsd::cxx::tree::traits< TransformType, char > TransformTraits;

    const TransformSequence&
    getTransform () const;

    TransformSequence&
    getTransform ();

    void
    setTransform (const TransformSequence& s);

    // Constructors.
    //
    TransformsType ();

    TransformsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    TransformsType (const TransformsType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual TransformsType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TransformsType&
    operator= (const TransformsType& x);

    virtual 
    ~TransformsType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TransformSequence Transform_;
  };

  class TransformType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // XPath
    //
    typedef ::xml_schema::String XPathType;
    typedef ::xsd::cxx::tree::sequence< XPathType > XPathSequence;
    typedef XPathSequence::iterator XPathIterator;
    typedef XPathSequence::const_iterator XPathConstIterator;
    typedef ::xsd::cxx::tree::traits< XPathType, char > XPathTraits;

    const XPathSequence&
    getXPath () const;

    XPathSequence&
    getXPath ();

    void
    setXPath (const XPathSequence& s);

    // Algorithm
    //
    typedef ::xml_schema::Uri AlgorithmType;
    typedef ::xsd::cxx::tree::traits< AlgorithmType, char > AlgorithmTraits;

    const AlgorithmType&
    getAlgorithm () const;

    AlgorithmType&
    getAlgorithm ();

    void
    setAlgorithm (const AlgorithmType& x);

    void
    setAlgorithm (::std::unique_ptr< AlgorithmType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    TransformType (const AlgorithmType&);

    TransformType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    TransformType (const TransformType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual TransformType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TransformType&
    operator= (const TransformType& x);

    virtual 
    ~TransformType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
    XPathSequence XPath_;
    ::xsd::cxx::tree::one< AlgorithmType > Algorithm_;
  };

  class DigestMethodType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Algorithm
    //
    typedef ::xml_schema::Uri AlgorithmType;
    typedef ::xsd::cxx::tree::traits< AlgorithmType, char > AlgorithmTraits;

    const AlgorithmType&
    getAlgorithm () const;

    AlgorithmType&
    getAlgorithm ();

    void
    setAlgorithm (const AlgorithmType& x);

    void
    setAlgorithm (::std::unique_ptr< AlgorithmType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    DigestMethodType (const AlgorithmType&);

    DigestMethodType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    DigestMethodType (const DigestMethodType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual DigestMethodType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DigestMethodType&
    operator= (const DigestMethodType& x);

    virtual 
    ~DigestMethodType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
    ::xsd::cxx::tree::one< AlgorithmType > Algorithm_;
  };

  class DigestValueType: public ::xml_schema::Base64Binary
  {
    public:
    // Constructors.
    //
    DigestValueType ();

    DigestValueType (const ::xml_schema::Base64Binary&);

    DigestValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    DigestValueType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    DigestValueType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    DigestValueType (const DigestValueType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual DigestValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~DigestValueType ();
  };

  class KeyInfoType: public ::xml_schema::Type
  {
    public:
    // KeyName
    //
    typedef ::xml_schema::String KeyNameType;
    typedef ::xsd::cxx::tree::sequence< KeyNameType > KeyNameSequence;
    typedef KeyNameSequence::iterator KeyNameIterator;
    typedef KeyNameSequence::const_iterator KeyNameConstIterator;
    typedef ::xsd::cxx::tree::traits< KeyNameType, char > KeyNameTraits;

    const KeyNameSequence&
    getKeyName () const;

    KeyNameSequence&
    getKeyName ();

    void
    setKeyName (const KeyNameSequence& s);

    // KeyValue
    //
    typedef ::ds::KeyValueType KeyValueType;
    typedef ::xsd::cxx::tree::sequence< KeyValueType > KeyValueSequence;
    typedef KeyValueSequence::iterator KeyValueIterator;
    typedef KeyValueSequence::const_iterator KeyValueConstIterator;
    typedef ::xsd::cxx::tree::traits< KeyValueType, char > KeyValueTraits;

    const KeyValueSequence&
    getKeyValue () const;

    KeyValueSequence&
    getKeyValue ();

    void
    setKeyValue (const KeyValueSequence& s);

    // RetrievalMethod
    //
    typedef ::ds::RetrievalMethodType RetrievalMethodType;
    typedef ::xsd::cxx::tree::sequence< RetrievalMethodType > RetrievalMethodSequence;
    typedef RetrievalMethodSequence::iterator RetrievalMethodIterator;
    typedef RetrievalMethodSequence::const_iterator RetrievalMethodConstIterator;
    typedef ::xsd::cxx::tree::traits< RetrievalMethodType, char > RetrievalMethodTraits;

    const RetrievalMethodSequence&
    getRetrievalMethod () const;

    RetrievalMethodSequence&
    getRetrievalMethod ();

    void
    setRetrievalMethod (const RetrievalMethodSequence& s);

    // X509Data
    //
    typedef ::ds::X509DataType X509DataType;
    typedef ::xsd::cxx::tree::sequence< X509DataType > X509DataSequence;
    typedef X509DataSequence::iterator X509DataIterator;
    typedef X509DataSequence::const_iterator X509DataConstIterator;
    typedef ::xsd::cxx::tree::traits< X509DataType, char > X509DataTraits;

    const X509DataSequence&
    getX509Data () const;

    X509DataSequence&
    getX509Data ();

    void
    setX509Data (const X509DataSequence& s);

    // PGPData
    //
    typedef ::ds::PGPDataType PGPDataType;
    typedef ::xsd::cxx::tree::sequence< PGPDataType > PGPDataSequence;
    typedef PGPDataSequence::iterator PGPDataIterator;
    typedef PGPDataSequence::const_iterator PGPDataConstIterator;
    typedef ::xsd::cxx::tree::traits< PGPDataType, char > PGPDataTraits;

    const PGPDataSequence&
    getPGPData () const;

    PGPDataSequence&
    getPGPData ();

    void
    setPGPData (const PGPDataSequence& s);

    // SPKIData
    //
    typedef ::ds::SPKIDataType SPKIDataType;
    typedef ::xsd::cxx::tree::sequence< SPKIDataType > SPKIDataSequence;
    typedef SPKIDataSequence::iterator SPKIDataIterator;
    typedef SPKIDataSequence::const_iterator SPKIDataConstIterator;
    typedef ::xsd::cxx::tree::traits< SPKIDataType, char > SPKIDataTraits;

    const SPKIDataSequence&
    getSPKIData () const;

    SPKIDataSequence&
    getSPKIData ();

    void
    setSPKIData (const SPKIDataSequence& s);

    // MgmtData
    //
    typedef ::xml_schema::String MgmtDataType;
    typedef ::xsd::cxx::tree::sequence< MgmtDataType > MgmtDataSequence;
    typedef MgmtDataSequence::iterator MgmtDataIterator;
    typedef MgmtDataSequence::const_iterator MgmtDataConstIterator;
    typedef ::xsd::cxx::tree::traits< MgmtDataType, char > MgmtDataTraits;

    const MgmtDataSequence&
    getMgmtData () const;

    MgmtDataSequence&
    getMgmtData ();

    void
    setMgmtData (const MgmtDataSequence& s);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    KeyInfoType ();

    KeyInfoType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    KeyInfoType (const KeyInfoType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual KeyInfoType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    KeyInfoType&
    operator= (const KeyInfoType& x);

    virtual 
    ~KeyInfoType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    KeyNameSequence KeyName_;
    KeyValueSequence KeyValue_;
    RetrievalMethodSequence RetrievalMethod_;
    X509DataSequence X509Data_;
    PGPDataSequence PGPData_;
    SPKIDataSequence SPKIData_;
    MgmtDataSequence MgmtData_;
    AnySequence any_;
    IdOptional Id_;
  };

  class KeyValueType: public ::xml_schema::Type
  {
    public:
    // DSAKeyValue
    //
    typedef ::ds::DSAKeyValueType DSAKeyValueType;
    typedef ::xsd::cxx::tree::optional< DSAKeyValueType > DSAKeyValueOptional;
    typedef ::xsd::cxx::tree::traits< DSAKeyValueType, char > DSAKeyValueTraits;

    const DSAKeyValueOptional&
    getDSAKeyValue () const;

    DSAKeyValueOptional&
    getDSAKeyValue ();

    void
    setDSAKeyValue (const DSAKeyValueType& x);

    void
    setDSAKeyValue (const DSAKeyValueOptional& x);

    void
    setDSAKeyValue (::std::unique_ptr< DSAKeyValueType > p);

    // RSAKeyValue
    //
    typedef ::ds::RSAKeyValueType RSAKeyValueType;
    typedef ::xsd::cxx::tree::optional< RSAKeyValueType > RSAKeyValueOptional;
    typedef ::xsd::cxx::tree::traits< RSAKeyValueType, char > RSAKeyValueTraits;

    const RSAKeyValueOptional&
    getRSAKeyValue () const;

    RSAKeyValueOptional&
    getRSAKeyValue ();

    void
    setRSAKeyValue (const RSAKeyValueType& x);

    void
    setRSAKeyValue (const RSAKeyValueOptional& x);

    void
    setRSAKeyValue (::std::unique_ptr< RSAKeyValueType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_optional AnyOptional;

    const AnyOptional&
    getAny () const;

    AnyOptional&
    getAny ();

    void
    setAny (const ::xercesc::DOMElement& e);

    void
    setAny (::xercesc::DOMElement* p);

    void
    setAny (const AnyOptional& x);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    KeyValueType ();

    KeyValueType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    KeyValueType (const KeyValueType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual KeyValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    KeyValueType&
    operator= (const KeyValueType& x);

    virtual 
    ~KeyValueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    DSAKeyValueOptional DSAKeyValue_;
    RSAKeyValueOptional RSAKeyValue_;
    AnyOptional any_;
  };

  class RetrievalMethodType: public ::xml_schema::Type
  {
    public:
    // Transforms
    //
    typedef ::ds::TransformsType TransformsType;
    typedef ::xsd::cxx::tree::optional< TransformsType > TransformsOptional;
    typedef ::xsd::cxx::tree::traits< TransformsType, char > TransformsTraits;

    const TransformsOptional&
    getTransforms () const;

    TransformsOptional&
    getTransforms ();

    void
    setTransforms (const TransformsType& x);

    void
    setTransforms (const TransformsOptional& x);

    void
    setTransforms (::std::unique_ptr< TransformsType > p);

    // URI
    //
    typedef ::xml_schema::Uri URIType;
    typedef ::xsd::cxx::tree::optional< URIType > URIOptional;
    typedef ::xsd::cxx::tree::traits< URIType, char > URITraits;

    const URIOptional&
    getURI () const;

    URIOptional&
    getURI ();

    void
    setURI (const URIType& x);

    void
    setURI (const URIOptional& x);

    void
    setURI (::std::unique_ptr< URIType > p);

    // Type
    //
    typedef ::xml_schema::Uri TypeType;
    typedef ::xsd::cxx::tree::optional< TypeType > TypeOptional;
    typedef ::xsd::cxx::tree::traits< TypeType, char > TypeTraits;

    const TypeOptional&
    getType () const;

    TypeOptional&
    getType ();

    void
    setType (const TypeType& x);

    void
    setType (const TypeOptional& x);

    void
    setType (::std::unique_ptr< TypeType > p);

    // Constructors.
    //
    RetrievalMethodType ();

    RetrievalMethodType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    RetrievalMethodType (const RetrievalMethodType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual RetrievalMethodType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RetrievalMethodType&
    operator= (const RetrievalMethodType& x);

    virtual 
    ~RetrievalMethodType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TransformsOptional Transforms_;
    URIOptional URI_;
    TypeOptional Type_;
  };

  class X509DataType: public ::xml_schema::Type
  {
    public:
    // X509IssuerSerial
    //
    typedef ::ds::X509IssuerSerialType X509IssuerSerialType;
    typedef ::xsd::cxx::tree::sequence< X509IssuerSerialType > X509IssuerSerialSequence;
    typedef X509IssuerSerialSequence::iterator X509IssuerSerialIterator;
    typedef X509IssuerSerialSequence::const_iterator X509IssuerSerialConstIterator;
    typedef ::xsd::cxx::tree::traits< X509IssuerSerialType, char > X509IssuerSerialTraits;

    const X509IssuerSerialSequence&
    getX509IssuerSerial () const;

    X509IssuerSerialSequence&
    getX509IssuerSerial ();

    void
    setX509IssuerSerial (const X509IssuerSerialSequence& s);

    // X509SKI
    //
    typedef ::xml_schema::Base64Binary X509SKIType;
    typedef ::xsd::cxx::tree::sequence< X509SKIType > X509SKISequence;
    typedef X509SKISequence::iterator X509SKIIterator;
    typedef X509SKISequence::const_iterator X509SKIConstIterator;
    typedef ::xsd::cxx::tree::traits< X509SKIType, char > X509SKITraits;

    const X509SKISequence&
    getX509SKI () const;

    X509SKISequence&
    getX509SKI ();

    void
    setX509SKI (const X509SKISequence& s);

    // X509SubjectName
    //
    typedef ::xml_schema::String X509SubjectNameType;
    typedef ::xsd::cxx::tree::sequence< X509SubjectNameType > X509SubjectNameSequence;
    typedef X509SubjectNameSequence::iterator X509SubjectNameIterator;
    typedef X509SubjectNameSequence::const_iterator X509SubjectNameConstIterator;
    typedef ::xsd::cxx::tree::traits< X509SubjectNameType, char > X509SubjectNameTraits;

    const X509SubjectNameSequence&
    getX509SubjectName () const;

    X509SubjectNameSequence&
    getX509SubjectName ();

    void
    setX509SubjectName (const X509SubjectNameSequence& s);

    // X509Certificate
    //
    typedef ::xml_schema::Base64Binary X509CertificateType;
    typedef ::xsd::cxx::tree::sequence< X509CertificateType > X509CertificateSequence;
    typedef X509CertificateSequence::iterator X509CertificateIterator;
    typedef X509CertificateSequence::const_iterator X509CertificateConstIterator;
    typedef ::xsd::cxx::tree::traits< X509CertificateType, char > X509CertificateTraits;

    const X509CertificateSequence&
    getX509Certificate () const;

    X509CertificateSequence&
    getX509Certificate ();

    void
    setX509Certificate (const X509CertificateSequence& s);

    // X509CRL
    //
    typedef ::xml_schema::Base64Binary X509CRLType;
    typedef ::xsd::cxx::tree::sequence< X509CRLType > X509CRLSequence;
    typedef X509CRLSequence::iterator X509CRLIterator;
    typedef X509CRLSequence::const_iterator X509CRLConstIterator;
    typedef ::xsd::cxx::tree::traits< X509CRLType, char > X509CRLTraits;

    const X509CRLSequence&
    getX509CRL () const;

    X509CRLSequence&
    getX509CRL ();

    void
    setX509CRL (const X509CRLSequence& s);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    X509DataType ();

    X509DataType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    X509DataType (const X509DataType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual X509DataType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    X509DataType&
    operator= (const X509DataType& x);

    virtual 
    ~X509DataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    X509IssuerSerialSequence X509IssuerSerial_;
    X509SKISequence X509SKI_;
    X509SubjectNameSequence X509SubjectName_;
    X509CertificateSequence X509Certificate_;
    X509CRLSequence X509CRL_;
    AnySequence any_;
  };

  class X509IssuerSerialType: public ::xml_schema::Type
  {
    public:
    // X509IssuerName
    //
    typedef ::xml_schema::String X509IssuerNameType;
    typedef ::xsd::cxx::tree::traits< X509IssuerNameType, char > X509IssuerNameTraits;

    const X509IssuerNameType&
    getX509IssuerName () const;

    X509IssuerNameType&
    getX509IssuerName ();

    void
    setX509IssuerName (const X509IssuerNameType& x);

    void
    setX509IssuerName (::std::unique_ptr< X509IssuerNameType > p);

    // X509SerialNumber
    //
    typedef ::xml_schema::Integer X509SerialNumberType;
    typedef ::xsd::cxx::tree::traits< X509SerialNumberType, char > X509SerialNumberTraits;

    const X509SerialNumberType&
    getX509SerialNumber () const;

    X509SerialNumberType&
    getX509SerialNumber ();

    void
    setX509SerialNumber (const X509SerialNumberType& x);

    // Constructors.
    //
    X509IssuerSerialType (const X509IssuerNameType&,
                          const X509SerialNumberType&);

    X509IssuerSerialType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    X509IssuerSerialType (const X509IssuerSerialType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual X509IssuerSerialType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    X509IssuerSerialType&
    operator= (const X509IssuerSerialType& x);

    virtual 
    ~X509IssuerSerialType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< X509IssuerNameType > X509IssuerName_;
    ::xsd::cxx::tree::one< X509SerialNumberType > X509SerialNumber_;
  };

  class PGPDataType: public ::xml_schema::Type
  {
    public:
    // PGPKeyID
    //
    typedef ::xml_schema::Base64Binary PGPKeyIDType;
    typedef ::xsd::cxx::tree::optional< PGPKeyIDType > PGPKeyIDOptional;
    typedef ::xsd::cxx::tree::traits< PGPKeyIDType, char > PGPKeyIDTraits;

    const PGPKeyIDOptional&
    getPGPKeyID () const;

    PGPKeyIDOptional&
    getPGPKeyID ();

    void
    setPGPKeyID (const PGPKeyIDType& x);

    void
    setPGPKeyID (const PGPKeyIDOptional& x);

    void
    setPGPKeyID (::std::unique_ptr< PGPKeyIDType > p);

    // PGPKeyPacket
    //
    typedef ::xml_schema::Base64Binary PGPKeyPacketType;
    typedef ::xsd::cxx::tree::optional< PGPKeyPacketType > PGPKeyPacketOptional;
    typedef ::xsd::cxx::tree::traits< PGPKeyPacketType, char > PGPKeyPacketTraits;

    const PGPKeyPacketOptional&
    getPGPKeyPacket () const;

    PGPKeyPacketOptional&
    getPGPKeyPacket ();

    void
    setPGPKeyPacket (const PGPKeyPacketType& x);

    void
    setPGPKeyPacket (const PGPKeyPacketOptional& x);

    void
    setPGPKeyPacket (::std::unique_ptr< PGPKeyPacketType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // any1
    //
    typedef ::xsd::cxx::tree::element_sequence Any1Sequence;
    typedef Any1Sequence::iterator Any1Iterator;
    typedef Any1Sequence::const_iterator Any1ConstIterator;

    const Any1Sequence&
    getAny1 () const;

    Any1Sequence&
    getAny1 ();

    void
    setAny1 (const Any1Sequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    PGPDataType ();

    PGPDataType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    PGPDataType (const PGPDataType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual PGPDataType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    PGPDataType&
    operator= (const PGPDataType& x);

    virtual 
    ~PGPDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    PGPKeyIDOptional PGPKeyID_;
    PGPKeyPacketOptional PGPKeyPacket_;
    AnySequence any_;
    Any1Sequence any1_;
  };

  class SPKIDataType: public ::xml_schema::Type
  {
    public:
    // SPKISexp
    //
    typedef ::xml_schema::Base64Binary SPKISexpType;
    typedef ::xsd::cxx::tree::sequence< SPKISexpType > SPKISexpSequence;
    typedef SPKISexpSequence::iterator SPKISexpIterator;
    typedef SPKISexpSequence::const_iterator SPKISexpConstIterator;
    typedef ::xsd::cxx::tree::traits< SPKISexpType, char > SPKISexpTraits;

    const SPKISexpSequence&
    getSPKISexp () const;

    SPKISexpSequence&
    getSPKISexp ();

    void
    setSPKISexp (const SPKISexpSequence& s);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    SPKIDataType ();

    SPKIDataType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    SPKIDataType (const SPKIDataType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual SPKIDataType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SPKIDataType&
    operator= (const SPKIDataType& x);

    virtual 
    ~SPKIDataType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    SPKISexpSequence SPKISexp_;
    AnySequence any_;
  };

  class ObjectType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // MimeType
    //
    typedef ::xml_schema::String MimeTypeType;
    typedef ::xsd::cxx::tree::optional< MimeTypeType > MimeTypeOptional;
    typedef ::xsd::cxx::tree::traits< MimeTypeType, char > MimeTypeTraits;

    const MimeTypeOptional&
    getMimeType () const;

    MimeTypeOptional&
    getMimeType ();

    void
    setMimeType (const MimeTypeType& x);

    void
    setMimeType (const MimeTypeOptional& x);

    void
    setMimeType (::std::unique_ptr< MimeTypeType > p);

    // Encoding
    //
    typedef ::xml_schema::Uri EncodingType;
    typedef ::xsd::cxx::tree::optional< EncodingType > EncodingOptional;
    typedef ::xsd::cxx::tree::traits< EncodingType, char > EncodingTraits;

    const EncodingOptional&
    getEncoding () const;

    EncodingOptional&
    getEncoding ();

    void
    setEncoding (const EncodingType& x);

    void
    setEncoding (const EncodingOptional& x);

    void
    setEncoding (::std::unique_ptr< EncodingType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    ObjectType ();

    ObjectType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    ObjectType (const ObjectType& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual ObjectType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ObjectType&
    operator= (const ObjectType& x);

    virtual 
    ~ObjectType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
    IdOptional Id_;
    MimeTypeOptional MimeType_;
    EncodingOptional Encoding_;
  };

  class ManifestType: public ::xml_schema::Type
  {
    public:
    // Reference
    //
    typedef ::ds::ReferenceType ReferenceType;
    typedef ::xsd::cxx::tree::sequence< ReferenceType > ReferenceSequence;
    typedef ReferenceSequence::iterator ReferenceIterator;
    typedef ReferenceSequence::const_iterator ReferenceConstIterator;
    typedef ::xsd::cxx::tree::traits< ReferenceType, char > ReferenceTraits;

    const ReferenceSequence&
    getReference () const;

    ReferenceSequence&
    getReference ();

    void
    setReference (const ReferenceSequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Constructors.
    //
    ManifestType ();

    ManifestType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    ManifestType (const ManifestType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual ManifestType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ManifestType&
    operator= (const ManifestType& x);

    virtual 
    ~ManifestType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ReferenceSequence Reference_;
    IdOptional Id_;
  };

  class SignaturePropertiesType: public ::xml_schema::Type
  {
    public:
    // SignatureProperty
    //
    typedef ::ds::SignaturePropertyType SignaturePropertyType;
    typedef ::xsd::cxx::tree::sequence< SignaturePropertyType > SignaturePropertySequence;
    typedef SignaturePropertySequence::iterator SignaturePropertyIterator;
    typedef SignaturePropertySequence::const_iterator SignaturePropertyConstIterator;
    typedef ::xsd::cxx::tree::traits< SignaturePropertyType, char > SignaturePropertyTraits;

    const SignaturePropertySequence&
    getSignatureProperty () const;

    SignaturePropertySequence&
    getSignatureProperty ();

    void
    setSignatureProperty (const SignaturePropertySequence& s);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Constructors.
    //
    SignaturePropertiesType ();

    SignaturePropertiesType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    SignaturePropertiesType (const SignaturePropertiesType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual SignaturePropertiesType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignaturePropertiesType&
    operator= (const SignaturePropertiesType& x);

    virtual 
    ~SignaturePropertiesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SignaturePropertySequence SignatureProperty_;
    IdOptional Id_;
  };

  class SignaturePropertyType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // Target
    //
    typedef ::xml_schema::Uri TargetType;
    typedef ::xsd::cxx::tree::traits< TargetType, char > TargetTraits;

    const TargetType&
    getTarget () const;

    TargetType&
    getTarget ();

    void
    setTarget (const TargetType& x);

    void
    setTarget (::std::unique_ptr< TargetType > p);

    // Id
    //
    typedef ::xml_schema::Id IdType;
    typedef ::xsd::cxx::tree::optional< IdType > IdOptional;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdOptional&
    getId () const;

    IdOptional&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (const IdOptional& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    SignaturePropertyType (const TargetType&);

    SignaturePropertyType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    SignaturePropertyType (const SignaturePropertyType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual SignaturePropertyType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SignaturePropertyType&
    operator= (const SignaturePropertyType& x);

    virtual 
    ~SignaturePropertyType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
    ::xsd::cxx::tree::one< TargetType > Target_;
    IdOptional Id_;
  };

  class HMACOutputLengthType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >
  {
    public:
    // Constructors.
    //
    HMACOutputLengthType (const ::xml_schema::Integer&);

    HMACOutputLengthType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    HMACOutputLengthType (const ::xercesc::DOMAttr& a,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    HMACOutputLengthType (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    HMACOutputLengthType (const HMACOutputLengthType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual HMACOutputLengthType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~HMACOutputLengthType ();
  };

  class DSAKeyValueType: public ::xml_schema::Type
  {
    public:
    // P
    //
    typedef ::ds::CryptoBinary PType;
    typedef ::xsd::cxx::tree::optional< PType > POptional;
    typedef ::xsd::cxx::tree::traits< PType, char > PTraits;

    const POptional&
    getP () const;

    POptional&
    getP ();

    void
    setP (const PType& x);

    void
    setP (const POptional& x);

    void
    setP (::std::unique_ptr< PType > p);

    // Q
    //
    typedef ::ds::CryptoBinary QType;
    typedef ::xsd::cxx::tree::optional< QType > QOptional;
    typedef ::xsd::cxx::tree::traits< QType, char > QTraits;

    const QOptional&
    getQ () const;

    QOptional&
    getQ ();

    void
    setQ (const QType& x);

    void
    setQ (const QOptional& x);

    void
    setQ (::std::unique_ptr< QType > p);

    // G
    //
    typedef ::ds::CryptoBinary GType;
    typedef ::xsd::cxx::tree::optional< GType > GOptional;
    typedef ::xsd::cxx::tree::traits< GType, char > GTraits;

    const GOptional&
    getG () const;

    GOptional&
    getG ();

    void
    setG (const GType& x);

    void
    setG (const GOptional& x);

    void
    setG (::std::unique_ptr< GType > p);

    // Y
    //
    typedef ::ds::CryptoBinary YType;
    typedef ::xsd::cxx::tree::traits< YType, char > YTraits;

    const YType&
    getY () const;

    YType&
    getY ();

    void
    setY (const YType& x);

    void
    setY (::std::unique_ptr< YType > p);

    // J
    //
    typedef ::ds::CryptoBinary JType;
    typedef ::xsd::cxx::tree::optional< JType > JOptional;
    typedef ::xsd::cxx::tree::traits< JType, char > JTraits;

    const JOptional&
    getJ () const;

    JOptional&
    getJ ();

    void
    setJ (const JType& x);

    void
    setJ (const JOptional& x);

    void
    setJ (::std::unique_ptr< JType > p);

    // Seed
    //
    typedef ::ds::CryptoBinary SeedType;
    typedef ::xsd::cxx::tree::optional< SeedType > SeedOptional;
    typedef ::xsd::cxx::tree::traits< SeedType, char > SeedTraits;

    const SeedOptional&
    getSeed () const;

    SeedOptional&
    getSeed ();

    void
    setSeed (const SeedType& x);

    void
    setSeed (const SeedOptional& x);

    void
    setSeed (::std::unique_ptr< SeedType > p);

    // PgenCounter
    //
    typedef ::ds::CryptoBinary PgenCounterType;
    typedef ::xsd::cxx::tree::optional< PgenCounterType > PgenCounterOptional;
    typedef ::xsd::cxx::tree::traits< PgenCounterType, char > PgenCounterTraits;

    const PgenCounterOptional&
    getPgenCounter () const;

    PgenCounterOptional&
    getPgenCounter ();

    void
    setPgenCounter (const PgenCounterType& x);

    void
    setPgenCounter (const PgenCounterOptional& x);

    void
    setPgenCounter (::std::unique_ptr< PgenCounterType > p);

    // Constructors.
    //
    DSAKeyValueType (const YType&);

    DSAKeyValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    DSAKeyValueType (const DSAKeyValueType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual DSAKeyValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DSAKeyValueType&
    operator= (const DSAKeyValueType& x);

    virtual 
    ~DSAKeyValueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    POptional P_;
    QOptional Q_;
    GOptional G_;
    ::xsd::cxx::tree::one< YType > Y_;
    JOptional J_;
    SeedOptional Seed_;
    PgenCounterOptional PgenCounter_;
  };

  class RSAKeyValueType: public ::xml_schema::Type
  {
    public:
    // Modulus
    //
    typedef ::ds::CryptoBinary ModulusType;
    typedef ::xsd::cxx::tree::traits< ModulusType, char > ModulusTraits;

    const ModulusType&
    getModulus () const;

    ModulusType&
    getModulus ();

    void
    setModulus (const ModulusType& x);

    void
    setModulus (::std::unique_ptr< ModulusType > p);

    // Exponent
    //
    typedef ::ds::CryptoBinary ExponentType;
    typedef ::xsd::cxx::tree::traits< ExponentType, char > ExponentTraits;

    const ExponentType&
    getExponent () const;

    ExponentType&
    getExponent ();

    void
    setExponent (const ExponentType& x);

    void
    setExponent (::std::unique_ptr< ExponentType > p);

    // Constructors.
    //
    RSAKeyValueType (const ModulusType&,
                     const ExponentType&);

    RSAKeyValueType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    RSAKeyValueType (const RSAKeyValueType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual RSAKeyValueType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RSAKeyValueType&
    operator= (const RSAKeyValueType& x);

    virtual 
    ~RSAKeyValueType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModulusType > Modulus_;
    ::xsd::cxx::tree::one< ExponentType > Exponent_;
  };
}

#include <iosfwd>

namespace ds
{
  ::std::ostream&
  operator<< (::std::ostream&, const CryptoBinary&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignatureType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignatureValueType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignedInfoType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CanonicalizationMethodType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignatureMethodType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ReferenceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TransformsType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TransformType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DigestMethodType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DigestValueType&);

  ::std::ostream&
  operator<< (::std::ostream&, const KeyInfoType&);

  ::std::ostream&
  operator<< (::std::ostream&, const KeyValueType&);

  ::std::ostream&
  operator<< (::std::ostream&, const RetrievalMethodType&);

  ::std::ostream&
  operator<< (::std::ostream&, const X509DataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const X509IssuerSerialType&);

  ::std::ostream&
  operator<< (::std::ostream&, const PGPDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SPKIDataType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ObjectType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ManifestType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignaturePropertiesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SignaturePropertyType&);

  ::std::ostream&
  operator<< (::std::ostream&, const HMACOutputLengthType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DSAKeyValueType&);

  ::std::ostream&
  operator<< (::std::ostream&, const RSAKeyValueType&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace ds
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace ds
{
  void
  operator<< (::xercesc::DOMElement&, const CryptoBinary&);

  void
  operator<< (::xercesc::DOMAttr&, const CryptoBinary&);

  void
  operator<< (::xml_schema::ListStream&,
              const CryptoBinary&);

  void
  operator<< (::xercesc::DOMElement&, const SignatureType&);

  void
  operator<< (::xercesc::DOMElement&, const SignatureValueType&);

  void
  operator<< (::xercesc::DOMElement&, const SignedInfoType&);

  void
  operator<< (::xercesc::DOMElement&, const CanonicalizationMethodType&);

  void
  operator<< (::xercesc::DOMElement&, const SignatureMethodType&);

  void
  operator<< (::xercesc::DOMElement&, const ReferenceType&);

  void
  operator<< (::xercesc::DOMElement&, const TransformsType&);

  void
  operator<< (::xercesc::DOMElement&, const TransformType&);

  void
  operator<< (::xercesc::DOMElement&, const DigestMethodType&);

  void
  operator<< (::xercesc::DOMElement&, const DigestValueType&);

  void
  operator<< (::xercesc::DOMAttr&, const DigestValueType&);

  void
  operator<< (::xml_schema::ListStream&,
              const DigestValueType&);

  void
  operator<< (::xercesc::DOMElement&, const KeyInfoType&);

  void
  operator<< (::xercesc::DOMElement&, const KeyValueType&);

  void
  operator<< (::xercesc::DOMElement&, const RetrievalMethodType&);

  void
  operator<< (::xercesc::DOMElement&, const X509DataType&);

  void
  operator<< (::xercesc::DOMElement&, const X509IssuerSerialType&);

  void
  operator<< (::xercesc::DOMElement&, const PGPDataType&);

  void
  operator<< (::xercesc::DOMElement&, const SPKIDataType&);

  void
  operator<< (::xercesc::DOMElement&, const ObjectType&);

  void
  operator<< (::xercesc::DOMElement&, const ManifestType&);

  void
  operator<< (::xercesc::DOMElement&, const SignaturePropertiesType&);

  void
  operator<< (::xercesc::DOMElement&, const SignaturePropertyType&);

  void
  operator<< (::xercesc::DOMElement&, const HMACOutputLengthType&);

  void
  operator<< (::xercesc::DOMAttr&, const HMACOutputLengthType&);

  void
  operator<< (::xml_schema::ListStream&,
              const HMACOutputLengthType&);

  void
  operator<< (::xercesc::DOMElement&, const DSAKeyValueType&);

  void
  operator<< (::xercesc::DOMElement&, const RSAKeyValueType&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // XMLDSIG_CORE_SCHEMA_H
