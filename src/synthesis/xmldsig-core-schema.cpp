// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "xmldsig-core-schema.h"

namespace ds
{
  // CryptoBinary
  // 


  // SignatureType
  // 

  const SignatureType::SignedInfoType& SignatureType::
  getSignedInfo () const
  {
    return this->SignedInfo_.get ();
  }

  SignatureType::SignedInfoType& SignatureType::
  getSignedInfo ()
  {
    return this->SignedInfo_.get ();
  }

  void SignatureType::
  setSignedInfo (const SignedInfoType& x)
  {
    this->SignedInfo_.set (x);
  }

  void SignatureType::
  setSignedInfo (::std::unique_ptr< SignedInfoType > x)
  {
    this->SignedInfo_.set (std::move (x));
  }

  const SignatureType::SignatureValueType& SignatureType::
  getSignatureValue () const
  {
    return this->SignatureValue_.get ();
  }

  SignatureType::SignatureValueType& SignatureType::
  getSignatureValue ()
  {
    return this->SignatureValue_.get ();
  }

  void SignatureType::
  setSignatureValue (const SignatureValueType& x)
  {
    this->SignatureValue_.set (x);
  }

  void SignatureType::
  setSignatureValue (::std::unique_ptr< SignatureValueType > x)
  {
    this->SignatureValue_.set (std::move (x));
  }

  const SignatureType::KeyInfoOptional& SignatureType::
  getKeyInfo () const
  {
    return this->KeyInfo_;
  }

  SignatureType::KeyInfoOptional& SignatureType::
  getKeyInfo ()
  {
    return this->KeyInfo_;
  }

  void SignatureType::
  setKeyInfo (const KeyInfoType& x)
  {
    this->KeyInfo_.set (x);
  }

  void SignatureType::
  setKeyInfo (const KeyInfoOptional& x)
  {
    this->KeyInfo_ = x;
  }

  void SignatureType::
  setKeyInfo (::std::unique_ptr< KeyInfoType > x)
  {
    this->KeyInfo_.set (std::move (x));
  }

  const SignatureType::ObjectSequence& SignatureType::
  getObject () const
  {
    return this->Object_;
  }

  SignatureType::ObjectSequence& SignatureType::
  getObject ()
  {
    return this->Object_;
  }

  void SignatureType::
  setObject (const ObjectSequence& s)
  {
    this->Object_ = s;
  }

  const SignatureType::IdOptional& SignatureType::
  getId () const
  {
    return this->Id_;
  }

  SignatureType::IdOptional& SignatureType::
  getId ()
  {
    return this->Id_;
  }

  void SignatureType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SignatureType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void SignatureType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // SignatureValueType
  // 

  const SignatureValueType::IdOptional& SignatureValueType::
  getId () const
  {
    return this->Id_;
  }

  SignatureValueType::IdOptional& SignatureValueType::
  getId ()
  {
    return this->Id_;
  }

  void SignatureValueType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SignatureValueType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void SignatureValueType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // SignedInfoType
  // 

  const SignedInfoType::CanonicalizationMethodType& SignedInfoType::
  getCanonicalizationMethod () const
  {
    return this->CanonicalizationMethod_.get ();
  }

  SignedInfoType::CanonicalizationMethodType& SignedInfoType::
  getCanonicalizationMethod ()
  {
    return this->CanonicalizationMethod_.get ();
  }

  void SignedInfoType::
  setCanonicalizationMethod (const CanonicalizationMethodType& x)
  {
    this->CanonicalizationMethod_.set (x);
  }

  void SignedInfoType::
  setCanonicalizationMethod (::std::unique_ptr< CanonicalizationMethodType > x)
  {
    this->CanonicalizationMethod_.set (std::move (x));
  }

  const SignedInfoType::SignatureMethodType& SignedInfoType::
  getSignatureMethod () const
  {
    return this->SignatureMethod_.get ();
  }

  SignedInfoType::SignatureMethodType& SignedInfoType::
  getSignatureMethod ()
  {
    return this->SignatureMethod_.get ();
  }

  void SignedInfoType::
  setSignatureMethod (const SignatureMethodType& x)
  {
    this->SignatureMethod_.set (x);
  }

  void SignedInfoType::
  setSignatureMethod (::std::unique_ptr< SignatureMethodType > x)
  {
    this->SignatureMethod_.set (std::move (x));
  }

  const SignedInfoType::ReferenceSequence& SignedInfoType::
  getReference () const
  {
    return this->Reference_;
  }

  SignedInfoType::ReferenceSequence& SignedInfoType::
  getReference ()
  {
    return this->Reference_;
  }

  void SignedInfoType::
  setReference (const ReferenceSequence& s)
  {
    this->Reference_ = s;
  }

  const SignedInfoType::IdOptional& SignedInfoType::
  getId () const
  {
    return this->Id_;
  }

  SignedInfoType::IdOptional& SignedInfoType::
  getId ()
  {
    return this->Id_;
  }

  void SignedInfoType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SignedInfoType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void SignedInfoType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // CanonicalizationMethodType
  // 

  const CanonicalizationMethodType::AnySequence& CanonicalizationMethodType::
  getAny () const
  {
    return this->any_;
  }

  CanonicalizationMethodType::AnySequence& CanonicalizationMethodType::
  getAny ()
  {
    return this->any_;
  }

  void CanonicalizationMethodType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const CanonicalizationMethodType::AlgorithmType& CanonicalizationMethodType::
  getAlgorithm () const
  {
    return this->Algorithm_.get ();
  }

  CanonicalizationMethodType::AlgorithmType& CanonicalizationMethodType::
  getAlgorithm ()
  {
    return this->Algorithm_.get ();
  }

  void CanonicalizationMethodType::
  setAlgorithm (const AlgorithmType& x)
  {
    this->Algorithm_.set (x);
  }

  void CanonicalizationMethodType::
  setAlgorithm (::std::unique_ptr< AlgorithmType > x)
  {
    this->Algorithm_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& CanonicalizationMethodType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& CanonicalizationMethodType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // SignatureMethodType
  // 

  const SignatureMethodType::HMACOutputLengthOptional& SignatureMethodType::
  getHMACOutputLength () const
  {
    return this->HMACOutputLength_;
  }

  SignatureMethodType::HMACOutputLengthOptional& SignatureMethodType::
  getHMACOutputLength ()
  {
    return this->HMACOutputLength_;
  }

  void SignatureMethodType::
  setHMACOutputLength (const HMACOutputLengthType& x)
  {
    this->HMACOutputLength_.set (x);
  }

  void SignatureMethodType::
  setHMACOutputLength (const HMACOutputLengthOptional& x)
  {
    this->HMACOutputLength_ = x;
  }

  void SignatureMethodType::
  setHMACOutputLength (::std::unique_ptr< HMACOutputLengthType > x)
  {
    this->HMACOutputLength_.set (std::move (x));
  }

  const SignatureMethodType::AnySequence& SignatureMethodType::
  getAny () const
  {
    return this->any_;
  }

  SignatureMethodType::AnySequence& SignatureMethodType::
  getAny ()
  {
    return this->any_;
  }

  void SignatureMethodType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const SignatureMethodType::AlgorithmType& SignatureMethodType::
  getAlgorithm () const
  {
    return this->Algorithm_.get ();
  }

  SignatureMethodType::AlgorithmType& SignatureMethodType::
  getAlgorithm ()
  {
    return this->Algorithm_.get ();
  }

  void SignatureMethodType::
  setAlgorithm (const AlgorithmType& x)
  {
    this->Algorithm_.set (x);
  }

  void SignatureMethodType::
  setAlgorithm (::std::unique_ptr< AlgorithmType > x)
  {
    this->Algorithm_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& SignatureMethodType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& SignatureMethodType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // ReferenceType
  // 

  const ReferenceType::TransformsOptional& ReferenceType::
  getTransforms () const
  {
    return this->Transforms_;
  }

  ReferenceType::TransformsOptional& ReferenceType::
  getTransforms ()
  {
    return this->Transforms_;
  }

  void ReferenceType::
  setTransforms (const TransformsType& x)
  {
    this->Transforms_.set (x);
  }

  void ReferenceType::
  setTransforms (const TransformsOptional& x)
  {
    this->Transforms_ = x;
  }

  void ReferenceType::
  setTransforms (::std::unique_ptr< TransformsType > x)
  {
    this->Transforms_.set (std::move (x));
  }

  const ReferenceType::DigestMethodType& ReferenceType::
  getDigestMethod () const
  {
    return this->DigestMethod_.get ();
  }

  ReferenceType::DigestMethodType& ReferenceType::
  getDigestMethod ()
  {
    return this->DigestMethod_.get ();
  }

  void ReferenceType::
  setDigestMethod (const DigestMethodType& x)
  {
    this->DigestMethod_.set (x);
  }

  void ReferenceType::
  setDigestMethod (::std::unique_ptr< DigestMethodType > x)
  {
    this->DigestMethod_.set (std::move (x));
  }

  const ReferenceType::DigestValueType& ReferenceType::
  getDigestValue () const
  {
    return this->DigestValue_.get ();
  }

  ReferenceType::DigestValueType& ReferenceType::
  getDigestValue ()
  {
    return this->DigestValue_.get ();
  }

  void ReferenceType::
  setDigestValue (const DigestValueType& x)
  {
    this->DigestValue_.set (x);
  }

  void ReferenceType::
  setDigestValue (::std::unique_ptr< DigestValueType > x)
  {
    this->DigestValue_.set (std::move (x));
  }

  const ReferenceType::IdOptional& ReferenceType::
  getId () const
  {
    return this->Id_;
  }

  ReferenceType::IdOptional& ReferenceType::
  getId ()
  {
    return this->Id_;
  }

  void ReferenceType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void ReferenceType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void ReferenceType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const ReferenceType::URIOptional& ReferenceType::
  getURI () const
  {
    return this->URI_;
  }

  ReferenceType::URIOptional& ReferenceType::
  getURI ()
  {
    return this->URI_;
  }

  void ReferenceType::
  setURI (const URIType& x)
  {
    this->URI_.set (x);
  }

  void ReferenceType::
  setURI (const URIOptional& x)
  {
    this->URI_ = x;
  }

  void ReferenceType::
  setURI (::std::unique_ptr< URIType > x)
  {
    this->URI_.set (std::move (x));
  }

  const ReferenceType::TypeOptional& ReferenceType::
  getType () const
  {
    return this->Type_;
  }

  ReferenceType::TypeOptional& ReferenceType::
  getType ()
  {
    return this->Type_;
  }

  void ReferenceType::
  setType (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void ReferenceType::
  setType (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void ReferenceType::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }


  // TransformsType
  // 

  const TransformsType::TransformSequence& TransformsType::
  getTransform () const
  {
    return this->Transform_;
  }

  TransformsType::TransformSequence& TransformsType::
  getTransform ()
  {
    return this->Transform_;
  }

  void TransformsType::
  setTransform (const TransformSequence& s)
  {
    this->Transform_ = s;
  }


  // TransformType
  // 

  const TransformType::AnySequence& TransformType::
  getAny () const
  {
    return this->any_;
  }

  TransformType::AnySequence& TransformType::
  getAny ()
  {
    return this->any_;
  }

  void TransformType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const TransformType::XPathSequence& TransformType::
  getXPath () const
  {
    return this->XPath_;
  }

  TransformType::XPathSequence& TransformType::
  getXPath ()
  {
    return this->XPath_;
  }

  void TransformType::
  setXPath (const XPathSequence& s)
  {
    this->XPath_ = s;
  }

  const TransformType::AlgorithmType& TransformType::
  getAlgorithm () const
  {
    return this->Algorithm_.get ();
  }

  TransformType::AlgorithmType& TransformType::
  getAlgorithm ()
  {
    return this->Algorithm_.get ();
  }

  void TransformType::
  setAlgorithm (const AlgorithmType& x)
  {
    this->Algorithm_.set (x);
  }

  void TransformType::
  setAlgorithm (::std::unique_ptr< AlgorithmType > x)
  {
    this->Algorithm_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& TransformType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& TransformType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // DigestMethodType
  // 

  const DigestMethodType::AnySequence& DigestMethodType::
  getAny () const
  {
    return this->any_;
  }

  DigestMethodType::AnySequence& DigestMethodType::
  getAny ()
  {
    return this->any_;
  }

  void DigestMethodType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const DigestMethodType::AlgorithmType& DigestMethodType::
  getAlgorithm () const
  {
    return this->Algorithm_.get ();
  }

  DigestMethodType::AlgorithmType& DigestMethodType::
  getAlgorithm ()
  {
    return this->Algorithm_.get ();
  }

  void DigestMethodType::
  setAlgorithm (const AlgorithmType& x)
  {
    this->Algorithm_.set (x);
  }

  void DigestMethodType::
  setAlgorithm (::std::unique_ptr< AlgorithmType > x)
  {
    this->Algorithm_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& DigestMethodType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& DigestMethodType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // DigestValueType
  // 


  // KeyInfoType
  // 

  const KeyInfoType::KeyNameSequence& KeyInfoType::
  getKeyName () const
  {
    return this->KeyName_;
  }

  KeyInfoType::KeyNameSequence& KeyInfoType::
  getKeyName ()
  {
    return this->KeyName_;
  }

  void KeyInfoType::
  setKeyName (const KeyNameSequence& s)
  {
    this->KeyName_ = s;
  }

  const KeyInfoType::KeyValueSequence& KeyInfoType::
  getKeyValue () const
  {
    return this->KeyValue_;
  }

  KeyInfoType::KeyValueSequence& KeyInfoType::
  getKeyValue ()
  {
    return this->KeyValue_;
  }

  void KeyInfoType::
  setKeyValue (const KeyValueSequence& s)
  {
    this->KeyValue_ = s;
  }

  const KeyInfoType::RetrievalMethodSequence& KeyInfoType::
  getRetrievalMethod () const
  {
    return this->RetrievalMethod_;
  }

  KeyInfoType::RetrievalMethodSequence& KeyInfoType::
  getRetrievalMethod ()
  {
    return this->RetrievalMethod_;
  }

  void KeyInfoType::
  setRetrievalMethod (const RetrievalMethodSequence& s)
  {
    this->RetrievalMethod_ = s;
  }

  const KeyInfoType::X509DataSequence& KeyInfoType::
  getX509Data () const
  {
    return this->X509Data_;
  }

  KeyInfoType::X509DataSequence& KeyInfoType::
  getX509Data ()
  {
    return this->X509Data_;
  }

  void KeyInfoType::
  setX509Data (const X509DataSequence& s)
  {
    this->X509Data_ = s;
  }

  const KeyInfoType::PGPDataSequence& KeyInfoType::
  getPGPData () const
  {
    return this->PGPData_;
  }

  KeyInfoType::PGPDataSequence& KeyInfoType::
  getPGPData ()
  {
    return this->PGPData_;
  }

  void KeyInfoType::
  setPGPData (const PGPDataSequence& s)
  {
    this->PGPData_ = s;
  }

  const KeyInfoType::SPKIDataSequence& KeyInfoType::
  getSPKIData () const
  {
    return this->SPKIData_;
  }

  KeyInfoType::SPKIDataSequence& KeyInfoType::
  getSPKIData ()
  {
    return this->SPKIData_;
  }

  void KeyInfoType::
  setSPKIData (const SPKIDataSequence& s)
  {
    this->SPKIData_ = s;
  }

  const KeyInfoType::MgmtDataSequence& KeyInfoType::
  getMgmtData () const
  {
    return this->MgmtData_;
  }

  KeyInfoType::MgmtDataSequence& KeyInfoType::
  getMgmtData ()
  {
    return this->MgmtData_;
  }

  void KeyInfoType::
  setMgmtData (const MgmtDataSequence& s)
  {
    this->MgmtData_ = s;
  }

  const KeyInfoType::AnySequence& KeyInfoType::
  getAny () const
  {
    return this->any_;
  }

  KeyInfoType::AnySequence& KeyInfoType::
  getAny ()
  {
    return this->any_;
  }

  void KeyInfoType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const KeyInfoType::IdOptional& KeyInfoType::
  getId () const
  {
    return this->Id_;
  }

  KeyInfoType::IdOptional& KeyInfoType::
  getId ()
  {
    return this->Id_;
  }

  void KeyInfoType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void KeyInfoType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void KeyInfoType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& KeyInfoType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& KeyInfoType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // KeyValueType
  // 

  const KeyValueType::DSAKeyValueOptional& KeyValueType::
  getDSAKeyValue () const
  {
    return this->DSAKeyValue_;
  }

  KeyValueType::DSAKeyValueOptional& KeyValueType::
  getDSAKeyValue ()
  {
    return this->DSAKeyValue_;
  }

  void KeyValueType::
  setDSAKeyValue (const DSAKeyValueType& x)
  {
    this->DSAKeyValue_.set (x);
  }

  void KeyValueType::
  setDSAKeyValue (const DSAKeyValueOptional& x)
  {
    this->DSAKeyValue_ = x;
  }

  void KeyValueType::
  setDSAKeyValue (::std::unique_ptr< DSAKeyValueType > x)
  {
    this->DSAKeyValue_.set (std::move (x));
  }

  const KeyValueType::RSAKeyValueOptional& KeyValueType::
  getRSAKeyValue () const
  {
    return this->RSAKeyValue_;
  }

  KeyValueType::RSAKeyValueOptional& KeyValueType::
  getRSAKeyValue ()
  {
    return this->RSAKeyValue_;
  }

  void KeyValueType::
  setRSAKeyValue (const RSAKeyValueType& x)
  {
    this->RSAKeyValue_.set (x);
  }

  void KeyValueType::
  setRSAKeyValue (const RSAKeyValueOptional& x)
  {
    this->RSAKeyValue_ = x;
  }

  void KeyValueType::
  setRSAKeyValue (::std::unique_ptr< RSAKeyValueType > x)
  {
    this->RSAKeyValue_.set (std::move (x));
  }

  const KeyValueType::AnyOptional& KeyValueType::
  getAny () const
  {
    return this->any_;
  }

  KeyValueType::AnyOptional& KeyValueType::
  getAny ()
  {
    return this->any_;
  }

  void KeyValueType::
  setAny (const ::xercesc::DOMElement& e)
  {
    this->any_.set (e);
  }

  void KeyValueType::
  setAny (::xercesc::DOMElement* e)
  {
    this->any_.set (e);
  }

  void KeyValueType::
  setAny (const AnyOptional& x)
  {
    this->any_ = x;
  }

  const ::xercesc::DOMDocument& KeyValueType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& KeyValueType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // RetrievalMethodType
  // 

  const RetrievalMethodType::TransformsOptional& RetrievalMethodType::
  getTransforms () const
  {
    return this->Transforms_;
  }

  RetrievalMethodType::TransformsOptional& RetrievalMethodType::
  getTransforms ()
  {
    return this->Transforms_;
  }

  void RetrievalMethodType::
  setTransforms (const TransformsType& x)
  {
    this->Transforms_.set (x);
  }

  void RetrievalMethodType::
  setTransforms (const TransformsOptional& x)
  {
    this->Transforms_ = x;
  }

  void RetrievalMethodType::
  setTransforms (::std::unique_ptr< TransformsType > x)
  {
    this->Transforms_.set (std::move (x));
  }

  const RetrievalMethodType::URIOptional& RetrievalMethodType::
  getURI () const
  {
    return this->URI_;
  }

  RetrievalMethodType::URIOptional& RetrievalMethodType::
  getURI ()
  {
    return this->URI_;
  }

  void RetrievalMethodType::
  setURI (const URIType& x)
  {
    this->URI_.set (x);
  }

  void RetrievalMethodType::
  setURI (const URIOptional& x)
  {
    this->URI_ = x;
  }

  void RetrievalMethodType::
  setURI (::std::unique_ptr< URIType > x)
  {
    this->URI_.set (std::move (x));
  }

  const RetrievalMethodType::TypeOptional& RetrievalMethodType::
  getType () const
  {
    return this->Type_;
  }

  RetrievalMethodType::TypeOptional& RetrievalMethodType::
  getType ()
  {
    return this->Type_;
  }

  void RetrievalMethodType::
  setType (const TypeType& x)
  {
    this->Type_.set (x);
  }

  void RetrievalMethodType::
  setType (const TypeOptional& x)
  {
    this->Type_ = x;
  }

  void RetrievalMethodType::
  setType (::std::unique_ptr< TypeType > x)
  {
    this->Type_.set (std::move (x));
  }


  // X509DataType
  // 

  const X509DataType::X509IssuerSerialSequence& X509DataType::
  getX509IssuerSerial () const
  {
    return this->X509IssuerSerial_;
  }

  X509DataType::X509IssuerSerialSequence& X509DataType::
  getX509IssuerSerial ()
  {
    return this->X509IssuerSerial_;
  }

  void X509DataType::
  setX509IssuerSerial (const X509IssuerSerialSequence& s)
  {
    this->X509IssuerSerial_ = s;
  }

  const X509DataType::X509SKISequence& X509DataType::
  getX509SKI () const
  {
    return this->X509SKI_;
  }

  X509DataType::X509SKISequence& X509DataType::
  getX509SKI ()
  {
    return this->X509SKI_;
  }

  void X509DataType::
  setX509SKI (const X509SKISequence& s)
  {
    this->X509SKI_ = s;
  }

  const X509DataType::X509SubjectNameSequence& X509DataType::
  getX509SubjectName () const
  {
    return this->X509SubjectName_;
  }

  X509DataType::X509SubjectNameSequence& X509DataType::
  getX509SubjectName ()
  {
    return this->X509SubjectName_;
  }

  void X509DataType::
  setX509SubjectName (const X509SubjectNameSequence& s)
  {
    this->X509SubjectName_ = s;
  }

  const X509DataType::X509CertificateSequence& X509DataType::
  getX509Certificate () const
  {
    return this->X509Certificate_;
  }

  X509DataType::X509CertificateSequence& X509DataType::
  getX509Certificate ()
  {
    return this->X509Certificate_;
  }

  void X509DataType::
  setX509Certificate (const X509CertificateSequence& s)
  {
    this->X509Certificate_ = s;
  }

  const X509DataType::X509CRLSequence& X509DataType::
  getX509CRL () const
  {
    return this->X509CRL_;
  }

  X509DataType::X509CRLSequence& X509DataType::
  getX509CRL ()
  {
    return this->X509CRL_;
  }

  void X509DataType::
  setX509CRL (const X509CRLSequence& s)
  {
    this->X509CRL_ = s;
  }

  const X509DataType::AnySequence& X509DataType::
  getAny () const
  {
    return this->any_;
  }

  X509DataType::AnySequence& X509DataType::
  getAny ()
  {
    return this->any_;
  }

  void X509DataType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& X509DataType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& X509DataType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // X509IssuerSerialType
  // 

  const X509IssuerSerialType::X509IssuerNameType& X509IssuerSerialType::
  getX509IssuerName () const
  {
    return this->X509IssuerName_.get ();
  }

  X509IssuerSerialType::X509IssuerNameType& X509IssuerSerialType::
  getX509IssuerName ()
  {
    return this->X509IssuerName_.get ();
  }

  void X509IssuerSerialType::
  setX509IssuerName (const X509IssuerNameType& x)
  {
    this->X509IssuerName_.set (x);
  }

  void X509IssuerSerialType::
  setX509IssuerName (::std::unique_ptr< X509IssuerNameType > x)
  {
    this->X509IssuerName_.set (std::move (x));
  }

  const X509IssuerSerialType::X509SerialNumberType& X509IssuerSerialType::
  getX509SerialNumber () const
  {
    return this->X509SerialNumber_.get ();
  }

  X509IssuerSerialType::X509SerialNumberType& X509IssuerSerialType::
  getX509SerialNumber ()
  {
    return this->X509SerialNumber_.get ();
  }

  void X509IssuerSerialType::
  setX509SerialNumber (const X509SerialNumberType& x)
  {
    this->X509SerialNumber_.set (x);
  }


  // PGPDataType
  // 

  const PGPDataType::PGPKeyIDOptional& PGPDataType::
  getPGPKeyID () const
  {
    return this->PGPKeyID_;
  }

  PGPDataType::PGPKeyIDOptional& PGPDataType::
  getPGPKeyID ()
  {
    return this->PGPKeyID_;
  }

  void PGPDataType::
  setPGPKeyID (const PGPKeyIDType& x)
  {
    this->PGPKeyID_.set (x);
  }

  void PGPDataType::
  setPGPKeyID (const PGPKeyIDOptional& x)
  {
    this->PGPKeyID_ = x;
  }

  void PGPDataType::
  setPGPKeyID (::std::unique_ptr< PGPKeyIDType > x)
  {
    this->PGPKeyID_.set (std::move (x));
  }

  const PGPDataType::PGPKeyPacketOptional& PGPDataType::
  getPGPKeyPacket () const
  {
    return this->PGPKeyPacket_;
  }

  PGPDataType::PGPKeyPacketOptional& PGPDataType::
  getPGPKeyPacket ()
  {
    return this->PGPKeyPacket_;
  }

  void PGPDataType::
  setPGPKeyPacket (const PGPKeyPacketType& x)
  {
    this->PGPKeyPacket_.set (x);
  }

  void PGPDataType::
  setPGPKeyPacket (const PGPKeyPacketOptional& x)
  {
    this->PGPKeyPacket_ = x;
  }

  void PGPDataType::
  setPGPKeyPacket (::std::unique_ptr< PGPKeyPacketType > x)
  {
    this->PGPKeyPacket_.set (std::move (x));
  }

  const PGPDataType::AnySequence& PGPDataType::
  getAny () const
  {
    return this->any_;
  }

  PGPDataType::AnySequence& PGPDataType::
  getAny ()
  {
    return this->any_;
  }

  void PGPDataType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const PGPDataType::Any1Sequence& PGPDataType::
  getAny1 () const
  {
    return this->any1_;
  }

  PGPDataType::Any1Sequence& PGPDataType::
  getAny1 ()
  {
    return this->any1_;
  }

  void PGPDataType::
  setAny1 (const Any1Sequence& s)
  {
    this->any1_ = s;
  }

  const ::xercesc::DOMDocument& PGPDataType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& PGPDataType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // SPKIDataType
  // 

  const SPKIDataType::SPKISexpSequence& SPKIDataType::
  getSPKISexp () const
  {
    return this->SPKISexp_;
  }

  SPKIDataType::SPKISexpSequence& SPKIDataType::
  getSPKISexp ()
  {
    return this->SPKISexp_;
  }

  void SPKIDataType::
  setSPKISexp (const SPKISexpSequence& s)
  {
    this->SPKISexp_ = s;
  }

  const SPKIDataType::AnySequence& SPKIDataType::
  getAny () const
  {
    return this->any_;
  }

  SPKIDataType::AnySequence& SPKIDataType::
  getAny ()
  {
    return this->any_;
  }

  void SPKIDataType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& SPKIDataType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& SPKIDataType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // ObjectType
  // 

  const ObjectType::AnySequence& ObjectType::
  getAny () const
  {
    return this->any_;
  }

  ObjectType::AnySequence& ObjectType::
  getAny ()
  {
    return this->any_;
  }

  void ObjectType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ObjectType::IdOptional& ObjectType::
  getId () const
  {
    return this->Id_;
  }

  ObjectType::IdOptional& ObjectType::
  getId ()
  {
    return this->Id_;
  }

  void ObjectType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void ObjectType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void ObjectType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const ObjectType::MimeTypeOptional& ObjectType::
  getMimeType () const
  {
    return this->MimeType_;
  }

  ObjectType::MimeTypeOptional& ObjectType::
  getMimeType ()
  {
    return this->MimeType_;
  }

  void ObjectType::
  setMimeType (const MimeTypeType& x)
  {
    this->MimeType_.set (x);
  }

  void ObjectType::
  setMimeType (const MimeTypeOptional& x)
  {
    this->MimeType_ = x;
  }

  void ObjectType::
  setMimeType (::std::unique_ptr< MimeTypeType > x)
  {
    this->MimeType_.set (std::move (x));
  }

  const ObjectType::EncodingOptional& ObjectType::
  getEncoding () const
  {
    return this->Encoding_;
  }

  ObjectType::EncodingOptional& ObjectType::
  getEncoding ()
  {
    return this->Encoding_;
  }

  void ObjectType::
  setEncoding (const EncodingType& x)
  {
    this->Encoding_.set (x);
  }

  void ObjectType::
  setEncoding (const EncodingOptional& x)
  {
    this->Encoding_ = x;
  }

  void ObjectType::
  setEncoding (::std::unique_ptr< EncodingType > x)
  {
    this->Encoding_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& ObjectType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& ObjectType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // ManifestType
  // 

  const ManifestType::ReferenceSequence& ManifestType::
  getReference () const
  {
    return this->Reference_;
  }

  ManifestType::ReferenceSequence& ManifestType::
  getReference ()
  {
    return this->Reference_;
  }

  void ManifestType::
  setReference (const ReferenceSequence& s)
  {
    this->Reference_ = s;
  }

  const ManifestType::IdOptional& ManifestType::
  getId () const
  {
    return this->Id_;
  }

  ManifestType::IdOptional& ManifestType::
  getId ()
  {
    return this->Id_;
  }

  void ManifestType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void ManifestType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void ManifestType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // SignaturePropertiesType
  // 

  const SignaturePropertiesType::SignaturePropertySequence& SignaturePropertiesType::
  getSignatureProperty () const
  {
    return this->SignatureProperty_;
  }

  SignaturePropertiesType::SignaturePropertySequence& SignaturePropertiesType::
  getSignatureProperty ()
  {
    return this->SignatureProperty_;
  }

  void SignaturePropertiesType::
  setSignatureProperty (const SignaturePropertySequence& s)
  {
    this->SignatureProperty_ = s;
  }

  const SignaturePropertiesType::IdOptional& SignaturePropertiesType::
  getId () const
  {
    return this->Id_;
  }

  SignaturePropertiesType::IdOptional& SignaturePropertiesType::
  getId ()
  {
    return this->Id_;
  }

  void SignaturePropertiesType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SignaturePropertiesType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void SignaturePropertiesType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }


  // SignaturePropertyType
  // 

  const SignaturePropertyType::AnySequence& SignaturePropertyType::
  getAny () const
  {
    return this->any_;
  }

  SignaturePropertyType::AnySequence& SignaturePropertyType::
  getAny ()
  {
    return this->any_;
  }

  void SignaturePropertyType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const SignaturePropertyType::TargetType& SignaturePropertyType::
  getTarget () const
  {
    return this->Target_.get ();
  }

  SignaturePropertyType::TargetType& SignaturePropertyType::
  getTarget ()
  {
    return this->Target_.get ();
  }

  void SignaturePropertyType::
  setTarget (const TargetType& x)
  {
    this->Target_.set (x);
  }

  void SignaturePropertyType::
  setTarget (::std::unique_ptr< TargetType > x)
  {
    this->Target_.set (std::move (x));
  }

  const SignaturePropertyType::IdOptional& SignaturePropertyType::
  getId () const
  {
    return this->Id_;
  }

  SignaturePropertyType::IdOptional& SignaturePropertyType::
  getId ()
  {
    return this->Id_;
  }

  void SignaturePropertyType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SignaturePropertyType::
  setId (const IdOptional& x)
  {
    this->Id_ = x;
  }

  void SignaturePropertyType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const ::xercesc::DOMDocument& SignaturePropertyType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& SignaturePropertyType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // HMACOutputLengthType
  // 


  // DSAKeyValueType
  // 

  const DSAKeyValueType::POptional& DSAKeyValueType::
  getP () const
  {
    return this->P_;
  }

  DSAKeyValueType::POptional& DSAKeyValueType::
  getP ()
  {
    return this->P_;
  }

  void DSAKeyValueType::
  setP (const PType& x)
  {
    this->P_.set (x);
  }

  void DSAKeyValueType::
  setP (const POptional& x)
  {
    this->P_ = x;
  }

  void DSAKeyValueType::
  setP (::std::unique_ptr< PType > x)
  {
    this->P_.set (std::move (x));
  }

  const DSAKeyValueType::QOptional& DSAKeyValueType::
  getQ () const
  {
    return this->Q_;
  }

  DSAKeyValueType::QOptional& DSAKeyValueType::
  getQ ()
  {
    return this->Q_;
  }

  void DSAKeyValueType::
  setQ (const QType& x)
  {
    this->Q_.set (x);
  }

  void DSAKeyValueType::
  setQ (const QOptional& x)
  {
    this->Q_ = x;
  }

  void DSAKeyValueType::
  setQ (::std::unique_ptr< QType > x)
  {
    this->Q_.set (std::move (x));
  }

  const DSAKeyValueType::GOptional& DSAKeyValueType::
  getG () const
  {
    return this->G_;
  }

  DSAKeyValueType::GOptional& DSAKeyValueType::
  getG ()
  {
    return this->G_;
  }

  void DSAKeyValueType::
  setG (const GType& x)
  {
    this->G_.set (x);
  }

  void DSAKeyValueType::
  setG (const GOptional& x)
  {
    this->G_ = x;
  }

  void DSAKeyValueType::
  setG (::std::unique_ptr< GType > x)
  {
    this->G_.set (std::move (x));
  }

  const DSAKeyValueType::YType& DSAKeyValueType::
  getY () const
  {
    return this->Y_.get ();
  }

  DSAKeyValueType::YType& DSAKeyValueType::
  getY ()
  {
    return this->Y_.get ();
  }

  void DSAKeyValueType::
  setY (const YType& x)
  {
    this->Y_.set (x);
  }

  void DSAKeyValueType::
  setY (::std::unique_ptr< YType > x)
  {
    this->Y_.set (std::move (x));
  }

  const DSAKeyValueType::JOptional& DSAKeyValueType::
  getJ () const
  {
    return this->J_;
  }

  DSAKeyValueType::JOptional& DSAKeyValueType::
  getJ ()
  {
    return this->J_;
  }

  void DSAKeyValueType::
  setJ (const JType& x)
  {
    this->J_.set (x);
  }

  void DSAKeyValueType::
  setJ (const JOptional& x)
  {
    this->J_ = x;
  }

  void DSAKeyValueType::
  setJ (::std::unique_ptr< JType > x)
  {
    this->J_.set (std::move (x));
  }

  const DSAKeyValueType::SeedOptional& DSAKeyValueType::
  getSeed () const
  {
    return this->Seed_;
  }

  DSAKeyValueType::SeedOptional& DSAKeyValueType::
  getSeed ()
  {
    return this->Seed_;
  }

  void DSAKeyValueType::
  setSeed (const SeedType& x)
  {
    this->Seed_.set (x);
  }

  void DSAKeyValueType::
  setSeed (const SeedOptional& x)
  {
    this->Seed_ = x;
  }

  void DSAKeyValueType::
  setSeed (::std::unique_ptr< SeedType > x)
  {
    this->Seed_.set (std::move (x));
  }

  const DSAKeyValueType::PgenCounterOptional& DSAKeyValueType::
  getPgenCounter () const
  {
    return this->PgenCounter_;
  }

  DSAKeyValueType::PgenCounterOptional& DSAKeyValueType::
  getPgenCounter ()
  {
    return this->PgenCounter_;
  }

  void DSAKeyValueType::
  setPgenCounter (const PgenCounterType& x)
  {
    this->PgenCounter_.set (x);
  }

  void DSAKeyValueType::
  setPgenCounter (const PgenCounterOptional& x)
  {
    this->PgenCounter_ = x;
  }

  void DSAKeyValueType::
  setPgenCounter (::std::unique_ptr< PgenCounterType > x)
  {
    this->PgenCounter_.set (std::move (x));
  }


  // RSAKeyValueType
  // 

  const RSAKeyValueType::ModulusType& RSAKeyValueType::
  getModulus () const
  {
    return this->Modulus_.get ();
  }

  RSAKeyValueType::ModulusType& RSAKeyValueType::
  getModulus ()
  {
    return this->Modulus_.get ();
  }

  void RSAKeyValueType::
  setModulus (const ModulusType& x)
  {
    this->Modulus_.set (x);
  }

  void RSAKeyValueType::
  setModulus (::std::unique_ptr< ModulusType > x)
  {
    this->Modulus_.set (std::move (x));
  }

  const RSAKeyValueType::ExponentType& RSAKeyValueType::
  getExponent () const
  {
    return this->Exponent_.get ();
  }

  RSAKeyValueType::ExponentType& RSAKeyValueType::
  getExponent ()
  {
    return this->Exponent_.get ();
  }

  void RSAKeyValueType::
  setExponent (const ExponentType& x)
  {
    this->Exponent_.set (x);
  }

  void RSAKeyValueType::
  setExponent (::std::unique_ptr< ExponentType > x)
  {
    this->Exponent_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace ds
{
  // CryptoBinary
  //

  CryptoBinary::
  CryptoBinary ()
  : ::xml_schema::Base64Binary ()
  {
  }

  CryptoBinary::
  CryptoBinary (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
  : ::xml_schema::Base64Binary (_xsd_Base64Binary_base)
  {
  }

  CryptoBinary::
  CryptoBinary (const CryptoBinary& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (x, f, c)
  {
  }

  CryptoBinary::
  CryptoBinary (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (e, f, c)
  {
  }

  CryptoBinary::
  CryptoBinary (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (a, f, c)
  {
  }

  CryptoBinary::
  CryptoBinary (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (s, e, f, c)
  {
  }

  CryptoBinary* CryptoBinary::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CryptoBinary (*this, f, c);
  }

  CryptoBinary::
  ~CryptoBinary ()
  {
  }

  // SignatureType
  //

  SignatureType::
  SignatureType (const SignedInfoType& SignedInfo,
                 const SignatureValueType& SignatureValue)
  : ::xml_schema::Type (),
    SignedInfo_ (SignedInfo, this),
    SignatureValue_ (SignatureValue, this),
    KeyInfo_ (this),
    Object_ (this),
    Id_ (this)
  {
  }

  SignatureType::
  SignatureType (::std::unique_ptr< SignedInfoType > SignedInfo,
                 ::std::unique_ptr< SignatureValueType > SignatureValue)
  : ::xml_schema::Type (),
    SignedInfo_ (std::move (SignedInfo), this),
    SignatureValue_ (std::move (SignatureValue), this),
    KeyInfo_ (this),
    Object_ (this),
    Id_ (this)
  {
  }

  SignatureType::
  SignatureType (const SignatureType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SignedInfo_ (x.SignedInfo_, f, this),
    SignatureValue_ (x.SignatureValue_, f, this),
    KeyInfo_ (x.KeyInfo_, f, this),
    Object_ (x.Object_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  SignatureType::
  SignatureType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SignedInfo_ (this),
    SignatureValue_ (this),
    KeyInfo_ (this),
    Object_ (this),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SignatureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SignedInfo
      //
      if (n.name () == "SignedInfo" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SignedInfoType > r (
          SignedInfoTraits::create (i, f, this));

        if (!SignedInfo_.present ())
        {
          this->SignedInfo_.set (::std::move (r));
          continue;
        }
      }

      // SignatureValue
      //
      if (n.name () == "SignatureValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SignatureValueType > r (
          SignatureValueTraits::create (i, f, this));

        if (!SignatureValue_.present ())
        {
          this->SignatureValue_.set (::std::move (r));
          continue;
        }
      }

      // KeyInfo
      //
      if (n.name () == "KeyInfo" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< KeyInfoType > r (
          KeyInfoTraits::create (i, f, this));

        if (!this->KeyInfo_)
        {
          this->KeyInfo_.set (::std::move (r));
          continue;
        }
      }

      // Object
      //
      if (n.name () == "Object" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< ObjectType > r (
          ObjectTraits::create (i, f, this));

        this->Object_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!SignedInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SignedInfo",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!SignatureValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SignatureValue",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  SignatureType* SignatureType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignatureType (*this, f, c);
  }

  SignatureType& SignatureType::
  operator= (const SignatureType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SignedInfo_ = x.SignedInfo_;
      this->SignatureValue_ = x.SignatureValue_;
      this->KeyInfo_ = x.KeyInfo_;
      this->Object_ = x.Object_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SignatureType::
  ~SignatureType ()
  {
  }

  // SignatureValueType
  //

  SignatureValueType::
  SignatureValueType ()
  : ::xml_schema::Base64Binary (),
    Id_ (this)
  {
  }

  SignatureValueType::
  SignatureValueType (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
  : ::xml_schema::Base64Binary (_xsd_Base64Binary_base),
    Id_ (this)
  {
  }

  SignatureValueType::
  SignatureValueType (const SignatureValueType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (x, f, c),
    Id_ (x.Id_, f, this)
  {
  }

  SignatureValueType::
  SignatureValueType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (e, f | ::xml_schema::Flags::base, c),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SignatureValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  SignatureValueType* SignatureValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignatureValueType (*this, f, c);
  }

  SignatureValueType& SignatureValueType::
  operator= (const SignatureValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Base64Binary& > (*this) = x;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SignatureValueType::
  ~SignatureValueType ()
  {
  }

  // SignedInfoType
  //

  SignedInfoType::
  SignedInfoType (const CanonicalizationMethodType& CanonicalizationMethod,
                  const SignatureMethodType& SignatureMethod)
  : ::xml_schema::Type (),
    CanonicalizationMethod_ (CanonicalizationMethod, this),
    SignatureMethod_ (SignatureMethod, this),
    Reference_ (this),
    Id_ (this)
  {
  }

  SignedInfoType::
  SignedInfoType (::std::unique_ptr< CanonicalizationMethodType > CanonicalizationMethod,
                  ::std::unique_ptr< SignatureMethodType > SignatureMethod)
  : ::xml_schema::Type (),
    CanonicalizationMethod_ (std::move (CanonicalizationMethod), this),
    SignatureMethod_ (std::move (SignatureMethod), this),
    Reference_ (this),
    Id_ (this)
  {
  }

  SignedInfoType::
  SignedInfoType (const SignedInfoType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CanonicalizationMethod_ (x.CanonicalizationMethod_, f, this),
    SignatureMethod_ (x.SignatureMethod_, f, this),
    Reference_ (x.Reference_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  SignedInfoType::
  SignedInfoType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CanonicalizationMethod_ (this),
    SignatureMethod_ (this),
    Reference_ (this),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SignedInfoType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CanonicalizationMethod
      //
      if (n.name () == "CanonicalizationMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< CanonicalizationMethodType > r (
          CanonicalizationMethodTraits::create (i, f, this));

        if (!CanonicalizationMethod_.present ())
        {
          this->CanonicalizationMethod_.set (::std::move (r));
          continue;
        }
      }

      // SignatureMethod
      //
      if (n.name () == "SignatureMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SignatureMethodType > r (
          SignatureMethodTraits::create (i, f, this));

        if (!SignatureMethod_.present ())
        {
          this->SignatureMethod_.set (::std::move (r));
          continue;
        }
      }

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< ReferenceType > r (
          ReferenceTraits::create (i, f, this));

        this->Reference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!CanonicalizationMethod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CanonicalizationMethod",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!SignatureMethod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SignatureMethod",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  SignedInfoType* SignedInfoType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignedInfoType (*this, f, c);
  }

  SignedInfoType& SignedInfoType::
  operator= (const SignedInfoType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->CanonicalizationMethod_ = x.CanonicalizationMethod_;
      this->SignatureMethod_ = x.SignatureMethod_;
      this->Reference_ = x.Reference_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SignedInfoType::
  ~SignedInfoType ()
  {
  }

  // CanonicalizationMethodType
  //

  CanonicalizationMethodType::
  CanonicalizationMethodType (const AlgorithmType& Algorithm)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Algorithm_ (Algorithm, this)
  {
  }

  CanonicalizationMethodType::
  CanonicalizationMethodType (const CanonicalizationMethodType& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ()),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  CanonicalizationMethodType::
  CanonicalizationMethodType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Algorithm_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void CanonicalizationMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if (true)
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        this->Algorithm_.set (AlgorithmTraits::create (i, f, this));
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  CanonicalizationMethodType* CanonicalizationMethodType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CanonicalizationMethodType (*this, f, c);
  }

  CanonicalizationMethodType& CanonicalizationMethodType::
  operator= (const CanonicalizationMethodType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
      this->Algorithm_ = x.Algorithm_;
    }

    return *this;
  }

  CanonicalizationMethodType::
  ~CanonicalizationMethodType ()
  {
  }

  // SignatureMethodType
  //

  SignatureMethodType::
  SignatureMethodType (const AlgorithmType& Algorithm)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    HMACOutputLength_ (this),
    any_ (this->getDomDocument ()),
    Algorithm_ (Algorithm, this)
  {
  }

  SignatureMethodType::
  SignatureMethodType (const SignatureMethodType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    HMACOutputLength_ (x.HMACOutputLength_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  SignatureMethodType::
  SignatureMethodType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    HMACOutputLength_ (this),
    any_ (this->getDomDocument ()),
    Algorithm_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SignatureMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // HMACOutputLength
      //
      if (n.name () == "HMACOutputLength" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< HMACOutputLengthType > r (
          HMACOutputLengthTraits::create (i, f, this));

        if (!this->HMACOutputLength_)
        {
          this->HMACOutputLength_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        this->Algorithm_.set (AlgorithmTraits::create (i, f, this));
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  SignatureMethodType* SignatureMethodType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignatureMethodType (*this, f, c);
  }

  SignatureMethodType& SignatureMethodType::
  operator= (const SignatureMethodType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->HMACOutputLength_ = x.HMACOutputLength_;
      this->any_ = x.any_;
      this->Algorithm_ = x.Algorithm_;
    }

    return *this;
  }

  SignatureMethodType::
  ~SignatureMethodType ()
  {
  }

  // ReferenceType
  //

  ReferenceType::
  ReferenceType (const DigestMethodType& DigestMethod,
                 const DigestValueType& DigestValue)
  : ::xml_schema::Type (),
    Transforms_ (this),
    DigestMethod_ (DigestMethod, this),
    DigestValue_ (DigestValue, this),
    Id_ (this),
    URI_ (this),
    Type_ (this)
  {
  }

  ReferenceType::
  ReferenceType (::std::unique_ptr< DigestMethodType > DigestMethod,
                 const DigestValueType& DigestValue)
  : ::xml_schema::Type (),
    Transforms_ (this),
    DigestMethod_ (std::move (DigestMethod), this),
    DigestValue_ (DigestValue, this),
    Id_ (this),
    URI_ (this),
    Type_ (this)
  {
  }

  ReferenceType::
  ReferenceType (const ReferenceType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Transforms_ (x.Transforms_, f, this),
    DigestMethod_ (x.DigestMethod_, f, this),
    DigestValue_ (x.DigestValue_, f, this),
    Id_ (x.Id_, f, this),
    URI_ (x.URI_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  ReferenceType::
  ReferenceType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Transforms_ (this),
    DigestMethod_ (this),
    DigestValue_ (this),
    Id_ (this),
    URI_ (this),
    Type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ReferenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Transforms
      //
      if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< TransformsType > r (
          TransformsTraits::create (i, f, this));

        if (!this->Transforms_)
        {
          this->Transforms_.set (::std::move (r));
          continue;
        }
      }

      // DigestMethod
      //
      if (n.name () == "DigestMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< DigestMethodType > r (
          DigestMethodTraits::create (i, f, this));

        if (!DigestMethod_.present ())
        {
          this->DigestMethod_.set (::std::move (r));
          continue;
        }
      }

      // DigestValue
      //
      if (n.name () == "DigestValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< DigestValueType > r (
          DigestValueTraits::create (i, f, this));

        if (!DigestValue_.present ())
        {
          this->DigestValue_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!DigestMethod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DigestMethod",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!DigestValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DigestValue",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "URI" && n.namespace_ ().empty ())
      {
        this->URI_.set (URITraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        this->Type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  ReferenceType* ReferenceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ReferenceType (*this, f, c);
  }

  ReferenceType& ReferenceType::
  operator= (const ReferenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Transforms_ = x.Transforms_;
      this->DigestMethod_ = x.DigestMethod_;
      this->DigestValue_ = x.DigestValue_;
      this->Id_ = x.Id_;
      this->URI_ = x.URI_;
      this->Type_ = x.Type_;
    }

    return *this;
  }

  ReferenceType::
  ~ReferenceType ()
  {
  }

  // TransformsType
  //

  TransformsType::
  TransformsType ()
  : ::xml_schema::Type (),
    Transform_ (this)
  {
  }

  TransformsType::
  TransformsType (const TransformsType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Transform_ (x.Transform_, f, this)
  {
  }

  TransformsType::
  TransformsType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Transform_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TransformsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Transform
      //
      if (n.name () == "Transform" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< TransformType > r (
          TransformTraits::create (i, f, this));

        this->Transform_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  TransformsType* TransformsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransformsType (*this, f, c);
  }

  TransformsType& TransformsType::
  operator= (const TransformsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Transform_ = x.Transform_;
    }

    return *this;
  }

  TransformsType::
  ~TransformsType ()
  {
  }

  // TransformType
  //

  TransformType::
  TransformType (const AlgorithmType& Algorithm)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    XPath_ (this),
    Algorithm_ (Algorithm, this)
  {
  }

  TransformType::
  TransformType (const TransformType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ()),
    XPath_ (x.XPath_, f, this),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  TransformType::
  TransformType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    XPath_ (this),
    Algorithm_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TransformType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      // XPath
      //
      if (n.name () == "XPath" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< XPathType > r (
          XPathTraits::create (i, f, this));

        this->XPath_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        this->Algorithm_.set (AlgorithmTraits::create (i, f, this));
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  TransformType* TransformType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TransformType (*this, f, c);
  }

  TransformType& TransformType::
  operator= (const TransformType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
      this->XPath_ = x.XPath_;
      this->Algorithm_ = x.Algorithm_;
    }

    return *this;
  }

  TransformType::
  ~TransformType ()
  {
  }

  // DigestMethodType
  //

  DigestMethodType::
  DigestMethodType (const AlgorithmType& Algorithm)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Algorithm_ (Algorithm, this)
  {
  }

  DigestMethodType::
  DigestMethodType (const DigestMethodType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ()),
    Algorithm_ (x.Algorithm_, f, this)
  {
  }

  DigestMethodType::
  DigestMethodType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Algorithm_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DigestMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Algorithm" && n.namespace_ ().empty ())
      {
        this->Algorithm_.set (AlgorithmTraits::create (i, f, this));
        continue;
      }
    }

    if (!Algorithm_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Algorithm",
        "");
    }
  }

  DigestMethodType* DigestMethodType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DigestMethodType (*this, f, c);
  }

  DigestMethodType& DigestMethodType::
  operator= (const DigestMethodType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
      this->Algorithm_ = x.Algorithm_;
    }

    return *this;
  }

  DigestMethodType::
  ~DigestMethodType ()
  {
  }

  // DigestValueType
  //

  DigestValueType::
  DigestValueType ()
  : ::xml_schema::Base64Binary ()
  {
  }

  DigestValueType::
  DigestValueType (const ::xml_schema::Base64Binary& _xsd_Base64Binary_base)
  : ::xml_schema::Base64Binary (_xsd_Base64Binary_base)
  {
  }

  DigestValueType::
  DigestValueType (const DigestValueType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (x, f, c)
  {
  }

  DigestValueType::
  DigestValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (e, f, c)
  {
  }

  DigestValueType::
  DigestValueType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (a, f, c)
  {
  }

  DigestValueType::
  DigestValueType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Base64Binary (s, e, f, c)
  {
  }

  DigestValueType* DigestValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DigestValueType (*this, f, c);
  }

  DigestValueType::
  ~DigestValueType ()
  {
  }

  // KeyInfoType
  //

  KeyInfoType::
  KeyInfoType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeyName_ (this),
    KeyValue_ (this),
    RetrievalMethod_ (this),
    X509Data_ (this),
    PGPData_ (this),
    SPKIData_ (this),
    MgmtData_ (this),
    any_ (this->getDomDocument ()),
    Id_ (this)
  {
  }

  KeyInfoType::
  KeyInfoType (const KeyInfoType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeyName_ (x.KeyName_, f, this),
    KeyValue_ (x.KeyValue_, f, this),
    RetrievalMethod_ (x.RetrievalMethod_, f, this),
    X509Data_ (x.X509Data_, f, this),
    PGPData_ (x.PGPData_, f, this),
    SPKIData_ (x.SPKIData_, f, this),
    MgmtData_ (x.MgmtData_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    Id_ (x.Id_, f, this)
  {
  }

  KeyInfoType::
  KeyInfoType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    KeyName_ (this),
    KeyValue_ (this),
    RetrievalMethod_ (this),
    X509Data_ (this),
    PGPData_ (this),
    SPKIData_ (this),
    MgmtData_ (this),
    any_ (this->getDomDocument ()),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void KeyInfoType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // KeyName
      //
      if (n.name () == "KeyName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< KeyNameType > r (
          KeyNameTraits::create (i, f, this));

        this->KeyName_.push_back (::std::move (r));
        continue;
      }

      // KeyValue
      //
      if (n.name () == "KeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< KeyValueType > r (
          KeyValueTraits::create (i, f, this));

        this->KeyValue_.push_back (::std::move (r));
        continue;
      }

      // RetrievalMethod
      //
      if (n.name () == "RetrievalMethod" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< RetrievalMethodType > r (
          RetrievalMethodTraits::create (i, f, this));

        this->RetrievalMethod_.push_back (::std::move (r));
        continue;
      }

      // X509Data
      //
      if (n.name () == "X509Data" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509DataType > r (
          X509DataTraits::create (i, f, this));

        this->X509Data_.push_back (::std::move (r));
        continue;
      }

      // PGPData
      //
      if (n.name () == "PGPData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< PGPDataType > r (
          PGPDataTraits::create (i, f, this));

        this->PGPData_.push_back (::std::move (r));
        continue;
      }

      // SPKIData
      //
      if (n.name () == "SPKIData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SPKIDataType > r (
          SPKIDataTraits::create (i, f, this));

        this->SPKIData_.push_back (::std::move (r));
        continue;
      }

      // MgmtData
      //
      if (n.name () == "MgmtData" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< MgmtDataType > r (
          MgmtDataTraits::create (i, f, this));

        this->MgmtData_.push_back (::std::move (r));
        continue;
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  KeyInfoType* KeyInfoType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class KeyInfoType (*this, f, c);
  }

  KeyInfoType& KeyInfoType::
  operator= (const KeyInfoType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->KeyName_ = x.KeyName_;
      this->KeyValue_ = x.KeyValue_;
      this->RetrievalMethod_ = x.RetrievalMethod_;
      this->X509Data_ = x.X509Data_;
      this->PGPData_ = x.PGPData_;
      this->SPKIData_ = x.SPKIData_;
      this->MgmtData_ = x.MgmtData_;
      this->any_ = x.any_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  KeyInfoType::
  ~KeyInfoType ()
  {
  }

  // KeyValueType
  //

  KeyValueType::
  KeyValueType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DSAKeyValue_ (this),
    RSAKeyValue_ (this),
    any_ (this->getDomDocument ())
  {
  }

  KeyValueType::
  KeyValueType (const KeyValueType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DSAKeyValue_ (x.DSAKeyValue_, f, this),
    RSAKeyValue_ (x.RSAKeyValue_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  KeyValueType::
  KeyValueType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    DSAKeyValue_ (this),
    RSAKeyValue_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void KeyValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DSAKeyValue
      //
      if (n.name () == "DSAKeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< DSAKeyValueType > r (
          DSAKeyValueTraits::create (i, f, this));

        if (!this->DSAKeyValue_)
        {
          this->DSAKeyValue_.set (::std::move (r));
          continue;
        }
      }

      // RSAKeyValue
      //
      if (n.name () == "RSAKeyValue" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< RSAKeyValueType > r (
          RSAKeyValueTraits::create (i, f, this));

        if (!this->RSAKeyValue_)
        {
          this->RSAKeyValue_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        if (!this->any_)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->getDomDocument ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_.set (r);
          continue;
        }
      }

      break;
    }
  }

  KeyValueType* KeyValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class KeyValueType (*this, f, c);
  }

  KeyValueType& KeyValueType::
  operator= (const KeyValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->DSAKeyValue_ = x.DSAKeyValue_;
      this->RSAKeyValue_ = x.RSAKeyValue_;
      this->any_ = x.any_;
    }

    return *this;
  }

  KeyValueType::
  ~KeyValueType ()
  {
  }

  // RetrievalMethodType
  //

  RetrievalMethodType::
  RetrievalMethodType ()
  : ::xml_schema::Type (),
    Transforms_ (this),
    URI_ (this),
    Type_ (this)
  {
  }

  RetrievalMethodType::
  RetrievalMethodType (const RetrievalMethodType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Transforms_ (x.Transforms_, f, this),
    URI_ (x.URI_, f, this),
    Type_ (x.Type_, f, this)
  {
  }

  RetrievalMethodType::
  RetrievalMethodType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Transforms_ (this),
    URI_ (this),
    Type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void RetrievalMethodType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Transforms
      //
      if (n.name () == "Transforms" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< TransformsType > r (
          TransformsTraits::create (i, f, this));

        if (!this->Transforms_)
        {
          this->Transforms_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "URI" && n.namespace_ ().empty ())
      {
        this->URI_.set (URITraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        this->Type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  RetrievalMethodType* RetrievalMethodType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RetrievalMethodType (*this, f, c);
  }

  RetrievalMethodType& RetrievalMethodType::
  operator= (const RetrievalMethodType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Transforms_ = x.Transforms_;
      this->URI_ = x.URI_;
      this->Type_ = x.Type_;
    }

    return *this;
  }

  RetrievalMethodType::
  ~RetrievalMethodType ()
  {
  }

  // X509DataType
  //

  X509DataType::
  X509DataType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    X509IssuerSerial_ (this),
    X509SKI_ (this),
    X509SubjectName_ (this),
    X509Certificate_ (this),
    X509CRL_ (this),
    any_ (this->getDomDocument ())
  {
  }

  X509DataType::
  X509DataType (const X509DataType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    X509IssuerSerial_ (x.X509IssuerSerial_, f, this),
    X509SKI_ (x.X509SKI_, f, this),
    X509SubjectName_ (x.X509SubjectName_, f, this),
    X509Certificate_ (x.X509Certificate_, f, this),
    X509CRL_ (x.X509CRL_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  X509DataType::
  X509DataType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    X509IssuerSerial_ (this),
    X509SKI_ (this),
    X509SubjectName_ (this),
    X509Certificate_ (this),
    X509CRL_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void X509DataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // X509IssuerSerial
      //
      if (n.name () == "X509IssuerSerial" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509IssuerSerialType > r (
          X509IssuerSerialTraits::create (i, f, this));

        this->X509IssuerSerial_.push_back (::std::move (r));
        continue;
      }

      // X509SKI
      //
      if (n.name () == "X509SKI" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509SKIType > r (
          X509SKITraits::create (i, f, this));

        this->X509SKI_.push_back (::std::move (r));
        continue;
      }

      // X509SubjectName
      //
      if (n.name () == "X509SubjectName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509SubjectNameType > r (
          X509SubjectNameTraits::create (i, f, this));

        this->X509SubjectName_.push_back (::std::move (r));
        continue;
      }

      // X509Certificate
      //
      if (n.name () == "X509Certificate" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509CertificateType > r (
          X509CertificateTraits::create (i, f, this));

        this->X509Certificate_.push_back (::std::move (r));
        continue;
      }

      // X509CRL
      //
      if (n.name () == "X509CRL" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509CRLType > r (
          X509CRLTraits::create (i, f, this));

        this->X509CRL_.push_back (::std::move (r));
        continue;
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }
  }

  X509DataType* X509DataType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X509DataType (*this, f, c);
  }

  X509DataType& X509DataType::
  operator= (const X509DataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->X509IssuerSerial_ = x.X509IssuerSerial_;
      this->X509SKI_ = x.X509SKI_;
      this->X509SubjectName_ = x.X509SubjectName_;
      this->X509Certificate_ = x.X509Certificate_;
      this->X509CRL_ = x.X509CRL_;
      this->any_ = x.any_;
    }

    return *this;
  }

  X509DataType::
  ~X509DataType ()
  {
  }

  // X509IssuerSerialType
  //

  X509IssuerSerialType::
  X509IssuerSerialType (const X509IssuerNameType& X509IssuerName,
                        const X509SerialNumberType& X509SerialNumber)
  : ::xml_schema::Type (),
    X509IssuerName_ (X509IssuerName, this),
    X509SerialNumber_ (X509SerialNumber, this)
  {
  }

  X509IssuerSerialType::
  X509IssuerSerialType (const X509IssuerSerialType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    X509IssuerName_ (x.X509IssuerName_, f, this),
    X509SerialNumber_ (x.X509SerialNumber_, f, this)
  {
  }

  X509IssuerSerialType::
  X509IssuerSerialType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    X509IssuerName_ (this),
    X509SerialNumber_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void X509IssuerSerialType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // X509IssuerName
      //
      if (n.name () == "X509IssuerName" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< X509IssuerNameType > r (
          X509IssuerNameTraits::create (i, f, this));

        if (!X509IssuerName_.present ())
        {
          this->X509IssuerName_.set (::std::move (r));
          continue;
        }
      }

      // X509SerialNumber
      //
      if (n.name () == "X509SerialNumber" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        if (!X509SerialNumber_.present ())
        {
          this->X509SerialNumber_.set (X509SerialNumberTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!X509IssuerName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "X509IssuerName",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!X509SerialNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "X509SerialNumber",
        "http://www.w3.org/2000/09/xmldsig#");
    }
  }

  X509IssuerSerialType* X509IssuerSerialType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class X509IssuerSerialType (*this, f, c);
  }

  X509IssuerSerialType& X509IssuerSerialType::
  operator= (const X509IssuerSerialType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->X509IssuerName_ = x.X509IssuerName_;
      this->X509SerialNumber_ = x.X509SerialNumber_;
    }

    return *this;
  }

  X509IssuerSerialType::
  ~X509IssuerSerialType ()
  {
  }

  // PGPDataType
  //

  PGPDataType::
  PGPDataType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    PGPKeyID_ (this),
    PGPKeyPacket_ (this),
    any_ (this->getDomDocument ()),
    any1_ (this->getDomDocument ())
  {
  }

  PGPDataType::
  PGPDataType (const PGPDataType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    PGPKeyID_ (x.PGPKeyID_, f, this),
    PGPKeyPacket_ (x.PGPKeyPacket_, f, this),
    any_ (x.any_, this->getDomDocument ()),
    any1_ (x.any1_, this->getDomDocument ())
  {
  }

  PGPDataType::
  PGPDataType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    PGPKeyID_ (this),
    PGPKeyPacket_ (this),
    any_ (this->getDomDocument ()),
    any1_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PGPDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PGPKeyID
      //
      if (n.name () == "PGPKeyID" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< PGPKeyIDType > r (
          PGPKeyIDTraits::create (i, f, this));

        if (!this->PGPKeyID_)
        {
          this->PGPKeyID_.set (::std::move (r));
          continue;
        }
      }

      // PGPKeyPacket
      //
      if (n.name () == "PGPKeyPacket" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< PGPKeyPacketType > r (
          PGPKeyPacketTraits::create (i, f, this));

        if (!this->PGPKeyPacket_)
        {
          this->PGPKeyPacket_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      // any1
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any1_.push_back (r);
        continue;
      }

      break;
    }
  }

  PGPDataType* PGPDataType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PGPDataType (*this, f, c);
  }

  PGPDataType& PGPDataType::
  operator= (const PGPDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->PGPKeyID_ = x.PGPKeyID_;
      this->PGPKeyPacket_ = x.PGPKeyPacket_;
      this->any_ = x.any_;
      this->any1_ = x.any1_;
    }

    return *this;
  }

  PGPDataType::
  ~PGPDataType ()
  {
  }

  // SPKIDataType
  //

  SPKIDataType::
  SPKIDataType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    SPKISexp_ (this),
    any_ (this->getDomDocument ())
  {
  }

  SPKIDataType::
  SPKIDataType (const SPKIDataType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    SPKISexp_ (x.SPKISexp_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  SPKIDataType::
  SPKIDataType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    SPKISexp_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SPKIDataType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SPKISexp
      //
      if (n.name () == "SPKISexp" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SPKISexpType > r (
          SPKISexpTraits::create (i, f, this));

        this->SPKISexp_.push_back (::std::move (r));
        continue;
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }
  }

  SPKIDataType* SPKIDataType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SPKIDataType (*this, f, c);
  }

  SPKIDataType& SPKIDataType::
  operator= (const SPKIDataType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SPKISexp_ = x.SPKISexp_;
      this->any_ = x.any_;
    }

    return *this;
  }

  SPKIDataType::
  ~SPKIDataType ()
  {
  }

  // ObjectType
  //

  ObjectType::
  ObjectType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Id_ (this),
    MimeType_ (this),
    Encoding_ (this)
  {
  }

  ObjectType::
  ObjectType (const ObjectType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ()),
    Id_ (x.Id_, f, this),
    MimeType_ (x.MimeType_, f, this),
    Encoding_ (x.Encoding_, f, this)
  {
  }

  ObjectType::
  ObjectType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Id_ (this),
    MimeType_ (this),
    Encoding_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ObjectType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if (true)
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "MimeType" && n.namespace_ ().empty ())
      {
        this->MimeType_.set (MimeTypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Encoding" && n.namespace_ ().empty ())
      {
        this->Encoding_.set (EncodingTraits::create (i, f, this));
        continue;
      }
    }
  }

  ObjectType* ObjectType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ObjectType (*this, f, c);
  }

  ObjectType& ObjectType::
  operator= (const ObjectType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
      this->Id_ = x.Id_;
      this->MimeType_ = x.MimeType_;
      this->Encoding_ = x.Encoding_;
    }

    return *this;
  }

  ObjectType::
  ~ObjectType ()
  {
  }

  // ManifestType
  //

  ManifestType::
  ManifestType ()
  : ::xml_schema::Type (),
    Reference_ (this),
    Id_ (this)
  {
  }

  ManifestType::
  ManifestType (const ManifestType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Reference_ (x.Reference_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  ManifestType::
  ManifestType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Reference_ (this),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManifestType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Reference
      //
      if (n.name () == "Reference" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< ReferenceType > r (
          ReferenceTraits::create (i, f, this));

        this->Reference_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  ManifestType* ManifestType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ManifestType (*this, f, c);
  }

  ManifestType& ManifestType::
  operator= (const ManifestType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Reference_ = x.Reference_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  ManifestType::
  ~ManifestType ()
  {
  }

  // SignaturePropertiesType
  //

  SignaturePropertiesType::
  SignaturePropertiesType ()
  : ::xml_schema::Type (),
    SignatureProperty_ (this),
    Id_ (this)
  {
  }

  SignaturePropertiesType::
  SignaturePropertiesType (const SignaturePropertiesType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SignatureProperty_ (x.SignatureProperty_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  SignaturePropertiesType::
  SignaturePropertiesType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SignatureProperty_ (this),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SignaturePropertiesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SignatureProperty
      //
      if (n.name () == "SignatureProperty" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SignaturePropertyType > r (
          SignaturePropertyTraits::create (i, f, this));

        this->SignatureProperty_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }
  }

  SignaturePropertiesType* SignaturePropertiesType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignaturePropertiesType (*this, f, c);
  }

  SignaturePropertiesType& SignaturePropertiesType::
  operator= (const SignaturePropertiesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SignatureProperty_ = x.SignatureProperty_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SignaturePropertiesType::
  ~SignaturePropertiesType ()
  {
  }

  // SignaturePropertyType
  //

  SignaturePropertyType::
  SignaturePropertyType (const TargetType& Target)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Target_ (Target, this),
    Id_ (this)
  {
  }

  SignaturePropertyType::
  SignaturePropertyType (const SignaturePropertyType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ()),
    Target_ (x.Target_, f, this),
    Id_ (x.Id_, f, this)
  {
  }

  SignaturePropertyType::
  SignaturePropertyType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ()),
    Target_ (this),
    Id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SignaturePropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.w3.org/2000/09/xmldsig#"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Target" && n.namespace_ ().empty ())
      {
        this->Target_.set (TargetTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "Id" && n.namespace_ ().empty ())
      {
        this->Id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }

    if (!Target_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Target",
        "");
    }
  }

  SignaturePropertyType* SignaturePropertyType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SignaturePropertyType (*this, f, c);
  }

  SignaturePropertyType& SignaturePropertyType::
  operator= (const SignaturePropertyType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
      this->Target_ = x.Target_;
      this->Id_ = x.Id_;
    }

    return *this;
  }

  SignaturePropertyType::
  ~SignaturePropertyType ()
  {
  }

  // HMACOutputLengthType
  //

  HMACOutputLengthType::
  HMACOutputLengthType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  HMACOutputLengthType::
  HMACOutputLengthType (const HMACOutputLengthType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  HMACOutputLengthType::
  HMACOutputLengthType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  HMACOutputLengthType::
  HMACOutputLengthType (const ::xercesc::DOMAttr& a,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  HMACOutputLengthType::
  HMACOutputLengthType (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  HMACOutputLengthType* HMACOutputLengthType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HMACOutputLengthType (*this, f, c);
  }

  HMACOutputLengthType::
  ~HMACOutputLengthType ()
  {
  }

  // DSAKeyValueType
  //

  DSAKeyValueType::
  DSAKeyValueType (const YType& Y)
  : ::xml_schema::Type (),
    P_ (this),
    Q_ (this),
    G_ (this),
    Y_ (Y, this),
    J_ (this),
    Seed_ (this),
    PgenCounter_ (this)
  {
  }

  DSAKeyValueType::
  DSAKeyValueType (const DSAKeyValueType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    P_ (x.P_, f, this),
    Q_ (x.Q_, f, this),
    G_ (x.G_, f, this),
    Y_ (x.Y_, f, this),
    J_ (x.J_, f, this),
    Seed_ (x.Seed_, f, this),
    PgenCounter_ (x.PgenCounter_, f, this)
  {
  }

  DSAKeyValueType::
  DSAKeyValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    P_ (this),
    Q_ (this),
    G_ (this),
    Y_ (this),
    J_ (this),
    Seed_ (this),
    PgenCounter_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DSAKeyValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // P
      //
      if (n.name () == "P" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< PType > r (
          PTraits::create (i, f, this));

        if (!this->P_)
        {
          this->P_.set (::std::move (r));
          continue;
        }
      }

      // Q
      //
      if (n.name () == "Q" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< QType > r (
          QTraits::create (i, f, this));

        if (!this->Q_)
        {
          this->Q_.set (::std::move (r));
          continue;
        }
      }

      // G
      //
      if (n.name () == "G" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< GType > r (
          GTraits::create (i, f, this));

        if (!this->G_)
        {
          this->G_.set (::std::move (r));
          continue;
        }
      }

      // Y
      //
      if (n.name () == "Y" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< YType > r (
          YTraits::create (i, f, this));

        if (!Y_.present ())
        {
          this->Y_.set (::std::move (r));
          continue;
        }
      }

      // J
      //
      if (n.name () == "J" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< JType > r (
          JTraits::create (i, f, this));

        if (!this->J_)
        {
          this->J_.set (::std::move (r));
          continue;
        }
      }

      // Seed
      //
      if (n.name () == "Seed" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SeedType > r (
          SeedTraits::create (i, f, this));

        if (!this->Seed_)
        {
          this->Seed_.set (::std::move (r));
          continue;
        }
      }

      // PgenCounter
      //
      if (n.name () == "PgenCounter" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< PgenCounterType > r (
          PgenCounterTraits::create (i, f, this));

        if (!this->PgenCounter_)
        {
          this->PgenCounter_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Y",
        "http://www.w3.org/2000/09/xmldsig#");
    }
  }

  DSAKeyValueType* DSAKeyValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DSAKeyValueType (*this, f, c);
  }

  DSAKeyValueType& DSAKeyValueType::
  operator= (const DSAKeyValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->P_ = x.P_;
      this->Q_ = x.Q_;
      this->G_ = x.G_;
      this->Y_ = x.Y_;
      this->J_ = x.J_;
      this->Seed_ = x.Seed_;
      this->PgenCounter_ = x.PgenCounter_;
    }

    return *this;
  }

  DSAKeyValueType::
  ~DSAKeyValueType ()
  {
  }

  // RSAKeyValueType
  //

  RSAKeyValueType::
  RSAKeyValueType (const ModulusType& Modulus,
                   const ExponentType& Exponent)
  : ::xml_schema::Type (),
    Modulus_ (Modulus, this),
    Exponent_ (Exponent, this)
  {
  }

  RSAKeyValueType::
  RSAKeyValueType (const RSAKeyValueType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Modulus_ (x.Modulus_, f, this),
    Exponent_ (x.Exponent_, f, this)
  {
  }

  RSAKeyValueType::
  RSAKeyValueType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Modulus_ (this),
    Exponent_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RSAKeyValueType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Modulus
      //
      if (n.name () == "Modulus" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< ModulusType > r (
          ModulusTraits::create (i, f, this));

        if (!Modulus_.present ())
        {
          this->Modulus_.set (::std::move (r));
          continue;
        }
      }

      // Exponent
      //
      if (n.name () == "Exponent" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< ExponentType > r (
          ExponentTraits::create (i, f, this));

        if (!Exponent_.present ())
        {
          this->Exponent_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Modulus_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Modulus",
        "http://www.w3.org/2000/09/xmldsig#");
    }

    if (!Exponent_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Exponent",
        "http://www.w3.org/2000/09/xmldsig#");
    }
  }

  RSAKeyValueType* RSAKeyValueType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RSAKeyValueType (*this, f, c);
  }

  RSAKeyValueType& RSAKeyValueType::
  operator= (const RSAKeyValueType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Modulus_ = x.Modulus_;
      this->Exponent_ = x.Exponent_;
    }

    return *this;
  }

  RSAKeyValueType::
  ~RSAKeyValueType ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace ds
{
  ::std::ostream&
  operator<< (::std::ostream& o, const CryptoBinary& i)
  {
    o << static_cast< const ::xml_schema::Base64Binary& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignatureType& i)
  {
    o << ::std::endl << "SignedInfo: " << i.getSignedInfo ();
    o << ::std::endl << "SignatureValue: " << i.getSignatureValue ();
    if (i.getKeyInfo ())
    {
      o << ::std::endl << "KeyInfo: " << *i.getKeyInfo ();
    }

    for (SignatureType::ObjectConstIterator
         b (i.getObject ().begin ()), e (i.getObject ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Object: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignatureValueType& i)
  {
    o << static_cast< const ::xml_schema::Base64Binary& > (i);

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignedInfoType& i)
  {
    o << ::std::endl << "CanonicalizationMethod: " << i.getCanonicalizationMethod ();
    o << ::std::endl << "SignatureMethod: " << i.getSignatureMethod ();
    for (SignedInfoType::ReferenceConstIterator
         b (i.getReference ().begin ()), e (i.getReference ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Reference: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CanonicalizationMethodType& i)
  {
    o << ::std::endl << "Algorithm: " << i.getAlgorithm ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignatureMethodType& i)
  {
    if (i.getHMACOutputLength ())
    {
      o << ::std::endl << "HMACOutputLength: " << *i.getHMACOutputLength ();
    }

    o << ::std::endl << "Algorithm: " << i.getAlgorithm ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ReferenceType& i)
  {
    if (i.getTransforms ())
    {
      o << ::std::endl << "Transforms: " << *i.getTransforms ();
    }

    o << ::std::endl << "DigestMethod: " << i.getDigestMethod ();
    o << ::std::endl << "DigestValue: " << i.getDigestValue ();
    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    if (i.getURI ())
    {
      o << ::std::endl << "URI: " << *i.getURI ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "Type: " << *i.getType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TransformsType& i)
  {
    for (TransformsType::TransformConstIterator
         b (i.getTransform ().begin ()), e (i.getTransform ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Transform: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TransformType& i)
  {
    for (TransformType::XPathConstIterator
         b (i.getXPath ().begin ()), e (i.getXPath ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "XPath: " << *b;
    }

    o << ::std::endl << "Algorithm: " << i.getAlgorithm ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DigestMethodType& i)
  {
    o << ::std::endl << "Algorithm: " << i.getAlgorithm ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DigestValueType& i)
  {
    o << static_cast< const ::xml_schema::Base64Binary& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const KeyInfoType& i)
  {
    for (KeyInfoType::KeyNameConstIterator
         b (i.getKeyName ().begin ()), e (i.getKeyName ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "KeyName: " << *b;
    }

    for (KeyInfoType::KeyValueConstIterator
         b (i.getKeyValue ().begin ()), e (i.getKeyValue ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "KeyValue: " << *b;
    }

    for (KeyInfoType::RetrievalMethodConstIterator
         b (i.getRetrievalMethod ().begin ()), e (i.getRetrievalMethod ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "RetrievalMethod: " << *b;
    }

    for (KeyInfoType::X509DataConstIterator
         b (i.getX509Data ().begin ()), e (i.getX509Data ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509Data: " << *b;
    }

    for (KeyInfoType::PGPDataConstIterator
         b (i.getPGPData ().begin ()), e (i.getPGPData ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "PGPData: " << *b;
    }

    for (KeyInfoType::SPKIDataConstIterator
         b (i.getSPKIData ().begin ()), e (i.getSPKIData ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SPKIData: " << *b;
    }

    for (KeyInfoType::MgmtDataConstIterator
         b (i.getMgmtData ().begin ()), e (i.getMgmtData ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "MgmtData: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const KeyValueType& i)
  {
    if (i.getDSAKeyValue ())
    {
      o << ::std::endl << "DSAKeyValue: " << *i.getDSAKeyValue ();
    }

    if (i.getRSAKeyValue ())
    {
      o << ::std::endl << "RSAKeyValue: " << *i.getRSAKeyValue ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RetrievalMethodType& i)
  {
    if (i.getTransforms ())
    {
      o << ::std::endl << "Transforms: " << *i.getTransforms ();
    }

    if (i.getURI ())
    {
      o << ::std::endl << "URI: " << *i.getURI ();
    }

    if (i.getType ())
    {
      o << ::std::endl << "Type: " << *i.getType ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const X509DataType& i)
  {
    for (X509DataType::X509IssuerSerialConstIterator
         b (i.getX509IssuerSerial ().begin ()), e (i.getX509IssuerSerial ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509IssuerSerial: " << *b;
    }

    for (X509DataType::X509SKIConstIterator
         b (i.getX509SKI ().begin ()), e (i.getX509SKI ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509SKI: " << *b;
    }

    for (X509DataType::X509SubjectNameConstIterator
         b (i.getX509SubjectName ().begin ()), e (i.getX509SubjectName ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509SubjectName: " << *b;
    }

    for (X509DataType::X509CertificateConstIterator
         b (i.getX509Certificate ().begin ()), e (i.getX509Certificate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509Certificate: " << *b;
    }

    for (X509DataType::X509CRLConstIterator
         b (i.getX509CRL ().begin ()), e (i.getX509CRL ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "X509CRL: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const X509IssuerSerialType& i)
  {
    o << ::std::endl << "X509IssuerName: " << i.getX509IssuerName ();
    o << ::std::endl << "X509SerialNumber: " << i.getX509SerialNumber ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const PGPDataType& i)
  {
    if (i.getPGPKeyID ())
    {
      o << ::std::endl << "PGPKeyID: " << *i.getPGPKeyID ();
    }

    if (i.getPGPKeyPacket ())
    {
      o << ::std::endl << "PGPKeyPacket: " << *i.getPGPKeyPacket ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SPKIDataType& i)
  {
    for (SPKIDataType::SPKISexpConstIterator
         b (i.getSPKISexp ().begin ()), e (i.getSPKISexp ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SPKISexp: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ObjectType& i)
  {
    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    if (i.getMimeType ())
    {
      o << ::std::endl << "MimeType: " << *i.getMimeType ();
    }

    if (i.getEncoding ())
    {
      o << ::std::endl << "Encoding: " << *i.getEncoding ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ManifestType& i)
  {
    for (ManifestType::ReferenceConstIterator
         b (i.getReference ().begin ()), e (i.getReference ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Reference: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignaturePropertiesType& i)
  {
    for (SignaturePropertiesType::SignaturePropertyConstIterator
         b (i.getSignatureProperty ().begin ()), e (i.getSignatureProperty ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SignatureProperty: " << *b;
    }

    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SignaturePropertyType& i)
  {
    o << ::std::endl << "Target: " << i.getTarget ();
    if (i.getId ())
    {
      o << ::std::endl << "Id: " << *i.getId ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const HMACOutputLengthType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DSAKeyValueType& i)
  {
    if (i.getP ())
    {
      o << ::std::endl << "P: " << *i.getP ();
    }

    if (i.getQ ())
    {
      o << ::std::endl << "Q: " << *i.getQ ();
    }

    if (i.getG ())
    {
      o << ::std::endl << "G: " << *i.getG ();
    }

    o << ::std::endl << "Y: " << i.getY ();
    if (i.getJ ())
    {
      o << ::std::endl << "J: " << *i.getJ ();
    }

    if (i.getSeed ())
    {
      o << ::std::endl << "Seed: " << *i.getSeed ();
    }

    if (i.getPgenCounter ())
    {
      o << ::std::endl << "PgenCounter: " << *i.getPgenCounter ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RSAKeyValueType& i)
  {
    o << ::std::endl << "Modulus: " << i.getModulus ();
    o << ::std::endl << "Exponent: " << i.getExponent ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ds
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace ds
{
  void
  operator<< (::xercesc::DOMElement& e, const CryptoBinary& i)
  {
    e << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CryptoBinary& i)
  {
    a << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CryptoBinary& i)
  {
    l << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignatureType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SignedInfo
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SignedInfo",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getSignedInfo ();
    }

    // SignatureValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SignatureValue",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getSignatureValue ();
    }

    // KeyInfo
    //
    if (i.getKeyInfo ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyInfo",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getKeyInfo ();
    }

    // Object
    //
    for (SignatureType::ObjectConstIterator
         b (i.getObject ().begin ()), n (i.getObject ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Object",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignatureValueType& i)
  {
    e << static_cast< const ::xml_schema::Base64Binary& > (i);

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignedInfoType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // CanonicalizationMethod
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CanonicalizationMethod",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getCanonicalizationMethod ();
    }

    // SignatureMethod
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SignatureMethod",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getSignatureMethod ();
    }

    // Reference
    //
    for (SignedInfoType::ReferenceConstIterator
         b (i.getReference ().begin ()), n (i.getReference ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Reference",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CanonicalizationMethodType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (CanonicalizationMethodType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.getAlgorithm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignatureMethodType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // HMACOutputLength
    //
    if (i.getHMACOutputLength ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "HMACOutputLength",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getHMACOutputLength ();
    }

    // any
    //
    for (SignatureMethodType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.getAlgorithm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ReferenceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Transforms
    //
    if (i.getTransforms ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Transforms",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getTransforms ();
    }

    // DigestMethod
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DigestMethod",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getDigestMethod ();
    }

    // DigestValue
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DigestValue",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getDigestValue ();
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }

    // URI
    //
    if (i.getURI ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "URI",
          e));

      a << *i.getURI ();
    }

    // Type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Type",
          e));

      a << *i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransformsType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Transform
    //
    for (TransformsType::TransformConstIterator
         b (i.getTransform ().begin ()), n (i.getTransform ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Transform",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TransformType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (TransformType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // XPath
    //
    for (TransformType::XPathConstIterator
         b (i.getXPath ().begin ()), n (i.getXPath ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "XPath",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.getAlgorithm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DigestMethodType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (DigestMethodType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Algorithm
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Algorithm",
          e));

      a << i.getAlgorithm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DigestValueType& i)
  {
    e << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DigestValueType& i)
  {
    a << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DigestValueType& i)
  {
    l << static_cast< const ::xml_schema::Base64Binary& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const KeyInfoType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // KeyName
    //
    for (KeyInfoType::KeyNameConstIterator
         b (i.getKeyName ().begin ()), n (i.getKeyName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyName",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // KeyValue
    //
    for (KeyInfoType::KeyValueConstIterator
         b (i.getKeyValue ().begin ()), n (i.getKeyValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyValue",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // RetrievalMethod
    //
    for (KeyInfoType::RetrievalMethodConstIterator
         b (i.getRetrievalMethod ().begin ()), n (i.getRetrievalMethod ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RetrievalMethod",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // X509Data
    //
    for (KeyInfoType::X509DataConstIterator
         b (i.getX509Data ().begin ()), n (i.getX509Data ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509Data",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // PGPData
    //
    for (KeyInfoType::PGPDataConstIterator
         b (i.getPGPData ().begin ()), n (i.getPGPData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PGPData",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // SPKIData
    //
    for (KeyInfoType::SPKIDataConstIterator
         b (i.getSPKIData ().begin ()), n (i.getSPKIData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SPKIData",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // MgmtData
    //
    for (KeyInfoType::MgmtDataConstIterator
         b (i.getMgmtData ().begin ()), n (i.getMgmtData ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MgmtData",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // any
    //
    for (KeyInfoType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const KeyValueType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // DSAKeyValue
    //
    if (i.getDSAKeyValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DSAKeyValue",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getDSAKeyValue ();
    }

    // RSAKeyValue
    //
    if (i.getRSAKeyValue ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RSAKeyValue",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getRSAKeyValue ();
    }

    // any
    //
    if (i.getAny ())
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*i.getAny ())), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RetrievalMethodType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Transforms
    //
    if (i.getTransforms ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Transforms",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getTransforms ();
    }

    // URI
    //
    if (i.getURI ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "URI",
          e));

      a << *i.getURI ();
    }

    // Type
    //
    if (i.getType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Type",
          e));

      a << *i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X509DataType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // X509IssuerSerial
    //
    for (X509DataType::X509IssuerSerialConstIterator
         b (i.getX509IssuerSerial ().begin ()), n (i.getX509IssuerSerial ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509IssuerSerial",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // X509SKI
    //
    for (X509DataType::X509SKIConstIterator
         b (i.getX509SKI ().begin ()), n (i.getX509SKI ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509SKI",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // X509SubjectName
    //
    for (X509DataType::X509SubjectNameConstIterator
         b (i.getX509SubjectName ().begin ()), n (i.getX509SubjectName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509SubjectName",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // X509Certificate
    //
    for (X509DataType::X509CertificateConstIterator
         b (i.getX509Certificate ().begin ()), n (i.getX509Certificate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509Certificate",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // X509CRL
    //
    for (X509DataType::X509CRLConstIterator
         b (i.getX509CRL ().begin ()), n (i.getX509CRL ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509CRL",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // any
    //
    for (X509DataType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const X509IssuerSerialType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // X509IssuerName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509IssuerName",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getX509IssuerName ();
    }

    // X509SerialNumber
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "X509SerialNumber",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getX509SerialNumber ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const PGPDataType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PGPKeyID
    //
    if (i.getPGPKeyID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PGPKeyID",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getPGPKeyID ();
    }

    // PGPKeyPacket
    //
    if (i.getPGPKeyPacket ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PGPKeyPacket",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getPGPKeyPacket ();
    }

    // any
    //
    for (PGPDataType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // any1
    //
    for (PGPDataType::Any1ConstIterator
         b (i.getAny1 ().begin ()), n (i.getAny1 ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SPKIDataType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SPKISexp
    //
    for (SPKIDataType::SPKISexpConstIterator
         b (i.getSPKISexp ().begin ()), n (i.getSPKISexp ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SPKISexp",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // any
    //
    for (SPKIDataType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ObjectType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (ObjectType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }

    // MimeType
    //
    if (i.getMimeType ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "MimeType",
          e));

      a << *i.getMimeType ();
    }

    // Encoding
    //
    if (i.getEncoding ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Encoding",
          e));

      a << *i.getEncoding ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ManifestType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Reference
    //
    for (ManifestType::ReferenceConstIterator
         b (i.getReference ().begin ()), n (i.getReference ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Reference",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignaturePropertiesType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SignatureProperty
    //
    for (SignaturePropertiesType::SignaturePropertyConstIterator
         b (i.getSignatureProperty ().begin ()), n (i.getSignatureProperty ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SignatureProperty",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *b;
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SignaturePropertyType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (SignaturePropertyType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }

    // Target
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Target",
          e));

      a << i.getTarget ();
    }

    // Id
    //
    if (i.getId ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Id",
          e));

      a << *i.getId ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const HMACOutputLengthType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const HMACOutputLengthType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const HMACOutputLengthType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DSAKeyValueType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // P
    //
    if (i.getP ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "P",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getP ();
    }

    // Q
    //
    if (i.getQ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Q",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getQ ();
    }

    // G
    //
    if (i.getG ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "G",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getG ();
    }

    // Y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Y",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getY ();
    }

    // J
    //
    if (i.getJ ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "J",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getJ ();
    }

    // Seed
    //
    if (i.getSeed ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Seed",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getSeed ();
    }

    // PgenCounter
    //
    if (i.getPgenCounter ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PgenCounter",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getPgenCounter ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RSAKeyValueType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Modulus
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Modulus",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getModulus ();
    }

    // Exponent
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Exponent",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << i.getExponent ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

