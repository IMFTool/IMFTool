// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

#ifndef ST0433_DCML_TYPES_H
#define ST0433_DCML_TYPES_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (LIBXSD_VERSION != 400002000000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace dcml
{
  class UUIDType;
  class UserTextType;
  class RationalType_base;
  class RationalType;
  class TemperatureUnitsToken;
  class VoltageUnitsToken;
  class CurrentUnitsToken;
  class CurrentModeToken;
  class TimeUnitToken;
  class TemperatureType;
  class VoltageType;
  class CurrentType;
  class DurationType;
  class RateType;
  class DeviceIdentifierUnion;
  class DeviceIdentifierPolyType;
  class DeviceIdentifierListType;
  class DeviceTypeType;
  class ScopedTokenType;
  class NamedParmType;
  class ParameterListType;
  class VersionInfoListType;
  class DeviceDescriptionType;
  class DeviceIdentifierPolyType_idtypeType;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "xmldsig-core-schema.h"

namespace dcml
{
  class UUIDType: public ::xml_schema::Uri
  {
    public:
    // Constructors.
    //
    UUIDType (const ::xml_schema::Uri&);

    UUIDType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    UUIDType (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    UUIDType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    UUIDType (const UUIDType& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual UUIDType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

#ifdef XSD_CXX11
    UUIDType&
    operator= (const UUIDType&) = default;
#endif

    virtual 
    ~UUIDType ();
  };

  class UserTextType: public ::xml_schema::String
  {
    public:
    // language
    //
    typedef ::xml_schema::Language LanguageType;
    typedef ::xsd::cxx::tree::traits< LanguageType, char > LanguageTraits;

    const LanguageType&
    getLanguage () const;

    LanguageType&
    getLanguage ();

    void
    setLanguage (const LanguageType& x);

    void
    setLanguage (::std::unique_ptr< LanguageType > p);

    static const LanguageType&
    getLanguageDefaultValue ();

    // Constructors.
    //
    UserTextType ();

    UserTextType (const char*);

    UserTextType (const ::std::string&);

    UserTextType (const ::xml_schema::String&);

    UserTextType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    UserTextType (const UserTextType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual UserTextType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    UserTextType&
    operator= (const UserTextType& x);

    virtual 
    ~UserTextType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LanguageType > language_;
    static const LanguageType language_default_value_;
  };

  class RationalType_base: public ::xml_schema::SimpleType,
    public ::xsd::cxx::tree::list< ::xml_schema::Long, char >
  {
    public:
    RationalType_base ();

    RationalType_base (size_type n, const ::xml_schema::Long& x);

    template < typename I >
    RationalType_base (const I& begin, const I& end)
    : ::xsd::cxx::tree::list< ::xml_schema::Long, char > (begin, end, this)
    {
    }

    RationalType_base (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RationalType_base (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RationalType_base (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    RationalType_base (const RationalType_base& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    RationalType_base&
    operator= (const RationalType_base&) = default;
#endif

    virtual RationalType_base*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~RationalType_base ();
  };

  class RationalType: public ::dcml::RationalType_base
  {
    public:
    // Constructors.
    //
    RationalType ();

    RationalType (const ::dcml::RationalType_base&);

    RationalType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    RationalType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    RationalType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    RationalType (const RationalType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual RationalType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

#ifdef XSD_CXX11
    RationalType&
    operator= (const RationalType&) = default;
#endif

    virtual 
    ~RationalType ();
  };

  class TemperatureUnitsToken: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      celsius,
      fahrenheit,
      kelvin
    };

    TemperatureUnitsToken (Value v);

    TemperatureUnitsToken (const char* v);

    TemperatureUnitsToken (const ::std::string& v);

    TemperatureUnitsToken (const ::xml_schema::Token& v);

    TemperatureUnitsToken (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    TemperatureUnitsToken (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    TemperatureUnitsToken (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    TemperatureUnitsToken (const TemperatureUnitsToken& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    TemperatureUnitsToken&
    operator= (const TemperatureUnitsToken&) = default;
#endif

    virtual TemperatureUnitsToken*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TemperatureUnitsToken&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_TemperatureUnitsToken_convert ();
    }

    protected:
    Value
    _xsd_TemperatureUnitsToken_convert () const;

    public:
    static const char* const _xsd_TemperatureUnitsToken_literals_[3];
    static const Value _xsd_TemperatureUnitsToken_indexes_[3];
  };

  class VoltageUnitsToken: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      volts,
      millivolts,
      microvolts
    };

    VoltageUnitsToken (Value v);

    VoltageUnitsToken (const char* v);

    VoltageUnitsToken (const ::std::string& v);

    VoltageUnitsToken (const ::xml_schema::Token& v);

    VoltageUnitsToken (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    VoltageUnitsToken (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    VoltageUnitsToken (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    VoltageUnitsToken (const VoltageUnitsToken& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    VoltageUnitsToken&
    operator= (const VoltageUnitsToken&) = default;
#endif

    virtual VoltageUnitsToken*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    VoltageUnitsToken&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_VoltageUnitsToken_convert ();
    }

    protected:
    Value
    _xsd_VoltageUnitsToken_convert () const;

    public:
    static const char* const _xsd_VoltageUnitsToken_literals_[3];
    static const Value _xsd_VoltageUnitsToken_indexes_[3];
  };

  class CurrentUnitsToken: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      amps,
      milliamps
    };

    CurrentUnitsToken (Value v);

    CurrentUnitsToken (const char* v);

    CurrentUnitsToken (const ::std::string& v);

    CurrentUnitsToken (const ::xml_schema::Token& v);

    CurrentUnitsToken (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    CurrentUnitsToken (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    CurrentUnitsToken (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    CurrentUnitsToken (const CurrentUnitsToken& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    CurrentUnitsToken&
    operator= (const CurrentUnitsToken&) = default;
#endif

    virtual CurrentUnitsToken*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CurrentUnitsToken&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_CurrentUnitsToken_convert ();
    }

    protected:
    Value
    _xsd_CurrentUnitsToken_convert () const;

    public:
    static const char* const _xsd_CurrentUnitsToken_literals_[2];
    static const Value _xsd_CurrentUnitsToken_indexes_[2];
  };

  class CurrentModeToken: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      AC,
      DC
    };

    CurrentModeToken (Value v);

    CurrentModeToken (const char* v);

    CurrentModeToken (const ::std::string& v);

    CurrentModeToken (const ::xml_schema::Token& v);

    CurrentModeToken (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CurrentModeToken (const ::xercesc::DOMAttr& a,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CurrentModeToken (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    CurrentModeToken (const CurrentModeToken& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    CurrentModeToken&
    operator= (const CurrentModeToken&) = default;
#endif

    virtual CurrentModeToken*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CurrentModeToken&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_CurrentModeToken_convert ();
    }

    protected:
    Value
    _xsd_CurrentModeToken_convert () const;

    public:
    static const char* const _xsd_CurrentModeToken_literals_[2];
    static const Value _xsd_CurrentModeToken_indexes_[2];
  };

  class TimeUnitToken: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      week,
      day,
      hour,
      minute,
      second,
      millisecond,
      microsecond
    };

    TimeUnitToken (Value v);

    TimeUnitToken (const char* v);

    TimeUnitToken (const ::std::string& v);

    TimeUnitToken (const ::xml_schema::Token& v);

    TimeUnitToken (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    TimeUnitToken (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    TimeUnitToken (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    TimeUnitToken (const TimeUnitToken& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    TimeUnitToken&
    operator= (const TimeUnitToken&) = default;
#endif

    virtual TimeUnitToken*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TimeUnitToken&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_TimeUnitToken_convert ();
    }

    protected:
    Value
    _xsd_TimeUnitToken_convert () const;

    public:
    static const char* const _xsd_TimeUnitToken_literals_[7];
    static const Value _xsd_TimeUnitToken_indexes_[7];
  };

  class TemperatureType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // units
    //
    typedef ::dcml::TemperatureUnitsToken UnitsType;
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    const UnitsType&
    getUnits () const;

    UnitsType&
    getUnits ();

    void
    setUnits (const UnitsType& x);

    void
    setUnits (::std::unique_ptr< UnitsType > p);

    // Constructors.
    //
    TemperatureType (const ::xml_schema::Decimal&,
                     const UnitsType&);

    TemperatureType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    TemperatureType (const TemperatureType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual TemperatureType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TemperatureType&
    operator= (const TemperatureType& x);

    virtual 
    ~TemperatureType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitsType > units_;
  };

  class VoltageType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // units
    //
    typedef ::dcml::VoltageUnitsToken UnitsType;
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    const UnitsType&
    getUnits () const;

    UnitsType&
    getUnits ();

    void
    setUnits (const UnitsType& x);

    void
    setUnits (::std::unique_ptr< UnitsType > p);

    // mode
    //
    typedef ::dcml::CurrentModeToken ModeType;
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    const ModeType&
    getMode () const;

    ModeType&
    getMode ();

    void
    setMode (const ModeType& x);

    void
    setMode (::std::unique_ptr< ModeType > p);

    // Constructors.
    //
    VoltageType (const ::xml_schema::Decimal&,
                 const UnitsType&,
                 const ModeType&);

    VoltageType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    VoltageType (const VoltageType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual VoltageType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    VoltageType&
    operator= (const VoltageType& x);

    virtual 
    ~VoltageType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitsType > units_;
    ::xsd::cxx::tree::one< ModeType > mode_;
  };

  class CurrentType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // units
    //
    typedef ::dcml::CurrentUnitsToken UnitsType;
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    const UnitsType&
    getUnits () const;

    UnitsType&
    getUnits ();

    void
    setUnits (const UnitsType& x);

    void
    setUnits (::std::unique_ptr< UnitsType > p);

    // mode
    //
    typedef ::dcml::CurrentModeToken ModeType;
    typedef ::xsd::cxx::tree::traits< ModeType, char > ModeTraits;

    const ModeType&
    getMode () const;

    ModeType&
    getMode ();

    void
    setMode (const ModeType& x);

    void
    setMode (::std::unique_ptr< ModeType > p);

    // Constructors.
    //
    CurrentType (const ::xml_schema::Decimal&,
                 const UnitsType&,
                 const ModeType&);

    CurrentType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    CurrentType (const CurrentType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual CurrentType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CurrentType&
    operator= (const CurrentType& x);

    virtual 
    ~CurrentType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitsType > units_;
    ::xsd::cxx::tree::one< ModeType > mode_;
  };

  class DurationType: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // units
    //
    typedef ::dcml::TimeUnitToken UnitsType;
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    const UnitsType&
    getUnits () const;

    UnitsType&
    getUnits ();

    void
    setUnits (const UnitsType& x);

    void
    setUnits (::std::unique_ptr< UnitsType > p);

    // Constructors.
    //
    DurationType (const ::xml_schema::Decimal&,
                  const UnitsType&);

    DurationType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    DurationType (const DurationType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual DurationType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DurationType&
    operator= (const DurationType& x);

    virtual 
    ~DurationType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UnitsType > units_;
  };

  class RateType: public ::dcml::RationalType
  {
    public:
    // eventscope
    //
    typedef ::xml_schema::Uri EventscopeType;
    typedef ::xsd::cxx::tree::traits< EventscopeType, char > EventscopeTraits;

    const EventscopeType&
    getEventscope () const;

    EventscopeType&
    getEventscope ();

    void
    setEventscope (const EventscopeType& x);

    void
    setEventscope (::std::unique_ptr< EventscopeType > p);

    static const EventscopeType&
    getEventscopeDefaultValue ();

    // event
    //
    typedef ::xml_schema::Token EventType;
    typedef ::xsd::cxx::tree::optional< EventType > EventOptional;
    typedef ::xsd::cxx::tree::traits< EventType, char > EventTraits;

    const EventOptional&
    getEvent () const;

    EventOptional&
    getEvent ();

    void
    setEvent (const EventType& x);

    void
    setEvent (const EventOptional& x);

    void
    setEvent (::std::unique_ptr< EventType > p);

    // period
    //
    typedef ::dcml::TimeUnitToken PeriodType;
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    const PeriodType&
    getPeriod () const;

    PeriodType&
    getPeriod ();

    void
    setPeriod (const PeriodType& x);

    void
    setPeriod (::std::unique_ptr< PeriodType > p);

    // Constructors.
    //
    RateType (const PeriodType&);

    RateType (const ::dcml::RationalType_base&,
              const PeriodType&);

    RateType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    RateType (const RateType& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    virtual RateType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    RateType&
    operator= (const RateType& x);

    virtual 
    ~RateType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< EventscopeType > eventscope_;
    static const EventscopeType eventscope_default_value_;
    EventOptional event_;
    ::xsd::cxx::tree::one< PeriodType > period_;
  };

  class DeviceIdentifierUnion: public ::xml_schema::String
  {
    public:

    DeviceIdentifierUnion (const char* v);

    DeviceIdentifierUnion (const ::std::string& v);

    DeviceIdentifierUnion (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    DeviceIdentifierUnion (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    DeviceIdentifierUnion (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    DeviceIdentifierUnion (const DeviceIdentifierUnion& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    DeviceIdentifierUnion&
    operator= (const DeviceIdentifierUnion&) = default;
#endif

    virtual DeviceIdentifierUnion*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;
  };

  class DeviceIdentifierPolyType: public ::dcml::DeviceIdentifierUnion
  {
    public:
    // idtype
    //
    typedef ::dcml::DeviceIdentifierPolyType_idtypeType IdtypeType;
    typedef ::xsd::cxx::tree::traits< IdtypeType, char > IdtypeTraits;

    const IdtypeType&
    getIdtype () const;

    IdtypeType&
    getIdtype ();

    void
    setIdtype (const IdtypeType& x);

    void
    setIdtype (::std::unique_ptr< IdtypeType > p);

    // Constructors.
    //
    DeviceIdentifierPolyType (const char*,
                              const IdtypeType&);

    DeviceIdentifierPolyType (const ::std::string&,
                              const IdtypeType&);

    DeviceIdentifierPolyType (const ::dcml::DeviceIdentifierUnion&,
                              const IdtypeType&);

    DeviceIdentifierPolyType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    DeviceIdentifierPolyType (const DeviceIdentifierPolyType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual DeviceIdentifierPolyType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DeviceIdentifierPolyType&
    operator= (const DeviceIdentifierPolyType& x);

    virtual 
    ~DeviceIdentifierPolyType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdtypeType > idtype_;
  };

  class DeviceIdentifierListType: public ::xml_schema::Type
  {
    public:
    // PrimaryID
    //
    typedef ::dcml::DeviceIdentifierPolyType PrimaryIDType;
    typedef ::xsd::cxx::tree::traits< PrimaryIDType, char > PrimaryIDTraits;

    const PrimaryIDType&
    getPrimaryID () const;

    PrimaryIDType&
    getPrimaryID ();

    void
    setPrimaryID (const PrimaryIDType& x);

    void
    setPrimaryID (::std::unique_ptr< PrimaryIDType > p);

    // SecondaryID
    //
    typedef ::dcml::DeviceIdentifierPolyType SecondaryIDType;
    typedef ::xsd::cxx::tree::optional< SecondaryIDType > SecondaryIDOptional;
    typedef ::xsd::cxx::tree::traits< SecondaryIDType, char > SecondaryIDTraits;

    const SecondaryIDOptional&
    getSecondaryID () const;

    SecondaryIDOptional&
    getSecondaryID ();

    void
    setSecondaryID (const SecondaryIDType& x);

    void
    setSecondaryID (const SecondaryIDOptional& x);

    void
    setSecondaryID (::std::unique_ptr< SecondaryIDType > p);

    // Constructors.
    //
    DeviceIdentifierListType (const PrimaryIDType&);

    DeviceIdentifierListType (::std::unique_ptr< PrimaryIDType >);

    DeviceIdentifierListType (const ::xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    DeviceIdentifierListType (const DeviceIdentifierListType& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    virtual DeviceIdentifierListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DeviceIdentifierListType&
    operator= (const DeviceIdentifierListType& x);

    virtual 
    ~DeviceIdentifierListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PrimaryIDType > PrimaryID_;
    SecondaryIDOptional SecondaryID_;
  };

  class DeviceTypeType: public ::xml_schema::Token
  {
    public:
    // scope
    //
    typedef ::xml_schema::Uri ScopeType;
    typedef ::xsd::cxx::tree::traits< ScopeType, char > ScopeTraits;

    const ScopeType&
    getScope () const;

    ScopeType&
    getScope ();

    void
    setScope (const ScopeType& x);

    void
    setScope (::std::unique_ptr< ScopeType > p);

    static const ScopeType&
    getScopeDefaultValue ();

    // Constructors.
    //
    DeviceTypeType ();

    DeviceTypeType (const char*);

    DeviceTypeType (const ::std::string&);

    DeviceTypeType (const ::xml_schema::Token&);

    DeviceTypeType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    DeviceTypeType (const DeviceTypeType& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    virtual DeviceTypeType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DeviceTypeType&
    operator= (const DeviceTypeType& x);

    virtual 
    ~DeviceTypeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ScopeType > scope_;
    static const ScopeType scope_default_value_;
  };

  class ScopedTokenType: public ::xml_schema::Token
  {
    public:
    // scope
    //
    typedef ::xml_schema::Uri ScopeType;
    typedef ::xsd::cxx::tree::optional< ScopeType > ScopeOptional;
    typedef ::xsd::cxx::tree::traits< ScopeType, char > ScopeTraits;

    const ScopeOptional&
    getScope () const;

    ScopeOptional&
    getScope ();

    void
    setScope (const ScopeType& x);

    void
    setScope (const ScopeOptional& x);

    void
    setScope (::std::unique_ptr< ScopeType > p);

    // Constructors.
    //
    ScopedTokenType ();

    ScopedTokenType (const char*);

    ScopedTokenType (const ::std::string&);

    ScopedTokenType (const ::xml_schema::Token&);

    ScopedTokenType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ScopedTokenType (const ScopedTokenType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ScopedTokenType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ScopedTokenType&
    operator= (const ScopedTokenType& x);

    virtual 
    ~ScopedTokenType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ScopeOptional scope_;
  };

  class NamedParmType: public ::xml_schema::Type
  {
    public:
    // Name
    //
    typedef ::dcml::ScopedTokenType NameType;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameType&
    getName () const;

    NameType&
    getName ();

    void
    setName (const NameType& x);

    void
    setName (::std::unique_ptr< NameType > p);

    // Value
    //
    typedef ::xml_schema::Type ValueType;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueType&
    getValue () const;

    ValueType&
    getValue ();

    void
    setValue (const ValueType& x);

    void
    setValue (::std::unique_ptr< ValueType > p);

    // Constructors.
    //
    NamedParmType (const NameType&,
                   const ValueType&);

    NamedParmType (::std::unique_ptr< NameType >,
                   const ValueType&);

    NamedParmType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    NamedParmType (const NamedParmType& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    virtual NamedParmType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    NamedParmType&
    operator= (const NamedParmType& x);

    virtual 
    ~NamedParmType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > Name_;
    ::xsd::cxx::tree::one< ValueType > Value_;
  };

  class ParameterListType: public ::xml_schema::Type
  {
    public:
    // Parameter
    //
    typedef ::dcml::NamedParmType ParameterType;
    typedef ::xsd::cxx::tree::sequence< ParameterType > ParameterSequence;
    typedef ParameterSequence::iterator ParameterIterator;
    typedef ParameterSequence::const_iterator ParameterConstIterator;
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    const ParameterSequence&
    getParameter () const;

    ParameterSequence&
    getParameter ();

    void
    setParameter (const ParameterSequence& s);

    // Constructors.
    //
    ParameterListType ();

    ParameterListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    ParameterListType (const ParameterListType& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    virtual ParameterListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ParameterListType&
    operator= (const ParameterListType& x);

    virtual 
    ~ParameterListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ParameterSequence Parameter_;
  };

  class VersionInfoListType: public ::xml_schema::Type
  {
    public:
    // Name
    //
    typedef ::xml_schema::String NameType;
    typedef ::xsd::cxx::tree::sequence< NameType > NameSequence;
    typedef NameSequence::iterator NameIterator;
    typedef NameSequence::const_iterator NameConstIterator;
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    const NameSequence&
    getName () const;

    NameSequence&
    getName ();

    void
    setName (const NameSequence& s);

    // Value
    //
    typedef ::xml_schema::String ValueType;
    typedef ::xsd::cxx::tree::sequence< ValueType > ValueSequence;
    typedef ValueSequence::iterator ValueIterator;
    typedef ValueSequence::const_iterator ValueConstIterator;
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    const ValueSequence&
    getValue () const;

    ValueSequence&
    getValue ();

    void
    setValue (const ValueSequence& s);

    // Constructors.
    //
    VersionInfoListType ();

    VersionInfoListType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    VersionInfoListType (const VersionInfoListType& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    virtual VersionInfoListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    VersionInfoListType&
    operator= (const VersionInfoListType& x);

    virtual 
    ~VersionInfoListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameSequence Name_;
    ValueSequence Value_;
  };

  class DeviceDescriptionType: public ::xml_schema::Type
  {
    public:
    // DeviceIdentifier
    //
    typedef ::dcml::DeviceIdentifierPolyType DeviceIdentifierType;
    typedef ::xsd::cxx::tree::traits< DeviceIdentifierType, char > DeviceIdentifierTraits;

    const DeviceIdentifierType&
    getDeviceIdentifier () const;

    DeviceIdentifierType&
    getDeviceIdentifier ();

    void
    setDeviceIdentifier (const DeviceIdentifierType& x);

    void
    setDeviceIdentifier (::std::unique_ptr< DeviceIdentifierType > p);

    // DeviceTypeID
    //
    typedef ::dcml::DeviceTypeType DeviceTypeIDType;
    typedef ::xsd::cxx::tree::traits< DeviceTypeIDType, char > DeviceTypeIDTraits;

    const DeviceTypeIDType&
    getDeviceTypeID () const;

    DeviceTypeIDType&
    getDeviceTypeID ();

    void
    setDeviceTypeID (const DeviceTypeIDType& x);

    void
    setDeviceTypeID (::std::unique_ptr< DeviceTypeIDType > p);

    // DeviceSubsystemTypeID
    //
    typedef ::dcml::DeviceTypeType DeviceSubsystemTypeIDType;
    typedef ::xsd::cxx::tree::optional< DeviceSubsystemTypeIDType > DeviceSubsystemTypeIDOptional;
    typedef ::xsd::cxx::tree::traits< DeviceSubsystemTypeIDType, char > DeviceSubsystemTypeIDTraits;

    const DeviceSubsystemTypeIDOptional&
    getDeviceSubsystemTypeID () const;

    DeviceSubsystemTypeIDOptional&
    getDeviceSubsystemTypeID ();

    void
    setDeviceSubsystemTypeID (const DeviceSubsystemTypeIDType& x);

    void
    setDeviceSubsystemTypeID (const DeviceSubsystemTypeIDOptional& x);

    void
    setDeviceSubsystemTypeID (::std::unique_ptr< DeviceSubsystemTypeIDType > p);

    // AdditionalID
    //
    typedef ::xml_schema::Type AdditionalIDType;
    typedef ::xsd::cxx::tree::optional< AdditionalIDType > AdditionalIDOptional;
    typedef ::xsd::cxx::tree::traits< AdditionalIDType, char > AdditionalIDTraits;

    const AdditionalIDOptional&
    getAdditionalID () const;

    AdditionalIDOptional&
    getAdditionalID ();

    void
    setAdditionalID (const AdditionalIDType& x);

    void
    setAdditionalID (const AdditionalIDOptional& x);

    void
    setAdditionalID (::std::unique_ptr< AdditionalIDType > p);

    // DeviceSerial
    //
    typedef ::xml_schema::String DeviceSerialType;
    typedef ::xsd::cxx::tree::traits< DeviceSerialType, char > DeviceSerialTraits;

    const DeviceSerialType&
    getDeviceSerial () const;

    DeviceSerialType&
    getDeviceSerial ();

    void
    setDeviceSerial (const DeviceSerialType& x);

    void
    setDeviceSerial (::std::unique_ptr< DeviceSerialType > p);

    // ManufacturerID
    //
    typedef ::xml_schema::Uri ManufacturerIDType;
    typedef ::xsd::cxx::tree::optional< ManufacturerIDType > ManufacturerIDOptional;
    typedef ::xsd::cxx::tree::traits< ManufacturerIDType, char > ManufacturerIDTraits;

    const ManufacturerIDOptional&
    getManufacturerID () const;

    ManufacturerIDOptional&
    getManufacturerID ();

    void
    setManufacturerID (const ManufacturerIDType& x);

    void
    setManufacturerID (const ManufacturerIDOptional& x);

    void
    setManufacturerID (::std::unique_ptr< ManufacturerIDType > p);

    // ManufacturerCertID
    //
    typedef ::ds::DigestValueType ManufacturerCertIDType;
    typedef ::xsd::cxx::tree::optional< ManufacturerCertIDType > ManufacturerCertIDOptional;
    typedef ::xsd::cxx::tree::traits< ManufacturerCertIDType, char > ManufacturerCertIDTraits;

    const ManufacturerCertIDOptional&
    getManufacturerCertID () const;

    ManufacturerCertIDOptional&
    getManufacturerCertID ();

    void
    setManufacturerCertID (const ManufacturerCertIDType& x);

    void
    setManufacturerCertID (const ManufacturerCertIDOptional& x);

    void
    setManufacturerCertID (::std::unique_ptr< ManufacturerCertIDType > p);

    // DeviceCertID
    //
    typedef ::ds::DigestValueType DeviceCertIDType;
    typedef ::xsd::cxx::tree::optional< DeviceCertIDType > DeviceCertIDOptional;
    typedef ::xsd::cxx::tree::traits< DeviceCertIDType, char > DeviceCertIDTraits;

    const DeviceCertIDOptional&
    getDeviceCertID () const;

    DeviceCertIDOptional&
    getDeviceCertID ();

    void
    setDeviceCertID (const DeviceCertIDType& x);

    void
    setDeviceCertID (const DeviceCertIDOptional& x);

    void
    setDeviceCertID (::std::unique_ptr< DeviceCertIDType > p);

    // ManufacturerName
    //
    typedef ::xml_schema::String ManufacturerNameType;
    typedef ::xsd::cxx::tree::optional< ManufacturerNameType > ManufacturerNameOptional;
    typedef ::xsd::cxx::tree::traits< ManufacturerNameType, char > ManufacturerNameTraits;

    const ManufacturerNameOptional&
    getManufacturerName () const;

    ManufacturerNameOptional&
    getManufacturerName ();

    void
    setManufacturerName (const ManufacturerNameType& x);

    void
    setManufacturerName (const ManufacturerNameOptional& x);

    void
    setManufacturerName (::std::unique_ptr< ManufacturerNameType > p);

    // DeviceName
    //
    typedef ::xml_schema::String DeviceNameType;
    typedef ::xsd::cxx::tree::optional< DeviceNameType > DeviceNameOptional;
    typedef ::xsd::cxx::tree::traits< DeviceNameType, char > DeviceNameTraits;

    const DeviceNameOptional&
    getDeviceName () const;

    DeviceNameOptional&
    getDeviceName ();

    void
    setDeviceName (const DeviceNameType& x);

    void
    setDeviceName (const DeviceNameOptional& x);

    void
    setDeviceName (::std::unique_ptr< DeviceNameType > p);

    // ModelNumber
    //
    typedef ::xml_schema::String ModelNumberType;
    typedef ::xsd::cxx::tree::optional< ModelNumberType > ModelNumberOptional;
    typedef ::xsd::cxx::tree::traits< ModelNumberType, char > ModelNumberTraits;

    const ModelNumberOptional&
    getModelNumber () const;

    ModelNumberOptional&
    getModelNumber ();

    void
    setModelNumber (const ModelNumberType& x);

    void
    setModelNumber (const ModelNumberOptional& x);

    void
    setModelNumber (::std::unique_ptr< ModelNumberType > p);

    // VersionInfo
    //
    typedef ::dcml::VersionInfoListType VersionInfoType;
    typedef ::xsd::cxx::tree::traits< VersionInfoType, char > VersionInfoTraits;

    const VersionInfoType&
    getVersionInfo () const;

    VersionInfoType&
    getVersionInfo ();

    void
    setVersionInfo (const VersionInfoType& x);

    void
    setVersionInfo (::std::unique_ptr< VersionInfoType > p);

    // DeviceComment
    //
    typedef ::dcml::UserTextType DeviceCommentType;
    typedef ::xsd::cxx::tree::optional< DeviceCommentType > DeviceCommentOptional;
    typedef ::xsd::cxx::tree::traits< DeviceCommentType, char > DeviceCommentTraits;

    const DeviceCommentOptional&
    getDeviceComment () const;

    DeviceCommentOptional&
    getDeviceComment ();

    void
    setDeviceComment (const DeviceCommentType& x);

    void
    setDeviceComment (const DeviceCommentOptional& x);

    void
    setDeviceComment (::std::unique_ptr< DeviceCommentType > p);

    // Constructors.
    //
    DeviceDescriptionType (const DeviceIdentifierType&,
                           const DeviceTypeIDType&,
                           const DeviceSerialType&,
                           const VersionInfoType&);

    DeviceDescriptionType (::std::unique_ptr< DeviceIdentifierType >,
                           ::std::unique_ptr< DeviceTypeIDType >,
                           const DeviceSerialType&,
                           ::std::unique_ptr< VersionInfoType >);

    DeviceDescriptionType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    DeviceDescriptionType (const DeviceDescriptionType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual DeviceDescriptionType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DeviceDescriptionType&
    operator= (const DeviceDescriptionType& x);

    virtual 
    ~DeviceDescriptionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DeviceIdentifierType > DeviceIdentifier_;
    ::xsd::cxx::tree::one< DeviceTypeIDType > DeviceTypeID_;
    DeviceSubsystemTypeIDOptional DeviceSubsystemTypeID_;
    AdditionalIDOptional AdditionalID_;
    ::xsd::cxx::tree::one< DeviceSerialType > DeviceSerial_;
    ManufacturerIDOptional ManufacturerID_;
    ManufacturerCertIDOptional ManufacturerCertID_;
    DeviceCertIDOptional DeviceCertID_;
    ManufacturerNameOptional ManufacturerName_;
    DeviceNameOptional DeviceName_;
    ModelNumberOptional ModelNumber_;
    ::xsd::cxx::tree::one< VersionInfoType > VersionInfo_;
    DeviceCommentOptional DeviceComment_;
  };

  class DeviceIdentifierPolyType_idtypeType: public ::xml_schema::Token
  {
    public:
    enum Value
    {
      DeviceUID,
      CertThumbprint
    };

    DeviceIdentifierPolyType_idtypeType (Value v);

    DeviceIdentifierPolyType_idtypeType (const char* v);

    DeviceIdentifierPolyType_idtypeType (const ::std::string& v);

    DeviceIdentifierPolyType_idtypeType (const ::xml_schema::Token& v);

    DeviceIdentifierPolyType_idtypeType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    DeviceIdentifierPolyType_idtypeType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    DeviceIdentifierPolyType_idtypeType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

    DeviceIdentifierPolyType_idtypeType (const DeviceIdentifierPolyType_idtypeType& x,
                                         ::xml_schema::Flags f = 0,
                                         ::xml_schema::Container* c = 0);

#ifdef XSD_CXX11
    DeviceIdentifierPolyType_idtypeType&
    operator= (const DeviceIdentifierPolyType_idtypeType&) = default;
#endif

    virtual DeviceIdentifierPolyType_idtypeType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    DeviceIdentifierPolyType_idtypeType&
    operator= (Value v);

    virtual
    operator Value () const
    {
      return _xsd_DeviceIdentifierPolyType_idtypeType_convert ();
    }

    protected:
    Value
    _xsd_DeviceIdentifierPolyType_idtypeType_convert () const;

    public:
    static const char* const _xsd_DeviceIdentifierPolyType_idtypeType_literals_[2];
    static const Value _xsd_DeviceIdentifierPolyType_idtypeType_indexes_[2];
  };
}

#include <iosfwd>

namespace dcml
{
  ::std::ostream&
  operator<< (::std::ostream&, const UUIDType&);

  ::std::ostream&
  operator<< (::std::ostream&, const UserTextType&);

  ::std::ostream&
  operator<< (::std::ostream&, const RationalType_base&);

  ::std::ostream&
  operator<< (::std::ostream&, const RationalType&);

  ::std::ostream&
  operator<< (::std::ostream&, TemperatureUnitsToken::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const TemperatureUnitsToken&);

  ::std::ostream&
  operator<< (::std::ostream&, VoltageUnitsToken::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const VoltageUnitsToken&);

  ::std::ostream&
  operator<< (::std::ostream&, CurrentUnitsToken::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const CurrentUnitsToken&);

  ::std::ostream&
  operator<< (::std::ostream&, CurrentModeToken::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const CurrentModeToken&);

  ::std::ostream&
  operator<< (::std::ostream&, TimeUnitToken::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const TimeUnitToken&);

  ::std::ostream&
  operator<< (::std::ostream&, const TemperatureType&);

  ::std::ostream&
  operator<< (::std::ostream&, const VoltageType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CurrentType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DurationType&);

  ::std::ostream&
  operator<< (::std::ostream&, const RateType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceIdentifierUnion&);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceIdentifierPolyType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceIdentifierListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceTypeType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ScopedTokenType&);

  ::std::ostream&
  operator<< (::std::ostream&, const NamedParmType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ParameterListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const VersionInfoListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceDescriptionType&);

  ::std::ostream&
  operator<< (::std::ostream&, DeviceIdentifierPolyType_idtypeType::Value);

  ::std::ostream&
  operator<< (::std::ostream&, const DeviceIdentifierPolyType_idtypeType&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace dcml
{
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace dcml
{
  void
  operator<< (::xercesc::DOMElement&, const UUIDType&);

  void
  operator<< (::xercesc::DOMAttr&, const UUIDType&);

  void
  operator<< (::xml_schema::ListStream&,
              const UUIDType&);

  void
  operator<< (::xercesc::DOMElement&, const UserTextType&);

  void
  operator<< (::xercesc::DOMElement&, const RationalType_base&);

  void
  operator<< (::xercesc::DOMAttr&, const RationalType_base&);

  void
  operator<< (::xml_schema::ListStream&,
              const RationalType_base&);

  void
  operator<< (::xercesc::DOMElement&, const RationalType&);

  void
  operator<< (::xercesc::DOMAttr&, const RationalType&);

  void
  operator<< (::xml_schema::ListStream&,
              const RationalType&);

  void
  operator<< (::xercesc::DOMElement&, const TemperatureUnitsToken&);

  void
  operator<< (::xercesc::DOMAttr&, const TemperatureUnitsToken&);

  void
  operator<< (::xml_schema::ListStream&,
              const TemperatureUnitsToken&);

  void
  operator<< (::xercesc::DOMElement&, const VoltageUnitsToken&);

  void
  operator<< (::xercesc::DOMAttr&, const VoltageUnitsToken&);

  void
  operator<< (::xml_schema::ListStream&,
              const VoltageUnitsToken&);

  void
  operator<< (::xercesc::DOMElement&, const CurrentUnitsToken&);

  void
  operator<< (::xercesc::DOMAttr&, const CurrentUnitsToken&);

  void
  operator<< (::xml_schema::ListStream&,
              const CurrentUnitsToken&);

  void
  operator<< (::xercesc::DOMElement&, const CurrentModeToken&);

  void
  operator<< (::xercesc::DOMAttr&, const CurrentModeToken&);

  void
  operator<< (::xml_schema::ListStream&,
              const CurrentModeToken&);

  void
  operator<< (::xercesc::DOMElement&, const TimeUnitToken&);

  void
  operator<< (::xercesc::DOMAttr&, const TimeUnitToken&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimeUnitToken&);

  void
  operator<< (::xercesc::DOMElement&, const TemperatureType&);

  void
  operator<< (::xercesc::DOMElement&, const VoltageType&);

  void
  operator<< (::xercesc::DOMElement&, const CurrentType&);

  void
  operator<< (::xercesc::DOMElement&, const DurationType&);

  void
  operator<< (::xercesc::DOMElement&, const RateType&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceIdentifierUnion&);

  void
  operator<< (::xercesc::DOMAttr&, const DeviceIdentifierUnion&);

  void
  operator<< (::xml_schema::ListStream&,
              const DeviceIdentifierUnion&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceIdentifierPolyType&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceIdentifierListType&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceTypeType&);

  void
  operator<< (::xercesc::DOMElement&, const ScopedTokenType&);

  void
  operator<< (::xercesc::DOMElement&, const NamedParmType&);

  void
  operator<< (::xercesc::DOMElement&, const ParameterListType&);

  void
  operator<< (::xercesc::DOMElement&, const VersionInfoListType&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceDescriptionType&);

  void
  operator<< (::xercesc::DOMElement&, const DeviceIdentifierPolyType_idtypeType&);

  void
  operator<< (::xercesc::DOMAttr&, const DeviceIdentifierPolyType_idtypeType&);

  void
  operator<< (::xml_schema::ListStream&,
              const DeviceIdentifierPolyType_idtypeType&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // ST0433_DCML_TYPES_H
