// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef SMPTE_2067_3_2013_CPL_H
#define SMPTE_2067_3_2013_CPL_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

#include <xsd/cxx/tree/std-ostream-operators.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type Type;
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;
  typedef ::xsd::cxx::tree::type Container;

  // 8-bit
  //
  typedef signed char Byte;
  typedef unsigned char UnsignedByte;

  // 16-bit
  //
  typedef short Short;
  typedef unsigned short UnsignedShort;

  // 32-bit
  //
  typedef int Int;
  typedef unsigned int UnsignedInt;

  // 64-bit
  //
  typedef long long Long;
  typedef unsigned long long UnsignedLong;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long Integer;
  typedef long long NonPositiveInteger;
  typedef unsigned long long NonNegativeInteger;
  typedef unsigned long long PositiveInteger;
  typedef long long NegativeInteger;

  // Boolean.
  //
  typedef bool Boolean;

  // Floating-point types.
  //
  typedef float Float;
  typedef double Double;
  typedef double Decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;
  typedef ::xsd::cxx::tree::name< char, Token > Name;
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;
  typedef ::xsd::cxx::tree::language< char, Token > Language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > Buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone TimeZone;
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;

  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > NamespaceInfo;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > NamespaceInfomap;
  typedef ::xsd::cxx::tree::list_stream< char > ListStream;
  typedef ::xsd::cxx::tree::as_double< Double > AsDouble;
  typedef ::xsd::cxx::tree::as_decimal< Decimal > AsDecimal;
  typedef ::xsd::cxx::tree::facet Facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags Flags;
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity Severity;
  typedef ::xsd::cxx::tree::error< char > Error;
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > Exception;
  typedef ::xsd::cxx::tree::bounds< char > Bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;
  typedef ::xsd::cxx::tree::parsing< char > Parsing;
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;
  typedef ::xsd::cxx::tree::no_type_info< char > NoTypeInfo;
  typedef ::xsd::cxx::tree::not_derived< char > NotDerived;
  typedef ::xsd::cxx::tree::serialization< char > Serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace cpl
{
  class CompositionPlaylistType;
  class CompositionTimecodeType;
  class TimecodeType;
  class ContentKindType;
  class LocaleType;
  class ContentMaturityRatingType;
  class EssenceDescriptorBaseType;
  class ContentVersionType;
  class SegmentType;
  class SequenceType;
  class BaseResourceType;
  class TrackFileResourceType;
  class MarkerResourceType;
  class MarkerType;
  class CompositionPlaylistType_ContentVersionListType;
  class CompositionPlaylistType_EssenceDescriptorListType;
  class CompositionPlaylistType_TotalRunningTimeType;
  class CompositionPlaylistType_LocaleListType;
  class CompositionPlaylistType_ExtensionPropertiesType;
  class CompositionPlaylistType_SegmentListType;
  class LocaleType_LanguageListType;
  class LocaleType_RegionListType;
  class LocaleType_ContentMaturityRatingListType;
  class ContentMaturityRatingType_AudienceType;
  class SegmentType_SequenceListType;
  class SequenceType_ResourceListType;
  class MarkerType_LabelType;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "st0433-dcmlTypes.h"

#include "xmldsig-core-schema.h"

namespace cpl
{
  class CompositionPlaylistType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::dcml::UUIDType IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Annotation
    //
    typedef ::dcml::UserTextType AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // IssueDate
    //
    typedef ::xml_schema::DateTime IssueDateType;
    typedef ::xsd::cxx::tree::traits< IssueDateType, char > IssueDateTraits;

    const IssueDateType&
    getIssueDate () const;

    IssueDateType&
    getIssueDate ();

    void
    setIssueDate (const IssueDateType& x);

    void
    setIssueDate (::std::unique_ptr< IssueDateType > p);

    // Issuer
    //
    typedef ::dcml::UserTextType IssuerType;
    typedef ::xsd::cxx::tree::optional< IssuerType > IssuerOptional;
    typedef ::xsd::cxx::tree::traits< IssuerType, char > IssuerTraits;

    const IssuerOptional&
    getIssuer () const;

    IssuerOptional&
    getIssuer ();

    void
    setIssuer (const IssuerType& x);

    void
    setIssuer (const IssuerOptional& x);

    void
    setIssuer (::std::unique_ptr< IssuerType > p);

    // Creator
    //
    typedef ::dcml::UserTextType CreatorType;
    typedef ::xsd::cxx::tree::optional< CreatorType > CreatorOptional;
    typedef ::xsd::cxx::tree::traits< CreatorType, char > CreatorTraits;

    const CreatorOptional&
    getCreator () const;

    CreatorOptional&
    getCreator ();

    void
    setCreator (const CreatorType& x);

    void
    setCreator (const CreatorOptional& x);

    void
    setCreator (::std::unique_ptr< CreatorType > p);

    // ContentOriginator
    //
    typedef ::dcml::UserTextType ContentOriginatorType;
    typedef ::xsd::cxx::tree::optional< ContentOriginatorType > ContentOriginatorOptional;
    typedef ::xsd::cxx::tree::traits< ContentOriginatorType, char > ContentOriginatorTraits;

    const ContentOriginatorOptional&
    getContentOriginator () const;

    ContentOriginatorOptional&
    getContentOriginator ();

    void
    setContentOriginator (const ContentOriginatorType& x);

    void
    setContentOriginator (const ContentOriginatorOptional& x);

    void
    setContentOriginator (::std::unique_ptr< ContentOriginatorType > p);

    // ContentTitle
    //
    typedef ::dcml::UserTextType ContentTitleType;
    typedef ::xsd::cxx::tree::traits< ContentTitleType, char > ContentTitleTraits;

    const ContentTitleType&
    getContentTitle () const;

    ContentTitleType&
    getContentTitle ();

    void
    setContentTitle (const ContentTitleType& x);

    void
    setContentTitle (::std::unique_ptr< ContentTitleType > p);

    // ContentKind
    //
    typedef ::cpl::ContentKindType ContentKindType;
    typedef ::xsd::cxx::tree::optional< ContentKindType > ContentKindOptional;
    typedef ::xsd::cxx::tree::traits< ContentKindType, char > ContentKindTraits;

    const ContentKindOptional&
    getContentKind () const;

    ContentKindOptional&
    getContentKind ();

    void
    setContentKind (const ContentKindType& x);

    void
    setContentKind (const ContentKindOptional& x);

    void
    setContentKind (::std::unique_ptr< ContentKindType > p);

    // ContentVersionList
    //
    typedef ::cpl::CompositionPlaylistType_ContentVersionListType ContentVersionListType;
    typedef ::xsd::cxx::tree::optional< ContentVersionListType > ContentVersionListOptional;
    typedef ::xsd::cxx::tree::traits< ContentVersionListType, char > ContentVersionListTraits;

    const ContentVersionListOptional&
    getContentVersionList () const;

    ContentVersionListOptional&
    getContentVersionList ();

    void
    setContentVersionList (const ContentVersionListType& x);

    void
    setContentVersionList (const ContentVersionListOptional& x);

    void
    setContentVersionList (::std::unique_ptr< ContentVersionListType > p);

    // EssenceDescriptorList
    //
    typedef ::cpl::CompositionPlaylistType_EssenceDescriptorListType EssenceDescriptorListType;
    typedef ::xsd::cxx::tree::optional< EssenceDescriptorListType > EssenceDescriptorListOptional;
    typedef ::xsd::cxx::tree::traits< EssenceDescriptorListType, char > EssenceDescriptorListTraits;

    const EssenceDescriptorListOptional&
    getEssenceDescriptorList () const;

    EssenceDescriptorListOptional&
    getEssenceDescriptorList ();

    void
    setEssenceDescriptorList (const EssenceDescriptorListType& x);

    void
    setEssenceDescriptorList (const EssenceDescriptorListOptional& x);

    void
    setEssenceDescriptorList (::std::unique_ptr< EssenceDescriptorListType > p);

    // CompositionTimecode
    //
    typedef ::cpl::CompositionTimecodeType CompositionTimecodeType;
    typedef ::xsd::cxx::tree::optional< CompositionTimecodeType > CompositionTimecodeOptional;
    typedef ::xsd::cxx::tree::traits< CompositionTimecodeType, char > CompositionTimecodeTraits;

    const CompositionTimecodeOptional&
    getCompositionTimecode () const;

    CompositionTimecodeOptional&
    getCompositionTimecode ();

    void
    setCompositionTimecode (const CompositionTimecodeType& x);

    void
    setCompositionTimecode (const CompositionTimecodeOptional& x);

    void
    setCompositionTimecode (::std::unique_ptr< CompositionTimecodeType > p);

    // EditRate
    //
    typedef ::dcml::RationalType EditRateType;
    typedef ::xsd::cxx::tree::traits< EditRateType, char > EditRateTraits;

    const EditRateType&
    getEditRate () const;

    EditRateType&
    getEditRate ();

    void
    setEditRate (const EditRateType& x);

    void
    setEditRate (::std::unique_ptr< EditRateType > p);

    // TotalRunningTime
    //
    typedef ::cpl::CompositionPlaylistType_TotalRunningTimeType TotalRunningTimeType;
    typedef ::xsd::cxx::tree::optional< TotalRunningTimeType > TotalRunningTimeOptional;
    typedef ::xsd::cxx::tree::traits< TotalRunningTimeType, char > TotalRunningTimeTraits;

    const TotalRunningTimeOptional&
    getTotalRunningTime () const;

    TotalRunningTimeOptional&
    getTotalRunningTime ();

    void
    setTotalRunningTime (const TotalRunningTimeType& x);

    void
    setTotalRunningTime (const TotalRunningTimeOptional& x);

    void
    setTotalRunningTime (::std::unique_ptr< TotalRunningTimeType > p);

    // LocaleList
    //
    typedef ::cpl::CompositionPlaylistType_LocaleListType LocaleListType;
    typedef ::xsd::cxx::tree::optional< LocaleListType > LocaleListOptional;
    typedef ::xsd::cxx::tree::traits< LocaleListType, char > LocaleListTraits;

    const LocaleListOptional&
    getLocaleList () const;

    LocaleListOptional&
    getLocaleList ();

    void
    setLocaleList (const LocaleListType& x);

    void
    setLocaleList (const LocaleListOptional& x);

    void
    setLocaleList (::std::unique_ptr< LocaleListType > p);

    // ExtensionProperties
    //
    typedef ::cpl::CompositionPlaylistType_ExtensionPropertiesType ExtensionPropertiesType;
    typedef ::xsd::cxx::tree::optional< ExtensionPropertiesType > ExtensionPropertiesOptional;
    typedef ::xsd::cxx::tree::traits< ExtensionPropertiesType, char > ExtensionPropertiesTraits;

    const ExtensionPropertiesOptional&
    getExtensionProperties () const;

    ExtensionPropertiesOptional&
    getExtensionProperties ();

    void
    setExtensionProperties (const ExtensionPropertiesType& x);

    void
    setExtensionProperties (const ExtensionPropertiesOptional& x);

    void
    setExtensionProperties (::std::unique_ptr< ExtensionPropertiesType > p);

    // SegmentList
    //
    typedef ::cpl::CompositionPlaylistType_SegmentListType SegmentListType;
    typedef ::xsd::cxx::tree::traits< SegmentListType, char > SegmentListTraits;

    const SegmentListType&
    getSegmentList () const;

    SegmentListType&
    getSegmentList ();

    void
    setSegmentList (const SegmentListType& x);

    void
    setSegmentList (::std::unique_ptr< SegmentListType > p);

    // Signer
    //
    typedef ::ds::KeyInfoType SignerType;
    typedef ::xsd::cxx::tree::optional< SignerType > SignerOptional;
    typedef ::xsd::cxx::tree::traits< SignerType, char > SignerTraits;

    const SignerOptional&
    getSigner () const;

    SignerOptional&
    getSigner ();

    void
    setSigner (const SignerType& x);

    void
    setSigner (const SignerOptional& x);

    void
    setSigner (::std::unique_ptr< SignerType > p);

    // Signature
    //
    typedef ::ds::SignatureType SignatureType;
    typedef ::xsd::cxx::tree::optional< SignatureType > SignatureOptional;
    typedef ::xsd::cxx::tree::traits< SignatureType, char > SignatureTraits;

    const SignatureOptional&
    getSignature () const;

    SignatureOptional&
    getSignature ();

    void
    setSignature (const SignatureType& x);

    void
    setSignature (const SignatureOptional& x);

    void
    setSignature (::std::unique_ptr< SignatureType > p);

    // Constructors.
    //
    CompositionPlaylistType (const IdType&,
                             const IssueDateType&,
                             const ContentTitleType&,
                             const EditRateType&,
                             const SegmentListType&);

    CompositionPlaylistType (const IdType&,
                             const IssueDateType&,
                             ::std::unique_ptr< ContentTitleType >,
                             const EditRateType&,
                             ::std::unique_ptr< SegmentListType >);

    CompositionPlaylistType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    CompositionPlaylistType (const CompositionPlaylistType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType&
    operator= (const CompositionPlaylistType& x);

    virtual 
    ~CompositionPlaylistType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > Id_;
    AnnotationOptional Annotation_;
    ::xsd::cxx::tree::one< IssueDateType > IssueDate_;
    IssuerOptional Issuer_;
    CreatorOptional Creator_;
    ContentOriginatorOptional ContentOriginator_;
    ::xsd::cxx::tree::one< ContentTitleType > ContentTitle_;
    ContentKindOptional ContentKind_;
    ContentVersionListOptional ContentVersionList_;
    EssenceDescriptorListOptional EssenceDescriptorList_;
    CompositionTimecodeOptional CompositionTimecode_;
    ::xsd::cxx::tree::one< EditRateType > EditRate_;
    TotalRunningTimeOptional TotalRunningTime_;
    LocaleListOptional LocaleList_;
    ExtensionPropertiesOptional ExtensionProperties_;
    ::xsd::cxx::tree::one< SegmentListType > SegmentList_;
    SignerOptional Signer_;
    SignatureOptional Signature_;
  };

  class CompositionTimecodeType: public ::xml_schema::Type
  {
    public:
    // TimecodeDropFrame
    //
    typedef ::xml_schema::Boolean TimecodeDropFrameType;
    typedef ::xsd::cxx::tree::traits< TimecodeDropFrameType, char > TimecodeDropFrameTraits;

    const TimecodeDropFrameType&
    getTimecodeDropFrame () const;

    TimecodeDropFrameType&
    getTimecodeDropFrame ();

    void
    setTimecodeDropFrame (const TimecodeDropFrameType& x);

    // TimecodeRate
    //
    typedef ::xml_schema::PositiveInteger TimecodeRateType;
    typedef ::xsd::cxx::tree::traits< TimecodeRateType, char > TimecodeRateTraits;

    const TimecodeRateType&
    getTimecodeRate () const;

    TimecodeRateType&
    getTimecodeRate ();

    void
    setTimecodeRate (const TimecodeRateType& x);

    // TimecodeStartAddress
    //
    typedef ::cpl::TimecodeType TimecodeStartAddressType;
    typedef ::xsd::cxx::tree::traits< TimecodeStartAddressType, char > TimecodeStartAddressTraits;

    const TimecodeStartAddressType&
    getTimecodeStartAddress () const;

    TimecodeStartAddressType&
    getTimecodeStartAddress ();

    void
    setTimecodeStartAddress (const TimecodeStartAddressType& x);

    void
    setTimecodeStartAddress (::std::unique_ptr< TimecodeStartAddressType > p);

    // Constructors.
    //
    CompositionTimecodeType (const TimecodeDropFrameType&,
                             const TimecodeRateType&,
                             const TimecodeStartAddressType&);

    CompositionTimecodeType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    CompositionTimecodeType (const CompositionTimecodeType& x,
                             ::xml_schema::Flags f = 0,
                             ::xml_schema::Container* c = 0);

    virtual CompositionTimecodeType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionTimecodeType&
    operator= (const CompositionTimecodeType& x);

    virtual 
    ~CompositionTimecodeType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimecodeDropFrameType > TimecodeDropFrame_;
    ::xsd::cxx::tree::one< TimecodeRateType > TimecodeRate_;
    ::xsd::cxx::tree::one< TimecodeStartAddressType > TimecodeStartAddress_;
  };

  class TimecodeType: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    TimecodeType ();

    TimecodeType (const char*);

    TimecodeType (const ::std::string&);

    TimecodeType (const ::xml_schema::String&);

    TimecodeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    TimecodeType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    TimecodeType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    TimecodeType (const TimecodeType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual TimecodeType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~TimecodeType ();
  };

  class ContentKindType: public ::xml_schema::String
  {
    public:
    // scope
    //
    typedef ::xml_schema::Uri ScopeType;
    typedef ::xsd::cxx::tree::traits< ScopeType, char > ScopeTraits;

    const ScopeType&
    getScope () const;

    ScopeType&
    getScope ();

    void
    setScope (const ScopeType& x);

    void
    setScope (::std::unique_ptr< ScopeType > p);

    static const ScopeType&
    getScopeDefaultValue ();

    // Constructors.
    //
    ContentKindType ();

    ContentKindType (const char*);

    ContentKindType (const ::std::string&);

    ContentKindType (const ::xml_schema::String&);

    ContentKindType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    ContentKindType (const ContentKindType& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    virtual ContentKindType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContentKindType&
    operator= (const ContentKindType& x);

    virtual 
    ~ContentKindType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ScopeType > scope_;
    static const ScopeType scope_default_value_;
  };

  class LocaleType: public ::xml_schema::Type
  {
    public:
    // Annotation
    //
    typedef ::dcml::UserTextType AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // LanguageList
    //
    typedef ::cpl::LocaleType_LanguageListType LanguageListType;
    typedef ::xsd::cxx::tree::optional< LanguageListType > LanguageListOptional;
    typedef ::xsd::cxx::tree::traits< LanguageListType, char > LanguageListTraits;

    const LanguageListOptional&
    getLanguageList () const;

    LanguageListOptional&
    getLanguageList ();

    void
    setLanguageList (const LanguageListType& x);

    void
    setLanguageList (const LanguageListOptional& x);

    void
    setLanguageList (::std::unique_ptr< LanguageListType > p);

    // RegionList
    //
    typedef ::cpl::LocaleType_RegionListType RegionListType;
    typedef ::xsd::cxx::tree::optional< RegionListType > RegionListOptional;
    typedef ::xsd::cxx::tree::traits< RegionListType, char > RegionListTraits;

    const RegionListOptional&
    getRegionList () const;

    RegionListOptional&
    getRegionList ();

    void
    setRegionList (const RegionListType& x);

    void
    setRegionList (const RegionListOptional& x);

    void
    setRegionList (::std::unique_ptr< RegionListType > p);

    // ContentMaturityRatingList
    //
    typedef ::cpl::LocaleType_ContentMaturityRatingListType ContentMaturityRatingListType;
    typedef ::xsd::cxx::tree::optional< ContentMaturityRatingListType > ContentMaturityRatingListOptional;
    typedef ::xsd::cxx::tree::traits< ContentMaturityRatingListType, char > ContentMaturityRatingListTraits;

    const ContentMaturityRatingListOptional&
    getContentMaturityRatingList () const;

    ContentMaturityRatingListOptional&
    getContentMaturityRatingList ();

    void
    setContentMaturityRatingList (const ContentMaturityRatingListType& x);

    void
    setContentMaturityRatingList (const ContentMaturityRatingListOptional& x);

    void
    setContentMaturityRatingList (::std::unique_ptr< ContentMaturityRatingListType > p);

    // Constructors.
    //
    LocaleType ();

    LocaleType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    LocaleType (const LocaleType& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual LocaleType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocaleType&
    operator= (const LocaleType& x);

    virtual 
    ~LocaleType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnnotationOptional Annotation_;
    LanguageListOptional LanguageList_;
    RegionListOptional RegionList_;
    ContentMaturityRatingListOptional ContentMaturityRatingList_;
  };

  class ContentMaturityRatingType: public ::xml_schema::Type
  {
    public:
    // Agency
    //
    typedef ::xml_schema::Uri AgencyType;
    typedef ::xsd::cxx::tree::traits< AgencyType, char > AgencyTraits;

    const AgencyType&
    getAgency () const;

    AgencyType&
    getAgency ();

    void
    setAgency (const AgencyType& x);

    void
    setAgency (::std::unique_ptr< AgencyType > p);

    // Rating
    //
    typedef ::xml_schema::String RatingType;
    typedef ::xsd::cxx::tree::traits< RatingType, char > RatingTraits;

    const RatingType&
    getRating () const;

    RatingType&
    getRating ();

    void
    setRating (const RatingType& x);

    void
    setRating (::std::unique_ptr< RatingType > p);

    // Audience
    //
    typedef ::cpl::ContentMaturityRatingType_AudienceType AudienceType;
    typedef ::xsd::cxx::tree::optional< AudienceType > AudienceOptional;
    typedef ::xsd::cxx::tree::traits< AudienceType, char > AudienceTraits;

    const AudienceOptional&
    getAudience () const;

    AudienceOptional&
    getAudience ();

    void
    setAudience (const AudienceType& x);

    void
    setAudience (const AudienceOptional& x);

    void
    setAudience (::std::unique_ptr< AudienceType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    ContentMaturityRatingType (const AgencyType&,
                               const RatingType&);

    ContentMaturityRatingType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    ContentMaturityRatingType (const ContentMaturityRatingType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual ContentMaturityRatingType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContentMaturityRatingType&
    operator= (const ContentMaturityRatingType& x);

    virtual 
    ~ContentMaturityRatingType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    ::xsd::cxx::tree::one< AgencyType > Agency_;
    ::xsd::cxx::tree::one< RatingType > Rating_;
    AudienceOptional Audience_;
    AnySequence any_;
  };

  class EssenceDescriptorBaseType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::dcml::UUIDType IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    EssenceDescriptorBaseType (const IdType&);

    EssenceDescriptorBaseType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    EssenceDescriptorBaseType (const EssenceDescriptorBaseType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual EssenceDescriptorBaseType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    EssenceDescriptorBaseType&
    operator= (const EssenceDescriptorBaseType& x);

    virtual 
    ~EssenceDescriptorBaseType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    ::xsd::cxx::tree::one< IdType > Id_;
    AnySequence any_;
  };

  class ContentVersionType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::xml_schema::Uri IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // LabelText
    //
    typedef ::dcml::UserTextType LabelTextType;
    typedef ::xsd::cxx::tree::traits< LabelTextType, char > LabelTextTraits;

    const LabelTextType&
    getLabelText () const;

    LabelTextType&
    getLabelText ();

    void
    setLabelText (const LabelTextType& x);

    void
    setLabelText (::std::unique_ptr< LabelTextType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    ContentVersionType (const IdType&,
                        const LabelTextType&);

    ContentVersionType (const IdType&,
                        ::std::unique_ptr< LabelTextType >);

    ContentVersionType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    ContentVersionType (const ContentVersionType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual ContentVersionType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContentVersionType&
    operator= (const ContentVersionType& x);

    virtual 
    ~ContentVersionType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    ::xsd::cxx::tree::one< IdType > Id_;
    ::xsd::cxx::tree::one< LabelTextType > LabelText_;
    AnySequence any_;
  };

  class SegmentType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::dcml::UUIDType IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Annotation
    //
    typedef ::dcml::UserTextType AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // SequenceList
    //
    typedef ::cpl::SegmentType_SequenceListType SequenceListType;
    typedef ::xsd::cxx::tree::traits< SequenceListType, char > SequenceListTraits;

    const SequenceListType&
    getSequenceList () const;

    SequenceListType&
    getSequenceList ();

    void
    setSequenceList (const SequenceListType& x);

    void
    setSequenceList (::std::unique_ptr< SequenceListType > p);

    // Constructors.
    //
    SegmentType (const IdType&,
                 const SequenceListType&);

    SegmentType (const IdType&,
                 ::std::unique_ptr< SequenceListType >);

    SegmentType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    SegmentType (const SegmentType& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    virtual SegmentType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SegmentType&
    operator= (const SegmentType& x);

    virtual 
    ~SegmentType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > Id_;
    AnnotationOptional Annotation_;
    ::xsd::cxx::tree::one< SequenceListType > SequenceList_;
  };

  class SequenceType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::dcml::UUIDType IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // TrackId
    //
    typedef ::dcml::UUIDType TrackIdType;
    typedef ::xsd::cxx::tree::traits< TrackIdType, char > TrackIdTraits;

    const TrackIdType&
    getTrackId () const;

    TrackIdType&
    getTrackId ();

    void
    setTrackId (const TrackIdType& x);

    void
    setTrackId (::std::unique_ptr< TrackIdType > p);

    // ResourceList
    //
    typedef ::cpl::SequenceType_ResourceListType ResourceListType;
    typedef ::xsd::cxx::tree::traits< ResourceListType, char > ResourceListTraits;

    const ResourceListType&
    getResourceList () const;

    ResourceListType&
    getResourceList ();

    void
    setResourceList (const ResourceListType& x);

    void
    setResourceList (::std::unique_ptr< ResourceListType > p);

    // Constructors.
    //
    SequenceType (const IdType&,
                  const TrackIdType&,
                  const ResourceListType&);

    SequenceType (const IdType&,
                  const TrackIdType&,
                  ::std::unique_ptr< ResourceListType >);

    SequenceType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    SequenceType (const SequenceType& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    virtual SequenceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SequenceType&
    operator= (const SequenceType& x);

    virtual 
    ~SequenceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > Id_;
    ::xsd::cxx::tree::one< TrackIdType > TrackId_;
    ::xsd::cxx::tree::one< ResourceListType > ResourceList_;
  };

  class BaseResourceType: public ::xml_schema::Type
  {
    public:
    // Id
    //
    typedef ::dcml::UUIDType IdType;
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    const IdType&
    getId () const;

    IdType&
    getId ();

    void
    setId (const IdType& x);

    void
    setId (::std::unique_ptr< IdType > p);

    // Annotation
    //
    typedef ::dcml::UserTextType AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // EditRate
    //
    typedef ::dcml::RationalType EditRateType;
    typedef ::xsd::cxx::tree::optional< EditRateType > EditRateOptional;
    typedef ::xsd::cxx::tree::traits< EditRateType, char > EditRateTraits;

    const EditRateOptional&
    getEditRate () const;

    EditRateOptional&
    getEditRate ();

    void
    setEditRate (const EditRateType& x);

    void
    setEditRate (const EditRateOptional& x);

    void
    setEditRate (::std::unique_ptr< EditRateType > p);

    // IntrinsicDuration
    //
    typedef ::xml_schema::NonNegativeInteger IntrinsicDurationType;
    typedef ::xsd::cxx::tree::traits< IntrinsicDurationType, char > IntrinsicDurationTraits;

    const IntrinsicDurationType&
    getIntrinsicDuration () const;

    IntrinsicDurationType&
    getIntrinsicDuration ();

    void
    setIntrinsicDuration (const IntrinsicDurationType& x);

    // EntryPoint
    //
    typedef ::xml_schema::NonNegativeInteger EntryPointType;
    typedef ::xsd::cxx::tree::optional< EntryPointType > EntryPointOptional;
    typedef ::xsd::cxx::tree::traits< EntryPointType, char > EntryPointTraits;

    const EntryPointOptional&
    getEntryPoint () const;

    EntryPointOptional&
    getEntryPoint ();

    void
    setEntryPoint (const EntryPointType& x);

    void
    setEntryPoint (const EntryPointOptional& x);

    // SourceDuration
    //
    typedef ::xml_schema::NonNegativeInteger SourceDurationType;
    typedef ::xsd::cxx::tree::optional< SourceDurationType > SourceDurationOptional;
    typedef ::xsd::cxx::tree::traits< SourceDurationType, char > SourceDurationTraits;

    const SourceDurationOptional&
    getSourceDuration () const;

    SourceDurationOptional&
    getSourceDuration ();

    void
    setSourceDuration (const SourceDurationType& x);

    void
    setSourceDuration (const SourceDurationOptional& x);

    // RepeatCount
    //
    typedef ::xml_schema::PositiveInteger RepeatCountType;
    typedef ::xsd::cxx::tree::optional< RepeatCountType > RepeatCountOptional;
    typedef ::xsd::cxx::tree::traits< RepeatCountType, char > RepeatCountTraits;

    const RepeatCountOptional&
    getRepeatCount () const;

    RepeatCountOptional&
    getRepeatCount ();

    void
    setRepeatCount (const RepeatCountType& x);

    void
    setRepeatCount (const RepeatCountOptional& x);

    // Constructors.
    //
    BaseResourceType (const IdType&,
                      const IntrinsicDurationType&);

    BaseResourceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    BaseResourceType (const BaseResourceType& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    virtual BaseResourceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    BaseResourceType&
    operator= (const BaseResourceType& x);

    virtual 
    ~BaseResourceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > Id_;
    AnnotationOptional Annotation_;
    EditRateOptional EditRate_;
    ::xsd::cxx::tree::one< IntrinsicDurationType > IntrinsicDuration_;
    EntryPointOptional EntryPoint_;
    SourceDurationOptional SourceDuration_;
    RepeatCountOptional RepeatCount_;
  };

  class TrackFileResourceType: public ::cpl::BaseResourceType
  {
    public:
    // SourceEncoding
    //
    typedef ::dcml::UUIDType SourceEncodingType;
    typedef ::xsd::cxx::tree::traits< SourceEncodingType, char > SourceEncodingTraits;

    const SourceEncodingType&
    getSourceEncoding () const;

    SourceEncodingType&
    getSourceEncoding ();

    void
    setSourceEncoding (const SourceEncodingType& x);

    void
    setSourceEncoding (::std::unique_ptr< SourceEncodingType > p);

    // TrackFileId
    //
    typedef ::dcml::UUIDType TrackFileIdType;
    typedef ::xsd::cxx::tree::traits< TrackFileIdType, char > TrackFileIdTraits;

    const TrackFileIdType&
    getTrackFileId () const;

    TrackFileIdType&
    getTrackFileId ();

    void
    setTrackFileId (const TrackFileIdType& x);

    void
    setTrackFileId (::std::unique_ptr< TrackFileIdType > p);

    // KeyId
    //
    typedef ::dcml::UUIDType KeyIdType;
    typedef ::xsd::cxx::tree::optional< KeyIdType > KeyIdOptional;
    typedef ::xsd::cxx::tree::traits< KeyIdType, char > KeyIdTraits;

    const KeyIdOptional&
    getKeyId () const;

    KeyIdOptional&
    getKeyId ();

    void
    setKeyId (const KeyIdType& x);

    void
    setKeyId (const KeyIdOptional& x);

    void
    setKeyId (::std::unique_ptr< KeyIdType > p);

    // Hash
    //
    typedef ::xml_schema::Base64Binary HashType;
    typedef ::xsd::cxx::tree::optional< HashType > HashOptional;
    typedef ::xsd::cxx::tree::traits< HashType, char > HashTraits;

    const HashOptional&
    getHash () const;

    HashOptional&
    getHash ();

    void
    setHash (const HashType& x);

    void
    setHash (const HashOptional& x);

    void
    setHash (::std::unique_ptr< HashType > p);

    // Constructors.
    //
    TrackFileResourceType (const IdType&,
                           const IntrinsicDurationType&,
                           const SourceEncodingType&,
                           const TrackFileIdType&);

    TrackFileResourceType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    TrackFileResourceType (const TrackFileResourceType& x,
                           ::xml_schema::Flags f = 0,
                           ::xml_schema::Container* c = 0);

    virtual TrackFileResourceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    TrackFileResourceType&
    operator= (const TrackFileResourceType& x);

    virtual 
    ~TrackFileResourceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< SourceEncodingType > SourceEncoding_;
    ::xsd::cxx::tree::one< TrackFileIdType > TrackFileId_;
    KeyIdOptional KeyId_;
    HashOptional Hash_;
  };

  class MarkerResourceType: public ::cpl::BaseResourceType
  {
    public:
    // Marker
    //
    typedef ::cpl::MarkerType MarkerType;
    typedef ::xsd::cxx::tree::sequence< MarkerType > MarkerSequence;
    typedef MarkerSequence::iterator MarkerIterator;
    typedef MarkerSequence::const_iterator MarkerConstIterator;
    typedef ::xsd::cxx::tree::traits< MarkerType, char > MarkerTraits;

    const MarkerSequence&
    getMarker () const;

    MarkerSequence&
    getMarker ();

    void
    setMarker (const MarkerSequence& s);

    // Constructors.
    //
    MarkerResourceType (const IdType&,
                        const IntrinsicDurationType&);

    MarkerResourceType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    MarkerResourceType (const MarkerResourceType& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    virtual MarkerResourceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MarkerResourceType&
    operator= (const MarkerResourceType& x);

    virtual 
    ~MarkerResourceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MarkerSequence Marker_;
  };

  class MarkerType: public ::xml_schema::Type
  {
    public:
    // Annotation
    //
    typedef ::dcml::UserTextType AnnotationType;
    typedef ::xsd::cxx::tree::optional< AnnotationType > AnnotationOptional;
    typedef ::xsd::cxx::tree::traits< AnnotationType, char > AnnotationTraits;

    const AnnotationOptional&
    getAnnotation () const;

    AnnotationOptional&
    getAnnotation ();

    void
    setAnnotation (const AnnotationType& x);

    void
    setAnnotation (const AnnotationOptional& x);

    void
    setAnnotation (::std::unique_ptr< AnnotationType > p);

    // Label
    //
    typedef ::cpl::MarkerType_LabelType LabelType;
    typedef ::xsd::cxx::tree::traits< LabelType, char > LabelTraits;

    const LabelType&
    getLabel () const;

    LabelType&
    getLabel ();

    void
    setLabel (const LabelType& x);

    void
    setLabel (::std::unique_ptr< LabelType > p);

    // Offset
    //
    typedef ::xml_schema::NonNegativeInteger OffsetType;
    typedef ::xsd::cxx::tree::traits< OffsetType, char > OffsetTraits;

    const OffsetType&
    getOffset () const;

    OffsetType&
    getOffset ();

    void
    setOffset (const OffsetType& x);

    // Constructors.
    //
    MarkerType (const LabelType&,
                const OffsetType&);

    MarkerType (::std::unique_ptr< LabelType >,
                const OffsetType&);

    MarkerType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    MarkerType (const MarkerType& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    virtual MarkerType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MarkerType&
    operator= (const MarkerType& x);

    virtual 
    ~MarkerType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnnotationOptional Annotation_;
    ::xsd::cxx::tree::one< LabelType > Label_;
    ::xsd::cxx::tree::one< OffsetType > Offset_;
  };

  class CompositionPlaylistType_ContentVersionListType: public ::xml_schema::Type
  {
    public:
    // ContentVersion
    //
    typedef ::cpl::ContentVersionType ContentVersionType;
    typedef ::xsd::cxx::tree::sequence< ContentVersionType > ContentVersionSequence;
    typedef ContentVersionSequence::iterator ContentVersionIterator;
    typedef ContentVersionSequence::const_iterator ContentVersionConstIterator;
    typedef ::xsd::cxx::tree::traits< ContentVersionType, char > ContentVersionTraits;

    const ContentVersionSequence&
    getContentVersion () const;

    ContentVersionSequence&
    getContentVersion ();

    void
    setContentVersion (const ContentVersionSequence& s);

    // Constructors.
    //
    CompositionPlaylistType_ContentVersionListType ();

    CompositionPlaylistType_ContentVersionListType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    CompositionPlaylistType_ContentVersionListType (const CompositionPlaylistType_ContentVersionListType& x,
                                                    ::xml_schema::Flags f = 0,
                                                    ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_ContentVersionListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType_ContentVersionListType&
    operator= (const CompositionPlaylistType_ContentVersionListType& x);

    virtual 
    ~CompositionPlaylistType_ContentVersionListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ContentVersionSequence ContentVersion_;
  };

  class CompositionPlaylistType_EssenceDescriptorListType: public ::xml_schema::Type
  {
    public:
    // EssenceDescriptor
    //
    typedef ::cpl::EssenceDescriptorBaseType EssenceDescriptorType;
    typedef ::xsd::cxx::tree::sequence< EssenceDescriptorType > EssenceDescriptorSequence;
    typedef EssenceDescriptorSequence::iterator EssenceDescriptorIterator;
    typedef EssenceDescriptorSequence::const_iterator EssenceDescriptorConstIterator;
    typedef ::xsd::cxx::tree::traits< EssenceDescriptorType, char > EssenceDescriptorTraits;

    const EssenceDescriptorSequence&
    getEssenceDescriptor () const;

    EssenceDescriptorSequence&
    getEssenceDescriptor ();

    void
    setEssenceDescriptor (const EssenceDescriptorSequence& s);

    // Constructors.
    //
    CompositionPlaylistType_EssenceDescriptorListType ();

    CompositionPlaylistType_EssenceDescriptorListType (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    CompositionPlaylistType_EssenceDescriptorListType (const CompositionPlaylistType_EssenceDescriptorListType& x,
                                                       ::xml_schema::Flags f = 0,
                                                       ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_EssenceDescriptorListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType_EssenceDescriptorListType&
    operator= (const CompositionPlaylistType_EssenceDescriptorListType& x);

    virtual 
    ~CompositionPlaylistType_EssenceDescriptorListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EssenceDescriptorSequence EssenceDescriptor_;
  };

  class CompositionPlaylistType_TotalRunningTimeType: public ::xml_schema::String
  {
    public:
    // Constructors.
    //
    CompositionPlaylistType_TotalRunningTimeType ();

    CompositionPlaylistType_TotalRunningTimeType (const char*);

    CompositionPlaylistType_TotalRunningTimeType (const ::std::string&);

    CompositionPlaylistType_TotalRunningTimeType (const ::xml_schema::String&);

    CompositionPlaylistType_TotalRunningTimeType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    CompositionPlaylistType_TotalRunningTimeType (const ::xercesc::DOMAttr& a,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    CompositionPlaylistType_TotalRunningTimeType (const ::std::string& s,
                                                  const ::xercesc::DOMElement* e,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    CompositionPlaylistType_TotalRunningTimeType (const CompositionPlaylistType_TotalRunningTimeType& x,
                                                  ::xml_schema::Flags f = 0,
                                                  ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_TotalRunningTimeType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    virtual 
    ~CompositionPlaylistType_TotalRunningTimeType ();
  };

  class CompositionPlaylistType_LocaleListType: public ::xml_schema::Type
  {
    public:
    // Locale
    //
    typedef ::cpl::LocaleType LocaleType;
    typedef ::xsd::cxx::tree::sequence< LocaleType > LocaleSequence;
    typedef LocaleSequence::iterator LocaleIterator;
    typedef LocaleSequence::const_iterator LocaleConstIterator;
    typedef ::xsd::cxx::tree::traits< LocaleType, char > LocaleTraits;

    const LocaleSequence&
    getLocale () const;

    LocaleSequence&
    getLocale ();

    void
    setLocale (const LocaleSequence& s);

    // Constructors.
    //
    CompositionPlaylistType_LocaleListType ();

    CompositionPlaylistType_LocaleListType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    CompositionPlaylistType_LocaleListType (const CompositionPlaylistType_LocaleListType& x,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_LocaleListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType_LocaleListType&
    operator= (const CompositionPlaylistType_LocaleListType& x);

    virtual 
    ~CompositionPlaylistType_LocaleListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LocaleSequence Locale_;
  };

  class CompositionPlaylistType_ExtensionPropertiesType: public ::xml_schema::Type
  {
    public:
    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    CompositionPlaylistType_ExtensionPropertiesType ();

    CompositionPlaylistType_ExtensionPropertiesType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    CompositionPlaylistType_ExtensionPropertiesType (const CompositionPlaylistType_ExtensionPropertiesType& x,
                                                     ::xml_schema::Flags f = 0,
                                                     ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_ExtensionPropertiesType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType_ExtensionPropertiesType&
    operator= (const CompositionPlaylistType_ExtensionPropertiesType& x);

    virtual 
    ~CompositionPlaylistType_ExtensionPropertiesType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    AnySequence any_;
  };

  class CompositionPlaylistType_SegmentListType: public ::xml_schema::Type
  {
    public:
    // Segment
    //
    typedef ::cpl::SegmentType SegmentType;
    typedef ::xsd::cxx::tree::sequence< SegmentType > SegmentSequence;
    typedef SegmentSequence::iterator SegmentIterator;
    typedef SegmentSequence::const_iterator SegmentConstIterator;
    typedef ::xsd::cxx::tree::traits< SegmentType, char > SegmentTraits;

    const SegmentSequence&
    getSegment () const;

    SegmentSequence&
    getSegment ();

    void
    setSegment (const SegmentSequence& s);

    // Constructors.
    //
    CompositionPlaylistType_SegmentListType ();

    CompositionPlaylistType_SegmentListType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    CompositionPlaylistType_SegmentListType (const CompositionPlaylistType_SegmentListType& x,
                                             ::xml_schema::Flags f = 0,
                                             ::xml_schema::Container* c = 0);

    virtual CompositionPlaylistType_SegmentListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    CompositionPlaylistType_SegmentListType&
    operator= (const CompositionPlaylistType_SegmentListType& x);

    virtual 
    ~CompositionPlaylistType_SegmentListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SegmentSequence Segment_;
  };

  class LocaleType_LanguageListType: public ::xml_schema::Type
  {
    public:
    // Language
    //
    typedef ::xml_schema::String LanguageType;
    typedef ::xsd::cxx::tree::sequence< LanguageType > LanguageSequence;
    typedef LanguageSequence::iterator LanguageIterator;
    typedef LanguageSequence::const_iterator LanguageConstIterator;
    typedef ::xsd::cxx::tree::traits< LanguageType, char > LanguageTraits;

    const LanguageSequence&
    getLanguage () const;

    LanguageSequence&
    getLanguage ();

    void
    setLanguage (const LanguageSequence& s);

    // Constructors.
    //
    LocaleType_LanguageListType ();

    LocaleType_LanguageListType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    LocaleType_LanguageListType (const LocaleType_LanguageListType& x,
                                 ::xml_schema::Flags f = 0,
                                 ::xml_schema::Container* c = 0);

    virtual LocaleType_LanguageListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocaleType_LanguageListType&
    operator= (const LocaleType_LanguageListType& x);

    virtual 
    ~LocaleType_LanguageListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LanguageSequence Language_;
  };

  class LocaleType_RegionListType: public ::xml_schema::Type
  {
    public:
    // Region
    //
    typedef ::xml_schema::String RegionType;
    typedef ::xsd::cxx::tree::sequence< RegionType > RegionSequence;
    typedef RegionSequence::iterator RegionIterator;
    typedef RegionSequence::const_iterator RegionConstIterator;
    typedef ::xsd::cxx::tree::traits< RegionType, char > RegionTraits;

    const RegionSequence&
    getRegion () const;

    RegionSequence&
    getRegion ();

    void
    setRegion (const RegionSequence& s);

    // Constructors.
    //
    LocaleType_RegionListType ();

    LocaleType_RegionListType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    LocaleType_RegionListType (const LocaleType_RegionListType& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    virtual LocaleType_RegionListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocaleType_RegionListType&
    operator= (const LocaleType_RegionListType& x);

    virtual 
    ~LocaleType_RegionListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RegionSequence Region_;
  };

  class LocaleType_ContentMaturityRatingListType: public ::xml_schema::Type
  {
    public:
    // ContentMaturityRating
    //
    typedef ::cpl::ContentMaturityRatingType ContentMaturityRatingType;
    typedef ::xsd::cxx::tree::sequence< ContentMaturityRatingType > ContentMaturityRatingSequence;
    typedef ContentMaturityRatingSequence::iterator ContentMaturityRatingIterator;
    typedef ContentMaturityRatingSequence::const_iterator ContentMaturityRatingConstIterator;
    typedef ::xsd::cxx::tree::traits< ContentMaturityRatingType, char > ContentMaturityRatingTraits;

    const ContentMaturityRatingSequence&
    getContentMaturityRating () const;

    ContentMaturityRatingSequence&
    getContentMaturityRating ();

    void
    setContentMaturityRating (const ContentMaturityRatingSequence& s);

    // Constructors.
    //
    LocaleType_ContentMaturityRatingListType ();

    LocaleType_ContentMaturityRatingListType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    LocaleType_ContentMaturityRatingListType (const LocaleType_ContentMaturityRatingListType& x,
                                              ::xml_schema::Flags f = 0,
                                              ::xml_schema::Container* c = 0);

    virtual LocaleType_ContentMaturityRatingListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    LocaleType_ContentMaturityRatingListType&
    operator= (const LocaleType_ContentMaturityRatingListType& x);

    virtual 
    ~LocaleType_ContentMaturityRatingListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ContentMaturityRatingSequence ContentMaturityRating_;
  };

  class ContentMaturityRatingType_AudienceType: public ::xml_schema::String
  {
    public:
    // scope
    //
    typedef ::xml_schema::Uri ScopeType;
    typedef ::xsd::cxx::tree::traits< ScopeType, char > ScopeTraits;

    const ScopeType&
    getScope () const;

    ScopeType&
    getScope ();

    void
    setScope (const ScopeType& x);

    void
    setScope (::std::unique_ptr< ScopeType > p);

    // Constructors.
    //
    ContentMaturityRatingType_AudienceType (const ScopeType&);

    ContentMaturityRatingType_AudienceType (const char*,
                                            const ScopeType&);

    ContentMaturityRatingType_AudienceType (const ::std::string&,
                                            const ScopeType&);

    ContentMaturityRatingType_AudienceType (const ::xml_schema::String&,
                                            const ScopeType&);

    ContentMaturityRatingType_AudienceType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    ContentMaturityRatingType_AudienceType (const ContentMaturityRatingType_AudienceType& x,
                                            ::xml_schema::Flags f = 0,
                                            ::xml_schema::Container* c = 0);

    virtual ContentMaturityRatingType_AudienceType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    ContentMaturityRatingType_AudienceType&
    operator= (const ContentMaturityRatingType_AudienceType& x);

    virtual 
    ~ContentMaturityRatingType_AudienceType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ScopeType > scope_;
  };

  class SegmentType_SequenceListType: public ::xml_schema::Type
  {
    public:
    // MarkerSequence
    //
    typedef ::cpl::SequenceType MarkerSequenceType;
    typedef ::xsd::cxx::tree::optional< MarkerSequenceType > MarkerSequenceOptional;
    typedef ::xsd::cxx::tree::traits< MarkerSequenceType, char > MarkerSequenceTraits;

    const MarkerSequenceOptional&
    getMarkerSequence () const;

    MarkerSequenceOptional&
    getMarkerSequence ();

    void
    setMarkerSequence (const MarkerSequenceType& x);

    void
    setMarkerSequence (const MarkerSequenceOptional& x);

    void
    setMarkerSequence (::std::unique_ptr< MarkerSequenceType > p);

    // any
    //
    typedef ::xsd::cxx::tree::element_sequence AnySequence;
    typedef AnySequence::iterator AnyIterator;
    typedef AnySequence::const_iterator AnyConstIterator;

    const AnySequence&
    getAny () const;

    AnySequence&
    getAny ();

    void
    setAny (const AnySequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    getDomDocument () const;

    ::xercesc::DOMDocument&
    getDomDocument ();

    // Constructors.
    //
    SegmentType_SequenceListType ();

    SegmentType_SequenceListType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    SegmentType_SequenceListType (const SegmentType_SequenceListType& x,
                                  ::xml_schema::Flags f = 0,
                                  ::xml_schema::Container* c = 0);

    virtual SegmentType_SequenceListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SegmentType_SequenceListType&
    operator= (const SegmentType_SequenceListType& x);

    virtual 
    ~SegmentType_SequenceListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > dom_document_;

    MarkerSequenceOptional MarkerSequence_;
    AnySequence any_;
  };

  class SequenceType_ResourceListType: public ::xml_schema::Type
  {
    public:
    // Resource
    //
    typedef ::cpl::BaseResourceType ResourceType;
    typedef ::xsd::cxx::tree::sequence< ResourceType > ResourceSequence;
    typedef ResourceSequence::iterator ResourceIterator;
    typedef ResourceSequence::const_iterator ResourceConstIterator;
    typedef ::xsd::cxx::tree::traits< ResourceType, char > ResourceTraits;

    const ResourceSequence&
    getResource () const;

    ResourceSequence&
    getResource ();

    void
    setResource (const ResourceSequence& s);

    // Constructors.
    //
    SequenceType_ResourceListType ();

    SequenceType_ResourceListType (const ::xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    SequenceType_ResourceListType (const SequenceType_ResourceListType& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    virtual SequenceType_ResourceListType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    SequenceType_ResourceListType&
    operator= (const SequenceType_ResourceListType& x);

    virtual 
    ~SequenceType_ResourceListType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ResourceSequence Resource_;
  };

  class MarkerType_LabelType: public ::xml_schema::String
  {
    public:
    // scope
    //
    typedef ::xml_schema::Uri ScopeType;
    typedef ::xsd::cxx::tree::traits< ScopeType, char > ScopeTraits;

    const ScopeType&
    getScope () const;

    ScopeType&
    getScope ();

    void
    setScope (const ScopeType& x);

    void
    setScope (::std::unique_ptr< ScopeType > p);

    static const ScopeType&
    getScopeDefaultValue ();

    // Constructors.
    //
    MarkerType_LabelType ();

    MarkerType_LabelType (const char*);

    MarkerType_LabelType (const ::std::string&);

    MarkerType_LabelType (const ::xml_schema::String&);

    MarkerType_LabelType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    MarkerType_LabelType (const MarkerType_LabelType& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    virtual MarkerType_LabelType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    MarkerType_LabelType&
    operator= (const MarkerType_LabelType& x);

    virtual 
    ~MarkerType_LabelType ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ScopeType > scope_;
    static const ScopeType scope_default_value_;
  };
}

#include <iosfwd>

namespace cpl
{
  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionTimecodeType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TimecodeType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContentKindType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LocaleType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContentMaturityRatingType&);

  ::std::ostream&
  operator<< (::std::ostream&, const EssenceDescriptorBaseType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContentVersionType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SegmentType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SequenceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const BaseResourceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const TrackFileResourceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MarkerResourceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MarkerType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_ContentVersionListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_EssenceDescriptorListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_TotalRunningTimeType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_LocaleListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_ExtensionPropertiesType&);

  ::std::ostream&
  operator<< (::std::ostream&, const CompositionPlaylistType_SegmentListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LocaleType_LanguageListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LocaleType_RegionListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const LocaleType_ContentMaturityRatingListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const ContentMaturityRatingType_AudienceType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SegmentType_SequenceListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const SequenceType_ResourceListType&);

  ::std::ostream&
  operator<< (::std::ostream&, const MarkerType_LabelType&);
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace cpl
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& uri,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& uri,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& uri,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& id,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& id,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& is,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& is,
                            ::xml_schema::ErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& is,
                            ::xercesc::DOMErrorHandler& eh,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::xercesc::DOMDocument& d,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f = 0,
                            const ::xml_schema::Properties& p = ::xml_schema::Properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace cpl
{
  // Serialize to std::ostream.
  //

  void
  serializeCompositionPlaylist (::std::ostream& os,
                                const ::cpl::CompositionPlaylistType& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializeCompositionPlaylist (::std::ostream& os,
                                const ::cpl::CompositionPlaylistType& x, 
                                ::xml_schema::ErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializeCompositionPlaylist (::std::ostream& os,
                                const ::cpl::CompositionPlaylistType& x, 
                                ::xercesc::DOMErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& ft,
                                const ::cpl::CompositionPlaylistType& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& ft,
                                const ::cpl::CompositionPlaylistType& x, 
                                ::xml_schema::ErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& ft,
                                const ::cpl::CompositionPlaylistType& x, 
                                ::xercesc::DOMErrorHandler& eh,
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                const ::std::string& e = "UTF-8",
                                ::xml_schema::Flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  serializeCompositionPlaylist (::xercesc::DOMDocument& d,
                                const ::cpl::CompositionPlaylistType& x,
                                ::xml_schema::Flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeCompositionPlaylist (const ::cpl::CompositionPlaylistType& x, 
                                const ::xml_schema::NamespaceInfomap& m = ::xml_schema::NamespaceInfomap (),
                                ::xml_schema::Flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionTimecodeType&);

  void
  operator<< (::xercesc::DOMElement&, const TimecodeType&);

  void
  operator<< (::xercesc::DOMAttr&, const TimecodeType&);

  void
  operator<< (::xml_schema::ListStream&,
              const TimecodeType&);

  void
  operator<< (::xercesc::DOMElement&, const ContentKindType&);

  void
  operator<< (::xercesc::DOMElement&, const LocaleType&);

  void
  operator<< (::xercesc::DOMElement&, const ContentMaturityRatingType&);

  void
  operator<< (::xercesc::DOMElement&, const EssenceDescriptorBaseType&);

  void
  operator<< (::xercesc::DOMElement&, const ContentVersionType&);

  void
  operator<< (::xercesc::DOMElement&, const SegmentType&);

  void
  operator<< (::xercesc::DOMElement&, const SequenceType&);

  void
  operator<< (::xercesc::DOMElement&, const BaseResourceType&);

  void
  operator<< (::xercesc::DOMElement&, const TrackFileResourceType&);

  void
  operator<< (::xercesc::DOMElement&, const MarkerResourceType&);

  void
  operator<< (::xercesc::DOMElement&, const MarkerType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_ContentVersionListType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_EssenceDescriptorListType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_TotalRunningTimeType&);

  void
  operator<< (::xercesc::DOMAttr&, const CompositionPlaylistType_TotalRunningTimeType&);

  void
  operator<< (::xml_schema::ListStream&,
              const CompositionPlaylistType_TotalRunningTimeType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_LocaleListType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_ExtensionPropertiesType&);

  void
  operator<< (::xercesc::DOMElement&, const CompositionPlaylistType_SegmentListType&);

  void
  operator<< (::xercesc::DOMElement&, const LocaleType_LanguageListType&);

  void
  operator<< (::xercesc::DOMElement&, const LocaleType_RegionListType&);

  void
  operator<< (::xercesc::DOMElement&, const LocaleType_ContentMaturityRatingListType&);

  void
  operator<< (::xercesc::DOMElement&, const ContentMaturityRatingType_AudienceType&);

  void
  operator<< (::xercesc::DOMElement&, const SegmentType_SequenceListType&);

  void
  operator<< (::xercesc::DOMElement&, const SequenceType_ResourceListType&);

  void
  operator<< (::xercesc::DOMElement&, const MarkerType_LabelType&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SMPTE_2067_3_2013_CPL_H
