// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "st0433-dcmlTypes.h"

namespace dcml
{
  // UUIDType
  // 


  // UserTextType
  // 

  const UserTextType::LanguageType& UserTextType::
  getLanguage () const
  {
    return this->language_.get ();
  }

  UserTextType::LanguageType& UserTextType::
  getLanguage ()
  {
    return this->language_.get ();
  }

  void UserTextType::
  setLanguage (const LanguageType& x)
  {
    this->language_.set (x);
  }

  void UserTextType::
  setLanguage (::std::unique_ptr< LanguageType > x)
  {
    this->language_.set (std::move (x));
  }

  const UserTextType::LanguageType& UserTextType::
  getLanguageDefaultValue ()
  {
    return language_default_value_;
  }


  // RationalType_base
  //

  RationalType_base::
  RationalType_base ()
  : ::xsd::cxx::tree::list< ::xml_schema::Long, char > (this)
  {
  }

  RationalType_base::
  RationalType_base (size_type n, const ::xml_schema::Long& x)
  : ::xsd::cxx::tree::list< ::xml_schema::Long, char > (n, x, this)
  {
  }

  RationalType_base::
  RationalType_base (const RationalType_base& o,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (o, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Long, char > (o, f, this)
  {
  }

  // RationalType
  // 


  // TemperatureUnitsToken
  // 

  TemperatureUnitsToken::
  TemperatureUnitsToken (Value v)
  : ::xml_schema::Token (_xsd_TemperatureUnitsToken_literals_[v])
  {
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const TemperatureUnitsToken& v,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  TemperatureUnitsToken& TemperatureUnitsToken::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_TemperatureUnitsToken_literals_[v]);

    return *this;
  }


  // VoltageUnitsToken
  // 

  VoltageUnitsToken::
  VoltageUnitsToken (Value v)
  : ::xml_schema::Token (_xsd_VoltageUnitsToken_literals_[v])
  {
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const VoltageUnitsToken& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  VoltageUnitsToken& VoltageUnitsToken::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_VoltageUnitsToken_literals_[v]);

    return *this;
  }


  // CurrentUnitsToken
  // 

  CurrentUnitsToken::
  CurrentUnitsToken (Value v)
  : ::xml_schema::Token (_xsd_CurrentUnitsToken_literals_[v])
  {
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const CurrentUnitsToken& v,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  CurrentUnitsToken& CurrentUnitsToken::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_CurrentUnitsToken_literals_[v]);

    return *this;
  }


  // CurrentModeToken
  // 

  CurrentModeToken::
  CurrentModeToken (Value v)
  : ::xml_schema::Token (_xsd_CurrentModeToken_literals_[v])
  {
  }

  CurrentModeToken::
  CurrentModeToken (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentModeToken::
  CurrentModeToken (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentModeToken::
  CurrentModeToken (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  CurrentModeToken::
  CurrentModeToken (const CurrentModeToken& v,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  CurrentModeToken& CurrentModeToken::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_CurrentModeToken_literals_[v]);

    return *this;
  }


  // TimeUnitToken
  // 

  TimeUnitToken::
  TimeUnitToken (Value v)
  : ::xml_schema::Token (_xsd_TimeUnitToken_literals_[v])
  {
  }

  TimeUnitToken::
  TimeUnitToken (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  TimeUnitToken::
  TimeUnitToken (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  TimeUnitToken::
  TimeUnitToken (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  TimeUnitToken::
  TimeUnitToken (const TimeUnitToken& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  TimeUnitToken& TimeUnitToken::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_TimeUnitToken_literals_[v]);

    return *this;
  }


  // TemperatureType
  // 

  const TemperatureType::UnitsType& TemperatureType::
  getUnits () const
  {
    return this->units_.get ();
  }

  TemperatureType::UnitsType& TemperatureType::
  getUnits ()
  {
    return this->units_.get ();
  }

  void TemperatureType::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void TemperatureType::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }


  // VoltageType
  // 

  const VoltageType::UnitsType& VoltageType::
  getUnits () const
  {
    return this->units_.get ();
  }

  VoltageType::UnitsType& VoltageType::
  getUnits ()
  {
    return this->units_.get ();
  }

  void VoltageType::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void VoltageType::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }

  const VoltageType::ModeType& VoltageType::
  getMode () const
  {
    return this->mode_.get ();
  }

  VoltageType::ModeType& VoltageType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void VoltageType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void VoltageType::
  setMode (::std::unique_ptr< ModeType > x)
  {
    this->mode_.set (std::move (x));
  }


  // CurrentType
  // 

  const CurrentType::UnitsType& CurrentType::
  getUnits () const
  {
    return this->units_.get ();
  }

  CurrentType::UnitsType& CurrentType::
  getUnits ()
  {
    return this->units_.get ();
  }

  void CurrentType::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void CurrentType::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }

  const CurrentType::ModeType& CurrentType::
  getMode () const
  {
    return this->mode_.get ();
  }

  CurrentType::ModeType& CurrentType::
  getMode ()
  {
    return this->mode_.get ();
  }

  void CurrentType::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void CurrentType::
  setMode (::std::unique_ptr< ModeType > x)
  {
    this->mode_.set (std::move (x));
  }


  // DurationType
  // 

  const DurationType::UnitsType& DurationType::
  getUnits () const
  {
    return this->units_.get ();
  }

  DurationType::UnitsType& DurationType::
  getUnits ()
  {
    return this->units_.get ();
  }

  void DurationType::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void DurationType::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }


  // RateType
  // 

  const RateType::EventscopeType& RateType::
  getEventscope () const
  {
    return this->eventscope_.get ();
  }

  RateType::EventscopeType& RateType::
  getEventscope ()
  {
    return this->eventscope_.get ();
  }

  void RateType::
  setEventscope (const EventscopeType& x)
  {
    this->eventscope_.set (x);
  }

  void RateType::
  setEventscope (::std::unique_ptr< EventscopeType > x)
  {
    this->eventscope_.set (std::move (x));
  }

  const RateType::EventscopeType& RateType::
  getEventscopeDefaultValue ()
  {
    return eventscope_default_value_;
  }

  const RateType::EventOptional& RateType::
  getEvent () const
  {
    return this->event_;
  }

  RateType::EventOptional& RateType::
  getEvent ()
  {
    return this->event_;
  }

  void RateType::
  setEvent (const EventType& x)
  {
    this->event_.set (x);
  }

  void RateType::
  setEvent (const EventOptional& x)
  {
    this->event_ = x;
  }

  void RateType::
  setEvent (::std::unique_ptr< EventType > x)
  {
    this->event_.set (std::move (x));
  }

  const RateType::PeriodType& RateType::
  getPeriod () const
  {
    return this->period_.get ();
  }

  RateType::PeriodType& RateType::
  getPeriod ()
  {
    return this->period_.get ();
  }

  void RateType::
  setPeriod (const PeriodType& x)
  {
    this->period_.set (x);
  }

  void RateType::
  setPeriod (::std::unique_ptr< PeriodType > x)
  {
    this->period_.set (std::move (x));
  }


  // DeviceIdentifierUnion
  //

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const char* s)
  : ::xml_schema::String (s)
  {
  }

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const ::std::string& s)
  : ::xml_schema::String (s)
  {
  }

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const DeviceIdentifierUnion& o,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (o, f, c)
  {
  }

  // DeviceIdentifierPolyType
  // 

  const DeviceIdentifierPolyType::IdtypeType& DeviceIdentifierPolyType::
  getIdtype () const
  {
    return this->idtype_.get ();
  }

  DeviceIdentifierPolyType::IdtypeType& DeviceIdentifierPolyType::
  getIdtype ()
  {
    return this->idtype_.get ();
  }

  void DeviceIdentifierPolyType::
  setIdtype (const IdtypeType& x)
  {
    this->idtype_.set (x);
  }

  void DeviceIdentifierPolyType::
  setIdtype (::std::unique_ptr< IdtypeType > x)
  {
    this->idtype_.set (std::move (x));
  }


  // DeviceIdentifierListType
  // 

  const DeviceIdentifierListType::PrimaryIDType& DeviceIdentifierListType::
  getPrimaryID () const
  {
    return this->PrimaryID_.get ();
  }

  DeviceIdentifierListType::PrimaryIDType& DeviceIdentifierListType::
  getPrimaryID ()
  {
    return this->PrimaryID_.get ();
  }

  void DeviceIdentifierListType::
  setPrimaryID (const PrimaryIDType& x)
  {
    this->PrimaryID_.set (x);
  }

  void DeviceIdentifierListType::
  setPrimaryID (::std::unique_ptr< PrimaryIDType > x)
  {
    this->PrimaryID_.set (std::move (x));
  }

  const DeviceIdentifierListType::SecondaryIDOptional& DeviceIdentifierListType::
  getSecondaryID () const
  {
    return this->SecondaryID_;
  }

  DeviceIdentifierListType::SecondaryIDOptional& DeviceIdentifierListType::
  getSecondaryID ()
  {
    return this->SecondaryID_;
  }

  void DeviceIdentifierListType::
  setSecondaryID (const SecondaryIDType& x)
  {
    this->SecondaryID_.set (x);
  }

  void DeviceIdentifierListType::
  setSecondaryID (const SecondaryIDOptional& x)
  {
    this->SecondaryID_ = x;
  }

  void DeviceIdentifierListType::
  setSecondaryID (::std::unique_ptr< SecondaryIDType > x)
  {
    this->SecondaryID_.set (std::move (x));
  }


  // DeviceTypeType
  // 

  const DeviceTypeType::ScopeType& DeviceTypeType::
  getScope () const
  {
    return this->scope_.get ();
  }

  DeviceTypeType::ScopeType& DeviceTypeType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void DeviceTypeType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void DeviceTypeType::
  setScope (::std::unique_ptr< ScopeType > x)
  {
    this->scope_.set (std::move (x));
  }

  const DeviceTypeType::ScopeType& DeviceTypeType::
  getScopeDefaultValue ()
  {
    return scope_default_value_;
  }


  // ScopedTokenType
  // 

  const ScopedTokenType::ScopeOptional& ScopedTokenType::
  getScope () const
  {
    return this->scope_;
  }

  ScopedTokenType::ScopeOptional& ScopedTokenType::
  getScope ()
  {
    return this->scope_;
  }

  void ScopedTokenType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void ScopedTokenType::
  setScope (const ScopeOptional& x)
  {
    this->scope_ = x;
  }

  void ScopedTokenType::
  setScope (::std::unique_ptr< ScopeType > x)
  {
    this->scope_.set (std::move (x));
  }


  // NamedParmType
  // 

  const NamedParmType::NameType& NamedParmType::
  getName () const
  {
    return this->Name_.get ();
  }

  NamedParmType::NameType& NamedParmType::
  getName ()
  {
    return this->Name_.get ();
  }

  void NamedParmType::
  setName (const NameType& x)
  {
    this->Name_.set (x);
  }

  void NamedParmType::
  setName (::std::unique_ptr< NameType > x)
  {
    this->Name_.set (std::move (x));
  }

  const NamedParmType::ValueType& NamedParmType::
  getValue () const
  {
    return this->Value_.get ();
  }

  NamedParmType::ValueType& NamedParmType::
  getValue ()
  {
    return this->Value_.get ();
  }

  void NamedParmType::
  setValue (const ValueType& x)
  {
    this->Value_.set (x);
  }

  void NamedParmType::
  setValue (::std::unique_ptr< ValueType > x)
  {
    this->Value_.set (std::move (x));
  }


  // ParameterListType
  // 

  const ParameterListType::ParameterSequence& ParameterListType::
  getParameter () const
  {
    return this->Parameter_;
  }

  ParameterListType::ParameterSequence& ParameterListType::
  getParameter ()
  {
    return this->Parameter_;
  }

  void ParameterListType::
  setParameter (const ParameterSequence& s)
  {
    this->Parameter_ = s;
  }


  // VersionInfoListType
  // 

  const VersionInfoListType::NameSequence& VersionInfoListType::
  getName () const
  {
    return this->Name_;
  }

  VersionInfoListType::NameSequence& VersionInfoListType::
  getName ()
  {
    return this->Name_;
  }

  void VersionInfoListType::
  setName (const NameSequence& s)
  {
    this->Name_ = s;
  }

  const VersionInfoListType::ValueSequence& VersionInfoListType::
  getValue () const
  {
    return this->Value_;
  }

  VersionInfoListType::ValueSequence& VersionInfoListType::
  getValue ()
  {
    return this->Value_;
  }

  void VersionInfoListType::
  setValue (const ValueSequence& s)
  {
    this->Value_ = s;
  }


  // DeviceDescriptionType
  // 

  const DeviceDescriptionType::DeviceIdentifierType& DeviceDescriptionType::
  getDeviceIdentifier () const
  {
    return this->DeviceIdentifier_.get ();
  }

  DeviceDescriptionType::DeviceIdentifierType& DeviceDescriptionType::
  getDeviceIdentifier ()
  {
    return this->DeviceIdentifier_.get ();
  }

  void DeviceDescriptionType::
  setDeviceIdentifier (const DeviceIdentifierType& x)
  {
    this->DeviceIdentifier_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceIdentifier (::std::unique_ptr< DeviceIdentifierType > x)
  {
    this->DeviceIdentifier_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceTypeIDType& DeviceDescriptionType::
  getDeviceTypeID () const
  {
    return this->DeviceTypeID_.get ();
  }

  DeviceDescriptionType::DeviceTypeIDType& DeviceDescriptionType::
  getDeviceTypeID ()
  {
    return this->DeviceTypeID_.get ();
  }

  void DeviceDescriptionType::
  setDeviceTypeID (const DeviceTypeIDType& x)
  {
    this->DeviceTypeID_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceTypeID (::std::unique_ptr< DeviceTypeIDType > x)
  {
    this->DeviceTypeID_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceSubsystemTypeIDOptional& DeviceDescriptionType::
  getDeviceSubsystemTypeID () const
  {
    return this->DeviceSubsystemTypeID_;
  }

  DeviceDescriptionType::DeviceSubsystemTypeIDOptional& DeviceDescriptionType::
  getDeviceSubsystemTypeID ()
  {
    return this->DeviceSubsystemTypeID_;
  }

  void DeviceDescriptionType::
  setDeviceSubsystemTypeID (const DeviceSubsystemTypeIDType& x)
  {
    this->DeviceSubsystemTypeID_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceSubsystemTypeID (const DeviceSubsystemTypeIDOptional& x)
  {
    this->DeviceSubsystemTypeID_ = x;
  }

  void DeviceDescriptionType::
  setDeviceSubsystemTypeID (::std::unique_ptr< DeviceSubsystemTypeIDType > x)
  {
    this->DeviceSubsystemTypeID_.set (std::move (x));
  }

  const DeviceDescriptionType::AdditionalIDOptional& DeviceDescriptionType::
  getAdditionalID () const
  {
    return this->AdditionalID_;
  }

  DeviceDescriptionType::AdditionalIDOptional& DeviceDescriptionType::
  getAdditionalID ()
  {
    return this->AdditionalID_;
  }

  void DeviceDescriptionType::
  setAdditionalID (const AdditionalIDType& x)
  {
    this->AdditionalID_.set (x);
  }

  void DeviceDescriptionType::
  setAdditionalID (const AdditionalIDOptional& x)
  {
    this->AdditionalID_ = x;
  }

  void DeviceDescriptionType::
  setAdditionalID (::std::unique_ptr< AdditionalIDType > x)
  {
    this->AdditionalID_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceSerialType& DeviceDescriptionType::
  getDeviceSerial () const
  {
    return this->DeviceSerial_.get ();
  }

  DeviceDescriptionType::DeviceSerialType& DeviceDescriptionType::
  getDeviceSerial ()
  {
    return this->DeviceSerial_.get ();
  }

  void DeviceDescriptionType::
  setDeviceSerial (const DeviceSerialType& x)
  {
    this->DeviceSerial_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceSerial (::std::unique_ptr< DeviceSerialType > x)
  {
    this->DeviceSerial_.set (std::move (x));
  }

  const DeviceDescriptionType::ManufacturerIDOptional& DeviceDescriptionType::
  getManufacturerID () const
  {
    return this->ManufacturerID_;
  }

  DeviceDescriptionType::ManufacturerIDOptional& DeviceDescriptionType::
  getManufacturerID ()
  {
    return this->ManufacturerID_;
  }

  void DeviceDescriptionType::
  setManufacturerID (const ManufacturerIDType& x)
  {
    this->ManufacturerID_.set (x);
  }

  void DeviceDescriptionType::
  setManufacturerID (const ManufacturerIDOptional& x)
  {
    this->ManufacturerID_ = x;
  }

  void DeviceDescriptionType::
  setManufacturerID (::std::unique_ptr< ManufacturerIDType > x)
  {
    this->ManufacturerID_.set (std::move (x));
  }

  const DeviceDescriptionType::ManufacturerCertIDOptional& DeviceDescriptionType::
  getManufacturerCertID () const
  {
    return this->ManufacturerCertID_;
  }

  DeviceDescriptionType::ManufacturerCertIDOptional& DeviceDescriptionType::
  getManufacturerCertID ()
  {
    return this->ManufacturerCertID_;
  }

  void DeviceDescriptionType::
  setManufacturerCertID (const ManufacturerCertIDType& x)
  {
    this->ManufacturerCertID_.set (x);
  }

  void DeviceDescriptionType::
  setManufacturerCertID (const ManufacturerCertIDOptional& x)
  {
    this->ManufacturerCertID_ = x;
  }

  void DeviceDescriptionType::
  setManufacturerCertID (::std::unique_ptr< ManufacturerCertIDType > x)
  {
    this->ManufacturerCertID_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceCertIDOptional& DeviceDescriptionType::
  getDeviceCertID () const
  {
    return this->DeviceCertID_;
  }

  DeviceDescriptionType::DeviceCertIDOptional& DeviceDescriptionType::
  getDeviceCertID ()
  {
    return this->DeviceCertID_;
  }

  void DeviceDescriptionType::
  setDeviceCertID (const DeviceCertIDType& x)
  {
    this->DeviceCertID_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceCertID (const DeviceCertIDOptional& x)
  {
    this->DeviceCertID_ = x;
  }

  void DeviceDescriptionType::
  setDeviceCertID (::std::unique_ptr< DeviceCertIDType > x)
  {
    this->DeviceCertID_.set (std::move (x));
  }

  const DeviceDescriptionType::ManufacturerNameOptional& DeviceDescriptionType::
  getManufacturerName () const
  {
    return this->ManufacturerName_;
  }

  DeviceDescriptionType::ManufacturerNameOptional& DeviceDescriptionType::
  getManufacturerName ()
  {
    return this->ManufacturerName_;
  }

  void DeviceDescriptionType::
  setManufacturerName (const ManufacturerNameType& x)
  {
    this->ManufacturerName_.set (x);
  }

  void DeviceDescriptionType::
  setManufacturerName (const ManufacturerNameOptional& x)
  {
    this->ManufacturerName_ = x;
  }

  void DeviceDescriptionType::
  setManufacturerName (::std::unique_ptr< ManufacturerNameType > x)
  {
    this->ManufacturerName_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceNameOptional& DeviceDescriptionType::
  getDeviceName () const
  {
    return this->DeviceName_;
  }

  DeviceDescriptionType::DeviceNameOptional& DeviceDescriptionType::
  getDeviceName ()
  {
    return this->DeviceName_;
  }

  void DeviceDescriptionType::
  setDeviceName (const DeviceNameType& x)
  {
    this->DeviceName_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceName (const DeviceNameOptional& x)
  {
    this->DeviceName_ = x;
  }

  void DeviceDescriptionType::
  setDeviceName (::std::unique_ptr< DeviceNameType > x)
  {
    this->DeviceName_.set (std::move (x));
  }

  const DeviceDescriptionType::ModelNumberOptional& DeviceDescriptionType::
  getModelNumber () const
  {
    return this->ModelNumber_;
  }

  DeviceDescriptionType::ModelNumberOptional& DeviceDescriptionType::
  getModelNumber ()
  {
    return this->ModelNumber_;
  }

  void DeviceDescriptionType::
  setModelNumber (const ModelNumberType& x)
  {
    this->ModelNumber_.set (x);
  }

  void DeviceDescriptionType::
  setModelNumber (const ModelNumberOptional& x)
  {
    this->ModelNumber_ = x;
  }

  void DeviceDescriptionType::
  setModelNumber (::std::unique_ptr< ModelNumberType > x)
  {
    this->ModelNumber_.set (std::move (x));
  }

  const DeviceDescriptionType::VersionInfoType& DeviceDescriptionType::
  getVersionInfo () const
  {
    return this->VersionInfo_.get ();
  }

  DeviceDescriptionType::VersionInfoType& DeviceDescriptionType::
  getVersionInfo ()
  {
    return this->VersionInfo_.get ();
  }

  void DeviceDescriptionType::
  setVersionInfo (const VersionInfoType& x)
  {
    this->VersionInfo_.set (x);
  }

  void DeviceDescriptionType::
  setVersionInfo (::std::unique_ptr< VersionInfoType > x)
  {
    this->VersionInfo_.set (std::move (x));
  }

  const DeviceDescriptionType::DeviceCommentOptional& DeviceDescriptionType::
  getDeviceComment () const
  {
    return this->DeviceComment_;
  }

  DeviceDescriptionType::DeviceCommentOptional& DeviceDescriptionType::
  getDeviceComment ()
  {
    return this->DeviceComment_;
  }

  void DeviceDescriptionType::
  setDeviceComment (const DeviceCommentType& x)
  {
    this->DeviceComment_.set (x);
  }

  void DeviceDescriptionType::
  setDeviceComment (const DeviceCommentOptional& x)
  {
    this->DeviceComment_ = x;
  }

  void DeviceDescriptionType::
  setDeviceComment (::std::unique_ptr< DeviceCommentType > x)
  {
    this->DeviceComment_.set (std::move (x));
  }


  // DeviceIdentifierPolyType_idtypeType
  // 

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (Value v)
  : ::xml_schema::Token (_xsd_DeviceIdentifierPolyType_idtypeType_literals_[v])
  {
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const char* v)
  : ::xml_schema::Token (v)
  {
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const ::std::string& v)
  : ::xml_schema::Token (v)
  {
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const ::xml_schema::Token& v)
  : ::xml_schema::Token (v)
  {
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const DeviceIdentifierPolyType_idtypeType& v,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Token (v, f, c)
  {
  }

  DeviceIdentifierPolyType_idtypeType& DeviceIdentifierPolyType_idtypeType::
  operator= (Value v)
  {
    static_cast< ::xml_schema::Token& > (*this) = 
    ::xml_schema::Token (_xsd_DeviceIdentifierPolyType_idtypeType_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace dcml
{
  // UUIDType
  //

  UUIDType::
  UUIDType (const ::xml_schema::Uri& _xsd_Uri_base)
  : ::xml_schema::Uri (_xsd_Uri_base)
  {
  }

  UUIDType::
  UUIDType (const UUIDType& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Uri (x, f, c)
  {
  }

  UUIDType::
  UUIDType (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Uri (e, f, c)
  {
  }

  UUIDType::
  UUIDType (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Uri (a, f, c)
  {
  }

  UUIDType::
  UUIDType (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Uri (s, e, f, c)
  {
  }

  UUIDType* UUIDType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UUIDType (*this, f, c);
  }

  UUIDType::
  ~UUIDType ()
  {
  }

  // UserTextType
  //

  const UserTextType::LanguageType UserTextType::language_default_value_ (
    "en");

  UserTextType::
  UserTextType ()
  : ::xml_schema::String (),
    language_ (getLanguageDefaultValue (), this)
  {
  }

  UserTextType::
  UserTextType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    language_ (getLanguageDefaultValue (), this)
  {
  }

  UserTextType::
  UserTextType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    language_ (getLanguageDefaultValue (), this)
  {
  }

  UserTextType::
  UserTextType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    language_ (getLanguageDefaultValue (), this)
  {
  }

  UserTextType::
  UserTextType (const UserTextType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    language_ (x.language_, f, this)
  {
  }

  UserTextType::
  UserTextType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    language_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void UserTextType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "language" && n.namespace_ ().empty ())
      {
        this->language_.set (LanguageTraits::create (i, f, this));
        continue;
      }
    }

    if (!language_.present ())
    {
      this->language_.set (getLanguageDefaultValue ());
    }
  }

  UserTextType* UserTextType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UserTextType (*this, f, c);
  }

  UserTextType& UserTextType::
  operator= (const UserTextType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->language_ = x.language_;
    }

    return *this;
  }

  UserTextType::
  ~UserTextType ()
  {
  }

  // RationalType_base
  //

  RationalType_base::
  RationalType_base (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Long, char > (e, f, this)
  {
  }

  RationalType_base::
  RationalType_base (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (a, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Long, char > (a, f, this)
  {
  }

  RationalType_base::
  RationalType_base (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::SimpleType (s, e, f, c),
    ::xsd::cxx::tree::list< ::xml_schema::Long, char > (s, e, f, this)
  {
  }

  RationalType_base* RationalType_base::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RationalType_base (*this, f, c);
  }

  RationalType_base::
  ~RationalType_base ()
  {
  }

  // RationalType
  //

  RationalType::
  RationalType ()
  : ::dcml::RationalType_base ()
  {
  }

  RationalType::
  RationalType (const ::dcml::RationalType_base& _xsd_RationalType_base_base)
  : ::dcml::RationalType_base (_xsd_RationalType_base_base)
  {
  }

  RationalType::
  RationalType (const RationalType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::dcml::RationalType_base (x, f, c)
  {
  }

  RationalType::
  RationalType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::dcml::RationalType_base (e, f, c)
  {
  }

  RationalType::
  RationalType (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::dcml::RationalType_base (a, f, c)
  {
  }

  RationalType::
  RationalType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::dcml::RationalType_base (s, e, f, c)
  {
  }

  RationalType* RationalType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RationalType (*this, f, c);
  }

  RationalType::
  ~RationalType ()
  {
  }

  // TemperatureUnitsToken
  //

  TemperatureUnitsToken::
  TemperatureUnitsToken (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_TemperatureUnitsToken_convert ();
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_TemperatureUnitsToken_convert ();
  }

  TemperatureUnitsToken::
  TemperatureUnitsToken (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_TemperatureUnitsToken_convert ();
  }

  TemperatureUnitsToken* TemperatureUnitsToken::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TemperatureUnitsToken (*this, f, c);
  }

  TemperatureUnitsToken::Value TemperatureUnitsToken::
  _xsd_TemperatureUnitsToken_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TemperatureUnitsToken_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_TemperatureUnitsToken_indexes_,
                      _xsd_TemperatureUnitsToken_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_TemperatureUnitsToken_indexes_ + 3 || _xsd_TemperatureUnitsToken_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TemperatureUnitsToken::
  _xsd_TemperatureUnitsToken_literals_[3] =
  {
    "celsius",
    "fahrenheit",
    "kelvin"
  };

  const TemperatureUnitsToken::Value TemperatureUnitsToken::
  _xsd_TemperatureUnitsToken_indexes_[3] =
  {
    ::dcml::TemperatureUnitsToken::celsius,
    ::dcml::TemperatureUnitsToken::fahrenheit,
    ::dcml::TemperatureUnitsToken::kelvin
  };

  // VoltageUnitsToken
  //

  VoltageUnitsToken::
  VoltageUnitsToken (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_VoltageUnitsToken_convert ();
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_VoltageUnitsToken_convert ();
  }

  VoltageUnitsToken::
  VoltageUnitsToken (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_VoltageUnitsToken_convert ();
  }

  VoltageUnitsToken* VoltageUnitsToken::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VoltageUnitsToken (*this, f, c);
  }

  VoltageUnitsToken::Value VoltageUnitsToken::
  _xsd_VoltageUnitsToken_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_VoltageUnitsToken_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_VoltageUnitsToken_indexes_,
                      _xsd_VoltageUnitsToken_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_VoltageUnitsToken_indexes_ + 3 || _xsd_VoltageUnitsToken_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const VoltageUnitsToken::
  _xsd_VoltageUnitsToken_literals_[3] =
  {
    "volts",
    "millivolts",
    "microvolts"
  };

  const VoltageUnitsToken::Value VoltageUnitsToken::
  _xsd_VoltageUnitsToken_indexes_[3] =
  {
    ::dcml::VoltageUnitsToken::microvolts,
    ::dcml::VoltageUnitsToken::millivolts,
    ::dcml::VoltageUnitsToken::volts
  };

  // CurrentUnitsToken
  //

  CurrentUnitsToken::
  CurrentUnitsToken (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_CurrentUnitsToken_convert ();
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_CurrentUnitsToken_convert ();
  }

  CurrentUnitsToken::
  CurrentUnitsToken (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_CurrentUnitsToken_convert ();
  }

  CurrentUnitsToken* CurrentUnitsToken::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CurrentUnitsToken (*this, f, c);
  }

  CurrentUnitsToken::Value CurrentUnitsToken::
  _xsd_CurrentUnitsToken_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CurrentUnitsToken_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CurrentUnitsToken_indexes_,
                      _xsd_CurrentUnitsToken_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_CurrentUnitsToken_indexes_ + 2 || _xsd_CurrentUnitsToken_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CurrentUnitsToken::
  _xsd_CurrentUnitsToken_literals_[2] =
  {
    "amps",
    "milliamps"
  };

  const CurrentUnitsToken::Value CurrentUnitsToken::
  _xsd_CurrentUnitsToken_indexes_[2] =
  {
    ::dcml::CurrentUnitsToken::amps,
    ::dcml::CurrentUnitsToken::milliamps
  };

  // CurrentModeToken
  //

  CurrentModeToken::
  CurrentModeToken (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_CurrentModeToken_convert ();
  }

  CurrentModeToken::
  CurrentModeToken (const ::xercesc::DOMAttr& a,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_CurrentModeToken_convert ();
  }

  CurrentModeToken::
  CurrentModeToken (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_CurrentModeToken_convert ();
  }

  CurrentModeToken* CurrentModeToken::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CurrentModeToken (*this, f, c);
  }

  CurrentModeToken::Value CurrentModeToken::
  _xsd_CurrentModeToken_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CurrentModeToken_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_CurrentModeToken_indexes_,
                      _xsd_CurrentModeToken_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_CurrentModeToken_indexes_ + 2 || _xsd_CurrentModeToken_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const CurrentModeToken::
  _xsd_CurrentModeToken_literals_[2] =
  {
    "AC",
    "DC"
  };

  const CurrentModeToken::Value CurrentModeToken::
  _xsd_CurrentModeToken_indexes_[2] =
  {
    ::dcml::CurrentModeToken::AC,
    ::dcml::CurrentModeToken::DC
  };

  // TimeUnitToken
  //

  TimeUnitToken::
  TimeUnitToken (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_TimeUnitToken_convert ();
  }

  TimeUnitToken::
  TimeUnitToken (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_TimeUnitToken_convert ();
  }

  TimeUnitToken::
  TimeUnitToken (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_TimeUnitToken_convert ();
  }

  TimeUnitToken* TimeUnitToken::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimeUnitToken (*this, f, c);
  }

  TimeUnitToken::Value TimeUnitToken::
  _xsd_TimeUnitToken_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TimeUnitToken_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_TimeUnitToken_indexes_,
                      _xsd_TimeUnitToken_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_TimeUnitToken_indexes_ + 7 || _xsd_TimeUnitToken_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TimeUnitToken::
  _xsd_TimeUnitToken_literals_[7] =
  {
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond"
  };

  const TimeUnitToken::Value TimeUnitToken::
  _xsd_TimeUnitToken_indexes_[7] =
  {
    ::dcml::TimeUnitToken::day,
    ::dcml::TimeUnitToken::hour,
    ::dcml::TimeUnitToken::microsecond,
    ::dcml::TimeUnitToken::millisecond,
    ::dcml::TimeUnitToken::minute,
    ::dcml::TimeUnitToken::second,
    ::dcml::TimeUnitToken::week
  };

  // TemperatureType
  //

  TemperatureType::
  TemperatureType (const ::xml_schema::Decimal& _xsd_Decimal_base,
                   const UnitsType& units)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base),
    units_ (units, this)
  {
  }

  TemperatureType::
  TemperatureType (const TemperatureType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    units_ (x.units_, f, this)
  {
  }

  TemperatureType::
  TemperatureType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::Flags::base, c),
    units_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TemperatureType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }
  }

  TemperatureType* TemperatureType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TemperatureType (*this, f, c);
  }

  TemperatureType& TemperatureType::
  operator= (const TemperatureType& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->units_ = x.units_;
    }

    return *this;
  }

  TemperatureType::
  ~TemperatureType ()
  {
  }

  // VoltageType
  //

  VoltageType::
  VoltageType (const ::xml_schema::Decimal& _xsd_Decimal_base,
               const UnitsType& units,
               const ModeType& mode)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base),
    units_ (units, this),
    mode_ (mode, this)
  {
  }

  VoltageType::
  VoltageType (const VoltageType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    units_ (x.units_, f, this),
    mode_ (x.mode_, f, this)
  {
  }

  VoltageType::
  VoltageType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::Flags::base, c),
    units_ (this),
    mode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void VoltageType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        this->mode_.set (ModeTraits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mode",
        "");
    }
  }

  VoltageType* VoltageType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VoltageType (*this, f, c);
  }

  VoltageType& VoltageType::
  operator= (const VoltageType& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->units_ = x.units_;
      this->mode_ = x.mode_;
    }

    return *this;
  }

  VoltageType::
  ~VoltageType ()
  {
  }

  // CurrentType
  //

  CurrentType::
  CurrentType (const ::xml_schema::Decimal& _xsd_Decimal_base,
               const UnitsType& units,
               const ModeType& mode)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base),
    units_ (units, this),
    mode_ (mode, this)
  {
  }

  CurrentType::
  CurrentType (const CurrentType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    units_ (x.units_, f, this),
    mode_ (x.mode_, f, this)
  {
  }

  CurrentType::
  CurrentType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::Flags::base, c),
    units_ (this),
    mode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CurrentType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        this->mode_.set (ModeTraits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mode",
        "");
    }
  }

  CurrentType* CurrentType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CurrentType (*this, f, c);
  }

  CurrentType& CurrentType::
  operator= (const CurrentType& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->units_ = x.units_;
      this->mode_ = x.mode_;
    }

    return *this;
  }

  CurrentType::
  ~CurrentType ()
  {
  }

  // DurationType
  //

  DurationType::
  DurationType (const ::xml_schema::Decimal& _xsd_Decimal_base,
                const UnitsType& units)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (_xsd_Decimal_base),
    units_ (units, this)
  {
  }

  DurationType::
  DurationType (const DurationType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    units_ (x.units_, f, this)
  {
  }

  DurationType::
  DurationType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::Flags::base, c),
    units_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DurationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }
    }

    if (!units_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "units",
        "");
    }
  }

  DurationType* DurationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DurationType (*this, f, c);
  }

  DurationType& DurationType::
  operator= (const DurationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->units_ = x.units_;
    }

    return *this;
  }

  DurationType::
  ~DurationType ()
  {
  }

  // RateType
  //

  const RateType::EventscopeType RateType::eventscope_default_value_ (
    "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/#rate-scope-tokens");

  RateType::
  RateType (const PeriodType& period)
  : ::dcml::RationalType (),
    eventscope_ (getEventscopeDefaultValue (), this),
    event_ (this),
    period_ (period, this)
  {
  }

  RateType::
  RateType (const ::dcml::RationalType_base& _xsd_RationalType_base_base,
            const PeriodType& period)
  : ::dcml::RationalType (_xsd_RationalType_base_base),
    eventscope_ (getEventscopeDefaultValue (), this),
    event_ (this),
    period_ (period, this)
  {
  }

  RateType::
  RateType (const RateType& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::dcml::RationalType (x, f, c),
    eventscope_ (x.eventscope_, f, this),
    event_ (x.event_, f, this),
    period_ (x.period_, f, this)
  {
  }

  RateType::
  RateType (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::dcml::RationalType (e, f | ::xml_schema::Flags::base, c),
    eventscope_ (this),
    event_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RateType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "eventscope" && n.namespace_ ().empty ())
      {
        this->eventscope_.set (EventscopeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "event" && n.namespace_ ().empty ())
      {
        this->event_.set (EventTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (PeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!eventscope_.present ())
    {
      this->eventscope_.set (getEventscopeDefaultValue ());
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "period",
        "");
    }
  }

  RateType* RateType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RateType (*this, f, c);
  }

  RateType& RateType::
  operator= (const RateType& x)
  {
    if (this != &x)
    {
      static_cast< ::dcml::RationalType& > (*this) = x;
      this->eventscope_ = x.eventscope_;
      this->event_ = x.event_;
      this->period_ = x.period_;
    }

    return *this;
  }

  RateType::
  ~RateType ()
  {
  }

  // DeviceIdentifierUnion
  //

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const ::xercesc::DOMAttr& a,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DeviceIdentifierUnion::
  DeviceIdentifierUnion (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DeviceIdentifierUnion* DeviceIdentifierUnion::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceIdentifierUnion (*this, f, c);
  }

  // DeviceIdentifierPolyType
  //

  DeviceIdentifierPolyType::
  DeviceIdentifierPolyType (const char* _xsd_DeviceIdentifierUnion_base,
                            const IdtypeType& idtype)
  : ::dcml::DeviceIdentifierUnion (_xsd_DeviceIdentifierUnion_base),
    idtype_ (idtype, this)
  {
  }

  DeviceIdentifierPolyType::
  DeviceIdentifierPolyType (const ::std::string& _xsd_DeviceIdentifierUnion_base,
                            const IdtypeType& idtype)
  : ::dcml::DeviceIdentifierUnion (_xsd_DeviceIdentifierUnion_base),
    idtype_ (idtype, this)
  {
  }

  DeviceIdentifierPolyType::
  DeviceIdentifierPolyType (const ::dcml::DeviceIdentifierUnion& _xsd_DeviceIdentifierUnion_base,
                            const IdtypeType& idtype)
  : ::dcml::DeviceIdentifierUnion (_xsd_DeviceIdentifierUnion_base),
    idtype_ (idtype, this)
  {
  }

  DeviceIdentifierPolyType::
  DeviceIdentifierPolyType (const DeviceIdentifierPolyType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::dcml::DeviceIdentifierUnion (x, f, c),
    idtype_ (x.idtype_, f, this)
  {
  }

  DeviceIdentifierPolyType::
  DeviceIdentifierPolyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::dcml::DeviceIdentifierUnion (e, f | ::xml_schema::Flags::base, c),
    idtype_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DeviceIdentifierPolyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "idtype" && n.namespace_ ().empty ())
      {
        this->idtype_.set (IdtypeTraits::create (i, f, this));
        continue;
      }
    }

    if (!idtype_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "idtype",
        "");
    }
  }

  DeviceIdentifierPolyType* DeviceIdentifierPolyType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceIdentifierPolyType (*this, f, c);
  }

  DeviceIdentifierPolyType& DeviceIdentifierPolyType::
  operator= (const DeviceIdentifierPolyType& x)
  {
    if (this != &x)
    {
      static_cast< ::dcml::DeviceIdentifierUnion& > (*this) = x;
      this->idtype_ = x.idtype_;
    }

    return *this;
  }

  DeviceIdentifierPolyType::
  ~DeviceIdentifierPolyType ()
  {
  }

  // DeviceIdentifierListType
  //

  DeviceIdentifierListType::
  DeviceIdentifierListType (const PrimaryIDType& PrimaryID)
  : ::xml_schema::Type (),
    PrimaryID_ (PrimaryID, this),
    SecondaryID_ (this)
  {
  }

  DeviceIdentifierListType::
  DeviceIdentifierListType (::std::unique_ptr< PrimaryIDType > PrimaryID)
  : ::xml_schema::Type (),
    PrimaryID_ (std::move (PrimaryID), this),
    SecondaryID_ (this)
  {
  }

  DeviceIdentifierListType::
  DeviceIdentifierListType (const DeviceIdentifierListType& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PrimaryID_ (x.PrimaryID_, f, this),
    SecondaryID_ (x.SecondaryID_, f, this)
  {
  }

  DeviceIdentifierListType::
  DeviceIdentifierListType (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PrimaryID_ (this),
    SecondaryID_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeviceIdentifierListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PrimaryID
      //
      if (n.name () == "PrimaryID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< PrimaryIDType > r (
          PrimaryIDTraits::create (i, f, this));

        if (!PrimaryID_.present ())
        {
          this->PrimaryID_.set (::std::move (r));
          continue;
        }
      }

      // SecondaryID
      //
      if (n.name () == "SecondaryID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< SecondaryIDType > r (
          SecondaryIDTraits::create (i, f, this));

        if (!this->SecondaryID_)
        {
          this->SecondaryID_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!PrimaryID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PrimaryID",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }
  }

  DeviceIdentifierListType* DeviceIdentifierListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceIdentifierListType (*this, f, c);
  }

  DeviceIdentifierListType& DeviceIdentifierListType::
  operator= (const DeviceIdentifierListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->PrimaryID_ = x.PrimaryID_;
      this->SecondaryID_ = x.SecondaryID_;
    }

    return *this;
  }

  DeviceIdentifierListType::
  ~DeviceIdentifierListType ()
  {
  }

  // DeviceTypeType
  //

  const DeviceTypeType::ScopeType DeviceTypeType::scope_default_value_ (
    "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/#device-type-tokens");

  DeviceTypeType::
  DeviceTypeType ()
  : ::xml_schema::Token (),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  DeviceTypeType::
  DeviceTypeType (const char* _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  DeviceTypeType::
  DeviceTypeType (const ::std::string& _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  DeviceTypeType::
  DeviceTypeType (const ::xml_schema::Token& _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  DeviceTypeType::
  DeviceTypeType (const DeviceTypeType& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Token (x, f, c),
    scope_ (x.scope_, f, this)
  {
  }

  DeviceTypeType::
  DeviceTypeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f | ::xml_schema::Flags::base, c),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DeviceTypeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      this->scope_.set (getScopeDefaultValue ());
    }
  }

  DeviceTypeType* DeviceTypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceTypeType (*this, f, c);
  }

  DeviceTypeType& DeviceTypeType::
  operator= (const DeviceTypeType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Token& > (*this) = x;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  DeviceTypeType::
  ~DeviceTypeType ()
  {
  }

  // ScopedTokenType
  //

  ScopedTokenType::
  ScopedTokenType ()
  : ::xml_schema::Token (),
    scope_ (this)
  {
  }

  ScopedTokenType::
  ScopedTokenType (const char* _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (this)
  {
  }

  ScopedTokenType::
  ScopedTokenType (const ::std::string& _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (this)
  {
  }

  ScopedTokenType::
  ScopedTokenType (const ::xml_schema::Token& _xsd_Token_base)
  : ::xml_schema::Token (_xsd_Token_base),
    scope_ (this)
  {
  }

  ScopedTokenType::
  ScopedTokenType (const ScopedTokenType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Token (x, f, c),
    scope_ (x.scope_, f, this)
  {
  }

  ScopedTokenType::
  ScopedTokenType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f | ::xml_schema::Flags::base, c),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ScopedTokenType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }
  }

  ScopedTokenType* ScopedTokenType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ScopedTokenType (*this, f, c);
  }

  ScopedTokenType& ScopedTokenType::
  operator= (const ScopedTokenType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Token& > (*this) = x;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  ScopedTokenType::
  ~ScopedTokenType ()
  {
  }

  // NamedParmType
  //

  NamedParmType::
  NamedParmType (const NameType& Name,
                 const ValueType& Value)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    Value_ (Value, this)
  {
  }

  NamedParmType::
  NamedParmType (::std::unique_ptr< NameType > Name,
                 const ValueType& Value)
  : ::xml_schema::Type (),
    Name_ (std::move (Name), this),
    Value_ (Value, this)
  {
  }

  NamedParmType::
  NamedParmType (const NamedParmType& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    Value_ (x.Value_, f, this)
  {
  }

  NamedParmType::
  NamedParmType (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NamedParmType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (::std::move (r));
          continue;
        }
      }

      // Value
      //
      if (n.name () == "Value" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        if (!Value_.present ())
        {
          this->Value_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Value",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }
  }

  NamedParmType* NamedParmType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NamedParmType (*this, f, c);
  }

  NamedParmType& NamedParmType::
  operator= (const NamedParmType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  NamedParmType::
  ~NamedParmType ()
  {
  }

  // ParameterListType
  //

  ParameterListType::
  ParameterListType ()
  : ::xml_schema::Type (),
    Parameter_ (this)
  {
  }

  ParameterListType::
  ParameterListType (const ParameterListType& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Parameter_ (x.Parameter_, f, this)
  {
  }

  ParameterListType::
  ParameterListType (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Parameter_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ParameterListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Parameter
      //
      if (n.name () == "Parameter" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        this->Parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ParameterListType* ParameterListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParameterListType (*this, f, c);
  }

  ParameterListType& ParameterListType::
  operator= (const ParameterListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Parameter_ = x.Parameter_;
    }

    return *this;
  }

  ParameterListType::
  ~ParameterListType ()
  {
  }

  // VersionInfoListType
  //

  VersionInfoListType::
  VersionInfoListType ()
  : ::xml_schema::Type (),
    Name_ (this),
    Value_ (this)
  {
  }

  VersionInfoListType::
  VersionInfoListType (const VersionInfoListType& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    Value_ (x.Value_, f, this)
  {
  }

  VersionInfoListType::
  VersionInfoListType (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    Value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VersionInfoListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< NameType > r (
          NameTraits::create (i, f, this));

        this->Name_.push_back (::std::move (r));
        continue;
      }

      // Value
      //
      if (n.name () == "Value" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        this->Value_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  VersionInfoListType* VersionInfoListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VersionInfoListType (*this, f, c);
  }

  VersionInfoListType& VersionInfoListType::
  operator= (const VersionInfoListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->Value_ = x.Value_;
    }

    return *this;
  }

  VersionInfoListType::
  ~VersionInfoListType ()
  {
  }

  // DeviceDescriptionType
  //

  DeviceDescriptionType::
  DeviceDescriptionType (const DeviceIdentifierType& DeviceIdentifier,
                         const DeviceTypeIDType& DeviceTypeID,
                         const DeviceSerialType& DeviceSerial,
                         const VersionInfoType& VersionInfo)
  : ::xml_schema::Type (),
    DeviceIdentifier_ (DeviceIdentifier, this),
    DeviceTypeID_ (DeviceTypeID, this),
    DeviceSubsystemTypeID_ (this),
    AdditionalID_ (this),
    DeviceSerial_ (DeviceSerial, this),
    ManufacturerID_ (this),
    ManufacturerCertID_ (this),
    DeviceCertID_ (this),
    ManufacturerName_ (this),
    DeviceName_ (this),
    ModelNumber_ (this),
    VersionInfo_ (VersionInfo, this),
    DeviceComment_ (this)
  {
  }

  DeviceDescriptionType::
  DeviceDescriptionType (::std::unique_ptr< DeviceIdentifierType > DeviceIdentifier,
                         ::std::unique_ptr< DeviceTypeIDType > DeviceTypeID,
                         const DeviceSerialType& DeviceSerial,
                         ::std::unique_ptr< VersionInfoType > VersionInfo)
  : ::xml_schema::Type (),
    DeviceIdentifier_ (std::move (DeviceIdentifier), this),
    DeviceTypeID_ (std::move (DeviceTypeID), this),
    DeviceSubsystemTypeID_ (this),
    AdditionalID_ (this),
    DeviceSerial_ (DeviceSerial, this),
    ManufacturerID_ (this),
    ManufacturerCertID_ (this),
    DeviceCertID_ (this),
    ManufacturerName_ (this),
    DeviceName_ (this),
    ModelNumber_ (this),
    VersionInfo_ (std::move (VersionInfo), this),
    DeviceComment_ (this)
  {
  }

  DeviceDescriptionType::
  DeviceDescriptionType (const DeviceDescriptionType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    DeviceIdentifier_ (x.DeviceIdentifier_, f, this),
    DeviceTypeID_ (x.DeviceTypeID_, f, this),
    DeviceSubsystemTypeID_ (x.DeviceSubsystemTypeID_, f, this),
    AdditionalID_ (x.AdditionalID_, f, this),
    DeviceSerial_ (x.DeviceSerial_, f, this),
    ManufacturerID_ (x.ManufacturerID_, f, this),
    ManufacturerCertID_ (x.ManufacturerCertID_, f, this),
    DeviceCertID_ (x.DeviceCertID_, f, this),
    ManufacturerName_ (x.ManufacturerName_, f, this),
    DeviceName_ (x.DeviceName_, f, this),
    ModelNumber_ (x.ModelNumber_, f, this),
    VersionInfo_ (x.VersionInfo_, f, this),
    DeviceComment_ (x.DeviceComment_, f, this)
  {
  }

  DeviceDescriptionType::
  DeviceDescriptionType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    DeviceIdentifier_ (this),
    DeviceTypeID_ (this),
    DeviceSubsystemTypeID_ (this),
    AdditionalID_ (this),
    DeviceSerial_ (this),
    ManufacturerID_ (this),
    ManufacturerCertID_ (this),
    DeviceCertID_ (this),
    ManufacturerName_ (this),
    DeviceName_ (this),
    ModelNumber_ (this),
    VersionInfo_ (this),
    DeviceComment_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeviceDescriptionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DeviceIdentifier
      //
      if (n.name () == "DeviceIdentifier" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceIdentifierType > r (
          DeviceIdentifierTraits::create (i, f, this));

        if (!DeviceIdentifier_.present ())
        {
          this->DeviceIdentifier_.set (::std::move (r));
          continue;
        }
      }

      // DeviceTypeID
      //
      if (n.name () == "DeviceTypeID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceTypeIDType > r (
          DeviceTypeIDTraits::create (i, f, this));

        if (!DeviceTypeID_.present ())
        {
          this->DeviceTypeID_.set (::std::move (r));
          continue;
        }
      }

      // DeviceSubsystemTypeID
      //
      if (n.name () == "DeviceSubsystemTypeID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceSubsystemTypeIDType > r (
          DeviceSubsystemTypeIDTraits::create (i, f, this));

        if (!this->DeviceSubsystemTypeID_)
        {
          this->DeviceSubsystemTypeID_.set (::std::move (r));
          continue;
        }
      }

      // AdditionalID
      //
      if (n.name () == "AdditionalID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< AdditionalIDType > r (
          AdditionalIDTraits::create (i, f, this));

        if (!this->AdditionalID_)
        {
          this->AdditionalID_.set (::std::move (r));
          continue;
        }
      }

      // DeviceSerial
      //
      if (n.name () == "DeviceSerial" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceSerialType > r (
          DeviceSerialTraits::create (i, f, this));

        if (!DeviceSerial_.present ())
        {
          this->DeviceSerial_.set (::std::move (r));
          continue;
        }
      }

      // ManufacturerID
      //
      if (n.name () == "ManufacturerID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ManufacturerIDType > r (
          ManufacturerIDTraits::create (i, f, this));

        if (!this->ManufacturerID_)
        {
          this->ManufacturerID_.set (::std::move (r));
          continue;
        }
      }

      // ManufacturerCertID
      //
      if (n.name () == "ManufacturerCertID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ManufacturerCertIDType > r (
          ManufacturerCertIDTraits::create (i, f, this));

        if (!this->ManufacturerCertID_)
        {
          this->ManufacturerCertID_.set (::std::move (r));
          continue;
        }
      }

      // DeviceCertID
      //
      if (n.name () == "DeviceCertID" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceCertIDType > r (
          DeviceCertIDTraits::create (i, f, this));

        if (!this->DeviceCertID_)
        {
          this->DeviceCertID_.set (::std::move (r));
          continue;
        }
      }

      // ManufacturerName
      //
      if (n.name () == "ManufacturerName" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ManufacturerNameType > r (
          ManufacturerNameTraits::create (i, f, this));

        if (!this->ManufacturerName_)
        {
          this->ManufacturerName_.set (::std::move (r));
          continue;
        }
      }

      // DeviceName
      //
      if (n.name () == "DeviceName" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceNameType > r (
          DeviceNameTraits::create (i, f, this));

        if (!this->DeviceName_)
        {
          this->DeviceName_.set (::std::move (r));
          continue;
        }
      }

      // ModelNumber
      //
      if (n.name () == "ModelNumber" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< ModelNumberType > r (
          ModelNumberTraits::create (i, f, this));

        if (!this->ModelNumber_)
        {
          this->ModelNumber_.set (::std::move (r));
          continue;
        }
      }

      // VersionInfo
      //
      if (n.name () == "VersionInfo" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< VersionInfoType > r (
          VersionInfoTraits::create (i, f, this));

        if (!VersionInfo_.present ())
        {
          this->VersionInfo_.set (::std::move (r));
          continue;
        }
      }

      // DeviceComment
      //
      if (n.name () == "DeviceComment" && n.namespace_ () == "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/")
      {
        ::std::unique_ptr< DeviceCommentType > r (
          DeviceCommentTraits::create (i, f, this));

        if (!this->DeviceComment_)
        {
          this->DeviceComment_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!DeviceIdentifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeviceIdentifier",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }

    if (!DeviceTypeID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeviceTypeID",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }

    if (!DeviceSerial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeviceSerial",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }

    if (!VersionInfo_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "VersionInfo",
        "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/");
    }
  }

  DeviceDescriptionType* DeviceDescriptionType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceDescriptionType (*this, f, c);
  }

  DeviceDescriptionType& DeviceDescriptionType::
  operator= (const DeviceDescriptionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->DeviceIdentifier_ = x.DeviceIdentifier_;
      this->DeviceTypeID_ = x.DeviceTypeID_;
      this->DeviceSubsystemTypeID_ = x.DeviceSubsystemTypeID_;
      this->AdditionalID_ = x.AdditionalID_;
      this->DeviceSerial_ = x.DeviceSerial_;
      this->ManufacturerID_ = x.ManufacturerID_;
      this->ManufacturerCertID_ = x.ManufacturerCertID_;
      this->DeviceCertID_ = x.DeviceCertID_;
      this->ManufacturerName_ = x.ManufacturerName_;
      this->DeviceName_ = x.DeviceName_;
      this->ModelNumber_ = x.ModelNumber_;
      this->VersionInfo_ = x.VersionInfo_;
      this->DeviceComment_ = x.DeviceComment_;
    }

    return *this;
  }

  DeviceDescriptionType::
  ~DeviceDescriptionType ()
  {
  }

  // DeviceIdentifierPolyType_idtypeType
  //

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const ::xercesc::DOMElement& e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Token (e, f, c)
  {
    _xsd_DeviceIdentifierPolyType_idtypeType_convert ();
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const ::xercesc::DOMAttr& a,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Token (a, f, c)
  {
    _xsd_DeviceIdentifierPolyType_idtypeType_convert ();
  }

  DeviceIdentifierPolyType_idtypeType::
  DeviceIdentifierPolyType_idtypeType (const ::std::string& s,
                                       const ::xercesc::DOMElement* e,
                                       ::xml_schema::Flags f,
                                       ::xml_schema::Container* c)
  : ::xml_schema::Token (s, e, f, c)
  {
    _xsd_DeviceIdentifierPolyType_idtypeType_convert ();
  }

  DeviceIdentifierPolyType_idtypeType* DeviceIdentifierPolyType_idtypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeviceIdentifierPolyType_idtypeType (*this, f, c);
  }

  DeviceIdentifierPolyType_idtypeType::Value DeviceIdentifierPolyType_idtypeType::
  _xsd_DeviceIdentifierPolyType_idtypeType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_DeviceIdentifierPolyType_idtypeType_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_DeviceIdentifierPolyType_idtypeType_indexes_,
                      _xsd_DeviceIdentifierPolyType_idtypeType_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_DeviceIdentifierPolyType_idtypeType_indexes_ + 2 || _xsd_DeviceIdentifierPolyType_idtypeType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const DeviceIdentifierPolyType_idtypeType::
  _xsd_DeviceIdentifierPolyType_idtypeType_literals_[2] =
  {
    "DeviceUID",
    "CertThumbprint"
  };

  const DeviceIdentifierPolyType_idtypeType::Value DeviceIdentifierPolyType_idtypeType::
  _xsd_DeviceIdentifierPolyType_idtypeType_indexes_[2] =
  {
    ::dcml::DeviceIdentifierPolyType_idtypeType::CertThumbprint,
    ::dcml::DeviceIdentifierPolyType_idtypeType::DeviceUID
  };
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace dcml
{
  ::std::ostream&
  operator<< (::std::ostream& o, const UUIDType& i)
  {
    o << static_cast< const ::xml_schema::Uri& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const UserTextType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    o << ::std::endl << "language: " << i.getLanguage ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RationalType_base& i)
  {
    return o << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Long, char >& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RationalType& i)
  {
    o << static_cast< const ::dcml::RationalType_base& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, TemperatureUnitsToken::Value i)
  {
    return o << TemperatureUnitsToken::_xsd_TemperatureUnitsToken_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TemperatureUnitsToken& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, VoltageUnitsToken::Value i)
  {
    return o << VoltageUnitsToken::_xsd_VoltageUnitsToken_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VoltageUnitsToken& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, CurrentUnitsToken::Value i)
  {
    return o << CurrentUnitsToken::_xsd_CurrentUnitsToken_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CurrentUnitsToken& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, CurrentModeToken::Value i)
  {
    return o << CurrentModeToken::_xsd_CurrentModeToken_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CurrentModeToken& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, TimeUnitToken::Value i)
  {
    return o << TimeUnitToken::_xsd_TimeUnitToken_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimeUnitToken& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TemperatureType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    o << ::std::endl << "units: " << i.getUnits ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VoltageType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    o << ::std::endl << "units: " << i.getUnits ();
    o << ::std::endl << "mode: " << i.getMode ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CurrentType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    o << ::std::endl << "units: " << i.getUnits ();
    o << ::std::endl << "mode: " << i.getMode ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DurationType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    o << ::std::endl << "units: " << i.getUnits ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const RateType& i)
  {
    o << static_cast< const ::dcml::RationalType& > (i);

    o << ::std::endl << "eventscope: " << i.getEventscope ();
    if (i.getEvent ())
    {
      o << ::std::endl << "event: " << *i.getEvent ();
    }

    o << ::std::endl << "period: " << i.getPeriod ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceIdentifierUnion& i)
  {
    return o << static_cast< const ::xml_schema::String& > (i);
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceIdentifierPolyType& i)
  {
    o << static_cast< const ::dcml::DeviceIdentifierUnion& > (i);

    o << ::std::endl << "idtype: " << i.getIdtype ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceIdentifierListType& i)
  {
    o << ::std::endl << "PrimaryID: " << i.getPrimaryID ();
    if (i.getSecondaryID ())
    {
      o << ::std::endl << "SecondaryID: " << *i.getSecondaryID ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceTypeType& i)
  {
    o << static_cast< const ::xml_schema::Token& > (i);

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ScopedTokenType& i)
  {
    o << static_cast< const ::xml_schema::Token& > (i);

    if (i.getScope ())
    {
      o << ::std::endl << "scope: " << *i.getScope ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const NamedParmType& i)
  {
    o << ::std::endl << "Name: " << i.getName ();
    o << ::std::endl << "Value: " << i.getValue ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ParameterListType& i)
  {
    for (ParameterListType::ParameterConstIterator
         b (i.getParameter ().begin ()), e (i.getParameter ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Parameter: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const VersionInfoListType& i)
  {
    for (VersionInfoListType::NameConstIterator
         b (i.getName ().begin ()), e (i.getName ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Name: " << *b;
    }

    for (VersionInfoListType::ValueConstIterator
         b (i.getValue ().begin ()), e (i.getValue ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Value: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceDescriptionType& i)
  {
    o << ::std::endl << "DeviceIdentifier: " << i.getDeviceIdentifier ();
    o << ::std::endl << "DeviceTypeID: " << i.getDeviceTypeID ();
    if (i.getDeviceSubsystemTypeID ())
    {
      o << ::std::endl << "DeviceSubsystemTypeID: " << *i.getDeviceSubsystemTypeID ();
    }

    if (i.getAdditionalID ())
    {
      o << ::std::endl << "AdditionalID: " << *i.getAdditionalID ();
    }

    o << ::std::endl << "DeviceSerial: " << i.getDeviceSerial ();
    if (i.getManufacturerID ())
    {
      o << ::std::endl << "ManufacturerID: " << *i.getManufacturerID ();
    }

    if (i.getManufacturerCertID ())
    {
      o << ::std::endl << "ManufacturerCertID: " << *i.getManufacturerCertID ();
    }

    if (i.getDeviceCertID ())
    {
      o << ::std::endl << "DeviceCertID: " << *i.getDeviceCertID ();
    }

    if (i.getManufacturerName ())
    {
      o << ::std::endl << "ManufacturerName: " << *i.getManufacturerName ();
    }

    if (i.getDeviceName ())
    {
      o << ::std::endl << "DeviceName: " << *i.getDeviceName ();
    }

    if (i.getModelNumber ())
    {
      o << ::std::endl << "ModelNumber: " << *i.getModelNumber ();
    }

    o << ::std::endl << "VersionInfo: " << i.getVersionInfo ();
    if (i.getDeviceComment ())
    {
      o << ::std::endl << "DeviceComment: " << *i.getDeviceComment ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, DeviceIdentifierPolyType_idtypeType::Value i)
  {
    return o << DeviceIdentifierPolyType_idtypeType::_xsd_DeviceIdentifierPolyType_idtypeType_literals_[i];
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeviceIdentifierPolyType_idtypeType& i)
  {
    return o << static_cast< const ::xml_schema::Token& > (i);
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dcml
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace dcml
{
  void
  operator<< (::xercesc::DOMElement& e, const UUIDType& i)
  {
    e << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const UUIDType& i)
  {
    a << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const UUIDType& i)
  {
    l << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const UserTextType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // language
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "language",
          e));

      a << i.getLanguage ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RationalType_base& i)
  {
    e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Long, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RationalType_base& i)
  {
    a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Long, char >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RationalType_base& i)
  {
    l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::Long, char >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const RationalType& i)
  {
    e << static_cast< const ::dcml::RationalType_base& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const RationalType& i)
  {
    a << static_cast< const ::dcml::RationalType_base& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const RationalType& i)
  {
    l << static_cast< const ::dcml::RationalType_base& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TemperatureUnitsToken& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TemperatureUnitsToken& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TemperatureUnitsToken& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const VoltageUnitsToken& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const VoltageUnitsToken& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const VoltageUnitsToken& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CurrentUnitsToken& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CurrentUnitsToken& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CurrentUnitsToken& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CurrentModeToken& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CurrentModeToken& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CurrentModeToken& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimeUnitToken& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimeUnitToken& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimeUnitToken& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TemperatureType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.getUnits ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VoltageType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.getUnits ();
    }

    // mode
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mode",
          e));

      a << i.getMode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CurrentType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.getUnits ();
    }

    // mode
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "mode",
          e));

      a << i.getMode ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DurationType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Decimal, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::decimal >& > (i);

    // units
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "units",
          e));

      a << i.getUnits ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const RateType& i)
  {
    e << static_cast< const ::dcml::RationalType& > (i);

    // eventscope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "eventscope",
          e));

      a << i.getEventscope ();
    }

    // event
    //
    if (i.getEvent ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "event",
          e));

      a << *i.getEvent ();
    }

    // period
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "period",
          e));

      a << i.getPeriod ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceIdentifierUnion& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeviceIdentifierUnion& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeviceIdentifierUnion& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceIdentifierPolyType& i)
  {
    e << static_cast< const ::dcml::DeviceIdentifierUnion& > (i);

    // idtype
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "idtype",
          e));

      a << i.getIdtype ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceIdentifierListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PrimaryID
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PrimaryID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getPrimaryID ();
    }

    // SecondaryID
    //
    if (i.getSecondaryID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SecondaryID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getSecondaryID ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceTypeType& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ScopedTokenType& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);

    // scope
    //
    if (i.getScope ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << *i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const NamedParmType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getName ();
    }

    // Value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getValue ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ParameterListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Parameter
    //
    for (ParameterListType::ParameterConstIterator
         b (i.getParameter ().begin ()), n (i.getParameter ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Parameter",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const VersionInfoListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    for (VersionInfoListType::NameConstIterator
         b (i.getName ().begin ()), n (i.getName ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *b;
    }

    // Value
    //
    for (VersionInfoListType::ValueConstIterator
         b (i.getValue ().begin ()), n (i.getValue ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Value",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceDescriptionType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // DeviceIdentifier
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceIdentifier",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getDeviceIdentifier ();
    }

    // DeviceTypeID
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceTypeID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getDeviceTypeID ();
    }

    // DeviceSubsystemTypeID
    //
    if (i.getDeviceSubsystemTypeID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceSubsystemTypeID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getDeviceSubsystemTypeID ();
    }

    // AdditionalID
    //
    if (i.getAdditionalID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AdditionalID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getAdditionalID ();
    }

    // DeviceSerial
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceSerial",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getDeviceSerial ();
    }

    // ManufacturerID
    //
    if (i.getManufacturerID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ManufacturerID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getManufacturerID ();
    }

    // ManufacturerCertID
    //
    if (i.getManufacturerCertID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ManufacturerCertID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getManufacturerCertID ();
    }

    // DeviceCertID
    //
    if (i.getDeviceCertID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceCertID",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getDeviceCertID ();
    }

    // ManufacturerName
    //
    if (i.getManufacturerName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ManufacturerName",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getManufacturerName ();
    }

    // DeviceName
    //
    if (i.getDeviceName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceName",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getDeviceName ();
    }

    // ModelNumber
    //
    if (i.getModelNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ModelNumber",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getModelNumber ();
    }

    // VersionInfo
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "VersionInfo",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << i.getVersionInfo ();
    }

    // DeviceComment
    //
    if (i.getDeviceComment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeviceComment",
          "http://www.smpte-ra.org/schemas/433/2008/dcmlTypes/",
          e));

      s << *i.getDeviceComment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeviceIdentifierPolyType_idtypeType& i)
  {
    e << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeviceIdentifierPolyType_idtypeType& i)
  {
    a << static_cast< const ::xml_schema::Token& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeviceIdentifierPolyType_idtypeType& i)
  {
    l << static_cast< const ::xml_schema::Token& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

