// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "IMF_DeliverySchema.h"

namespace dsl
{
  // DeliverableType
  // 

  const DeliverableType::IdType& DeliverableType::
  getId () const
  {
    return this->Id_.get ();
  }

  DeliverableType::IdType& DeliverableType::
  getId ()
  {
    return this->Id_.get ();
  }

  void DeliverableType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void DeliverableType::
  setId (::std::auto_ptr< IdType > x)
  {
    this->Id_.set (x);
  }

  const DeliverableType::LabelType& DeliverableType::
  getLabel () const
  {
    return this->Label_.get ();
  }

  DeliverableType::LabelType& DeliverableType::
  getLabel ()
  {
    return this->Label_.get ();
  }

  void DeliverableType::
  setLabel (const LabelType& x)
  {
    this->Label_.set (x);
  }

  void DeliverableType::
  setLabel (::std::auto_ptr< LabelType > x)
  {
    this->Label_.set (x);
  }

  const DeliverableType::CompositionPlaylistConstraintsType& DeliverableType::
  getCompositionPlaylistConstraints () const
  {
    return this->CompositionPlaylistConstraints_.get ();
  }

  DeliverableType::CompositionPlaylistConstraintsType& DeliverableType::
  getCompositionPlaylistConstraints ()
  {
    return this->CompositionPlaylistConstraints_.get ();
  }

  void DeliverableType::
  setCompositionPlaylistConstraints (const CompositionPlaylistConstraintsType& x)
  {
    this->CompositionPlaylistConstraints_.set (x);
  }

  void DeliverableType::
  setCompositionPlaylistConstraints (::std::auto_ptr< CompositionPlaylistConstraintsType > x)
  {
    this->CompositionPlaylistConstraints_.set (x);
  }


  // GenericVirtualTrackType
  // 

  const GenericVirtualTrackType::EssenceEncodingConstraintListOptional& GenericVirtualTrackType::
  getEssenceEncodingConstraintList () const
  {
    return this->EssenceEncodingConstraintList_;
  }

  GenericVirtualTrackType::EssenceEncodingConstraintListOptional& GenericVirtualTrackType::
  getEssenceEncodingConstraintList ()
  {
    return this->EssenceEncodingConstraintList_;
  }

  void GenericVirtualTrackType::
  setEssenceEncodingConstraintList (const EssenceEncodingConstraintListType& x)
  {
    this->EssenceEncodingConstraintList_.set (x);
  }

  void GenericVirtualTrackType::
  setEssenceEncodingConstraintList (const EssenceEncodingConstraintListOptional& x)
  {
    this->EssenceEncodingConstraintList_ = x;
  }

  void GenericVirtualTrackType::
  setEssenceEncodingConstraintList (::std::auto_ptr< EssenceEncodingConstraintListType > x)
  {
    this->EssenceEncodingConstraintList_.set (x);
  }

  const GenericVirtualTrackType::TimelineComplexitySequence& GenericVirtualTrackType::
  getTimelineComplexity () const
  {
    return this->TimelineComplexity_;
  }

  GenericVirtualTrackType::TimelineComplexitySequence& GenericVirtualTrackType::
  getTimelineComplexity ()
  {
    return this->TimelineComplexity_;
  }

  void GenericVirtualTrackType::
  setTimelineComplexity (const TimelineComplexitySequence& s)
  {
    this->TimelineComplexity_ = s;
  }

  const GenericVirtualTrackType::ReferenceCardinalityOptional& GenericVirtualTrackType::
  getReferenceCardinality () const
  {
    return this->ReferenceCardinality_;
  }

  GenericVirtualTrackType::ReferenceCardinalityOptional& GenericVirtualTrackType::
  getReferenceCardinality ()
  {
    return this->ReferenceCardinality_;
  }

  void GenericVirtualTrackType::
  setReferenceCardinality (const ReferenceCardinalityType& x)
  {
    this->ReferenceCardinality_.set (x);
  }

  void GenericVirtualTrackType::
  setReferenceCardinality (const ReferenceCardinalityOptional& x)
  {
    this->ReferenceCardinality_ = x;
  }

  void GenericVirtualTrackType::
  setReferenceCardinality (::std::auto_ptr< ReferenceCardinalityType > x)
  {
    this->ReferenceCardinality_.set (x);
  }

  const GenericVirtualTrackType::NamespaceOptional& GenericVirtualTrackType::
  getNamespace () const
  {
    return this->namespace__;
  }

  GenericVirtualTrackType::NamespaceOptional& GenericVirtualTrackType::
  getNamespace ()
  {
    return this->namespace__;
  }

  void GenericVirtualTrackType::
  setNamespace (const NamespaceType& x)
  {
    this->namespace__.set (x);
  }

  void GenericVirtualTrackType::
  setNamespace (const NamespaceOptional& x)
  {
    this->namespace__ = x;
  }

  void GenericVirtualTrackType::
  setNamespace (::std::auto_ptr< NamespaceType > x)
  {
    this->namespace__.set (x);
  }


  // AudioVirtualTrackType
  // 

  const AudioVirtualTrackType::EssenceEncodingType& AudioVirtualTrackType::
  getEssenceEncoding () const
  {
    return this->EssenceEncoding_.get ();
  }

  AudioVirtualTrackType::EssenceEncodingType& AudioVirtualTrackType::
  getEssenceEncoding ()
  {
    return this->EssenceEncoding_.get ();
  }

  void AudioVirtualTrackType::
  setEssenceEncoding (const EssenceEncodingType& x)
  {
    this->EssenceEncoding_.set (x);
  }

  void AudioVirtualTrackType::
  setEssenceEncoding (::std::auto_ptr< EssenceEncodingType > x)
  {
    this->EssenceEncoding_.set (x);
  }

  const AudioVirtualTrackType::SoundfieldGroupConfigurationOptional& AudioVirtualTrackType::
  getSoundfieldGroupConfiguration () const
  {
    return this->SoundfieldGroupConfiguration_;
  }

  AudioVirtualTrackType::SoundfieldGroupConfigurationOptional& AudioVirtualTrackType::
  getSoundfieldGroupConfiguration ()
  {
    return this->SoundfieldGroupConfiguration_;
  }

  void AudioVirtualTrackType::
  setSoundfieldGroupConfiguration (const SoundfieldGroupConfigurationType& x)
  {
    this->SoundfieldGroupConfiguration_.set (x);
  }

  void AudioVirtualTrackType::
  setSoundfieldGroupConfiguration (const SoundfieldGroupConfigurationOptional& x)
  {
    this->SoundfieldGroupConfiguration_ = x;
  }

  void AudioVirtualTrackType::
  setSoundfieldGroupConfiguration (::std::auto_ptr< SoundfieldGroupConfigurationType > x)
  {
    this->SoundfieldGroupConfiguration_.set (x);
  }

  const AudioVirtualTrackType::AudioChannelMappingOptional& AudioVirtualTrackType::
  getAudioChannelMapping () const
  {
    return this->AudioChannelMapping_;
  }

  AudioVirtualTrackType::AudioChannelMappingOptional& AudioVirtualTrackType::
  getAudioChannelMapping ()
  {
    return this->AudioChannelMapping_;
  }

  void AudioVirtualTrackType::
  setAudioChannelMapping (const AudioChannelMappingType& x)
  {
    this->AudioChannelMapping_.set (x);
  }

  void AudioVirtualTrackType::
  setAudioChannelMapping (const AudioChannelMappingOptional& x)
  {
    this->AudioChannelMapping_ = x;
  }

  void AudioVirtualTrackType::
  setAudioChannelMapping (::std::auto_ptr< AudioChannelMappingType > x)
  {
    this->AudioChannelMapping_.set (x);
  }

  const AudioVirtualTrackType::SampleRateListOptional& AudioVirtualTrackType::
  getSampleRateList () const
  {
    return this->SampleRateList_;
  }

  AudioVirtualTrackType::SampleRateListOptional& AudioVirtualTrackType::
  getSampleRateList ()
  {
    return this->SampleRateList_;
  }

  void AudioVirtualTrackType::
  setSampleRateList (const SampleRateListType& x)
  {
    this->SampleRateList_.set (x);
  }

  void AudioVirtualTrackType::
  setSampleRateList (const SampleRateListOptional& x)
  {
    this->SampleRateList_ = x;
  }

  void AudioVirtualTrackType::
  setSampleRateList (::std::auto_ptr< SampleRateListType > x)
  {
    this->SampleRateList_.set (x);
  }


  // ImageVirtualTrackType
  // 

  const ImageVirtualTrackType::EssenceEncodingType& ImageVirtualTrackType::
  getEssenceEncoding () const
  {
    return this->EssenceEncoding_.get ();
  }

  ImageVirtualTrackType::EssenceEncodingType& ImageVirtualTrackType::
  getEssenceEncoding ()
  {
    return this->EssenceEncoding_.get ();
  }

  void ImageVirtualTrackType::
  setEssenceEncoding (const EssenceEncodingType& x)
  {
    this->EssenceEncoding_.set (x);
  }

  void ImageVirtualTrackType::
  setEssenceEncoding (::std::auto_ptr< EssenceEncodingType > x)
  {
    this->EssenceEncoding_.set (x);
  }

  const ImageVirtualTrackType::ColorimetryOptional& ImageVirtualTrackType::
  getColorimetry () const
  {
    return this->Colorimetry_;
  }

  ImageVirtualTrackType::ColorimetryOptional& ImageVirtualTrackType::
  getColorimetry ()
  {
    return this->Colorimetry_;
  }

  void ImageVirtualTrackType::
  setColorimetry (const ColorimetryType& x)
  {
    this->Colorimetry_.set (x);
  }

  void ImageVirtualTrackType::
  setColorimetry (const ColorimetryOptional& x)
  {
    this->Colorimetry_ = x;
  }

  void ImageVirtualTrackType::
  setColorimetry (::std::auto_ptr< ColorimetryType > x)
  {
    this->Colorimetry_.set (x);
  }

  const ImageVirtualTrackType::SamplingOptional& ImageVirtualTrackType::
  getSampling () const
  {
    return this->Sampling_;
  }

  ImageVirtualTrackType::SamplingOptional& ImageVirtualTrackType::
  getSampling ()
  {
    return this->Sampling_;
  }

  void ImageVirtualTrackType::
  setSampling (const SamplingType& x)
  {
    this->Sampling_.set (x);
  }

  void ImageVirtualTrackType::
  setSampling (const SamplingOptional& x)
  {
    this->Sampling_ = x;
  }

  void ImageVirtualTrackType::
  setSampling (::std::auto_ptr< SamplingType > x)
  {
    this->Sampling_.set (x);
  }

  const ImageVirtualTrackType::QuantizationOptional& ImageVirtualTrackType::
  getQuantization () const
  {
    return this->Quantization_;
  }

  ImageVirtualTrackType::QuantizationOptional& ImageVirtualTrackType::
  getQuantization ()
  {
    return this->Quantization_;
  }

  void ImageVirtualTrackType::
  setQuantization (const QuantizationType& x)
  {
    this->Quantization_.set (x);
  }

  void ImageVirtualTrackType::
  setQuantization (const QuantizationOptional& x)
  {
    this->Quantization_ = x;
  }

  void ImageVirtualTrackType::
  setQuantization (::std::auto_ptr< QuantizationType > x)
  {
    this->Quantization_.set (x);
  }

  const ImageVirtualTrackType::FrameStructureOptional& ImageVirtualTrackType::
  getFrameStructure () const
  {
    return this->FrameStructure_;
  }

  ImageVirtualTrackType::FrameStructureOptional& ImageVirtualTrackType::
  getFrameStructure ()
  {
    return this->FrameStructure_;
  }

  void ImageVirtualTrackType::
  setFrameStructure (const FrameStructureType& x)
  {
    this->FrameStructure_.set (x);
  }

  void ImageVirtualTrackType::
  setFrameStructure (const FrameStructureOptional& x)
  {
    this->FrameStructure_ = x;
  }

  void ImageVirtualTrackType::
  setFrameStructure (::std::auto_ptr< FrameStructureType > x)
  {
    this->FrameStructure_.set (x);
  }

  const ImageVirtualTrackType::StereoscopyOptional& ImageVirtualTrackType::
  getStereoscopy () const
  {
    return this->Stereoscopy_;
  }

  ImageVirtualTrackType::StereoscopyOptional& ImageVirtualTrackType::
  getStereoscopy ()
  {
    return this->Stereoscopy_;
  }

  void ImageVirtualTrackType::
  setStereoscopy (const StereoscopyType& x)
  {
    this->Stereoscopy_.set (x);
  }

  void ImageVirtualTrackType::
  setStereoscopy (const StereoscopyOptional& x)
  {
    this->Stereoscopy_ = x;
  }

  void ImageVirtualTrackType::
  setStereoscopy (::std::auto_ptr< StereoscopyType > x)
  {
    this->Stereoscopy_.set (x);
  }

  const ImageVirtualTrackType::ColorComponentsOptional& ImageVirtualTrackType::
  getColorComponents () const
  {
    return this->ColorComponents_;
  }

  ImageVirtualTrackType::ColorComponentsOptional& ImageVirtualTrackType::
  getColorComponents ()
  {
    return this->ColorComponents_;
  }

  void ImageVirtualTrackType::
  setColorComponents (const ColorComponentsType& x)
  {
    this->ColorComponents_.set (x);
  }

  void ImageVirtualTrackType::
  setColorComponents (const ColorComponentsOptional& x)
  {
    this->ColorComponents_ = x;
  }

  void ImageVirtualTrackType::
  setColorComponents (::std::auto_ptr< ColorComponentsType > x)
  {
    this->ColorComponents_.set (x);
  }

  const ImageVirtualTrackType::PixelBitDepthListOptional& ImageVirtualTrackType::
  getPixelBitDepthList () const
  {
    return this->PixelBitDepthList_;
  }

  ImageVirtualTrackType::PixelBitDepthListOptional& ImageVirtualTrackType::
  getPixelBitDepthList ()
  {
    return this->PixelBitDepthList_;
  }

  void ImageVirtualTrackType::
  setPixelBitDepthList (const PixelBitDepthListType& x)
  {
    this->PixelBitDepthList_.set (x);
  }

  void ImageVirtualTrackType::
  setPixelBitDepthList (const PixelBitDepthListOptional& x)
  {
    this->PixelBitDepthList_ = x;
  }

  void ImageVirtualTrackType::
  setPixelBitDepthList (::std::auto_ptr< PixelBitDepthListType > x)
  {
    this->PixelBitDepthList_.set (x);
  }

  const ImageVirtualTrackType::ImageFrameWidthListOptional& ImageVirtualTrackType::
  getImageFrameWidthList () const
  {
    return this->ImageFrameWidthList_;
  }

  ImageVirtualTrackType::ImageFrameWidthListOptional& ImageVirtualTrackType::
  getImageFrameWidthList ()
  {
    return this->ImageFrameWidthList_;
  }

  void ImageVirtualTrackType::
  setImageFrameWidthList (const ImageFrameWidthListType& x)
  {
    this->ImageFrameWidthList_.set (x);
  }

  void ImageVirtualTrackType::
  setImageFrameWidthList (const ImageFrameWidthListOptional& x)
  {
    this->ImageFrameWidthList_ = x;
  }

  void ImageVirtualTrackType::
  setImageFrameWidthList (::std::auto_ptr< ImageFrameWidthListType > x)
  {
    this->ImageFrameWidthList_.set (x);
  }

  const ImageVirtualTrackType::ImageFrameHeightListOptional& ImageVirtualTrackType::
  getImageFrameHeightList () const
  {
    return this->ImageFrameHeightList_;
  }

  ImageVirtualTrackType::ImageFrameHeightListOptional& ImageVirtualTrackType::
  getImageFrameHeightList ()
  {
    return this->ImageFrameHeightList_;
  }

  void ImageVirtualTrackType::
  setImageFrameHeightList (const ImageFrameHeightListType& x)
  {
    this->ImageFrameHeightList_.set (x);
  }

  void ImageVirtualTrackType::
  setImageFrameHeightList (const ImageFrameHeightListOptional& x)
  {
    this->ImageFrameHeightList_ = x;
  }

  void ImageVirtualTrackType::
  setImageFrameHeightList (::std::auto_ptr< ImageFrameHeightListType > x)
  {
    this->ImageFrameHeightList_.set (x);
  }

  const ImageVirtualTrackType::FrameRateListOptional& ImageVirtualTrackType::
  getFrameRateList () const
  {
    return this->FrameRateList_;
  }

  ImageVirtualTrackType::FrameRateListOptional& ImageVirtualTrackType::
  getFrameRateList ()
  {
    return this->FrameRateList_;
  }

  void ImageVirtualTrackType::
  setFrameRateList (const FrameRateListType& x)
  {
    this->FrameRateList_.set (x);
  }

  void ImageVirtualTrackType::
  setFrameRateList (const FrameRateListOptional& x)
  {
    this->FrameRateList_ = x;
  }

  void ImageVirtualTrackType::
  setFrameRateList (::std::auto_ptr< FrameRateListType > x)
  {
    this->FrameRateList_.set (x);
  }


  // CardinalityType
  // 

  const CardinalityType::MinItemType& CardinalityType::
  getMinItem () const
  {
    return this->MinItem_.get ();
  }

  CardinalityType::MinItemType& CardinalityType::
  getMinItem ()
  {
    return this->MinItem_.get ();
  }

  void CardinalityType::
  setMinItem (const MinItemType& x)
  {
    this->MinItem_.set (x);
  }

  void CardinalityType::
  setMinItem (::std::auto_ptr< MinItemType > x)
  {
    this->MinItem_.set (x);
  }

  const CardinalityType::MaxItemType& CardinalityType::
  getMaxItem () const
  {
    return this->MaxItem_.get ();
  }

  CardinalityType::MaxItemType& CardinalityType::
  getMaxItem ()
  {
    return this->MaxItem_.get ();
  }

  void CardinalityType::
  setMaxItem (const MaxItemType& x)
  {
    this->MaxItem_.set (x);
  }

  void CardinalityType::
  setMaxItem (::std::auto_ptr< MaxItemType > x)
  {
    this->MaxItem_.set (x);
  }


  // MarkerVirtualTrackType
  // 

  const MarkerVirtualTrackType::MarkerListOptional& MarkerVirtualTrackType::
  getMarkerList () const
  {
    return this->MarkerList_;
  }

  MarkerVirtualTrackType::MarkerListOptional& MarkerVirtualTrackType::
  getMarkerList ()
  {
    return this->MarkerList_;
  }

  void MarkerVirtualTrackType::
  setMarkerList (const MarkerListType& x)
  {
    this->MarkerList_.set (x);
  }

  void MarkerVirtualTrackType::
  setMarkerList (const MarkerListOptional& x)
  {
    this->MarkerList_ = x;
  }

  void MarkerVirtualTrackType::
  setMarkerList (::std::auto_ptr< MarkerListType > x)
  {
    this->MarkerList_.set (x);
  }


  // TimedTextVirtualTrackType
  // 

  const TimedTextVirtualTrackType::TimedTextSequenceTypeType& TimedTextVirtualTrackType::
  getTimedTextSequenceType () const
  {
    return this->TimedTextSequenceType_.get ();
  }

  TimedTextVirtualTrackType::TimedTextSequenceTypeType& TimedTextVirtualTrackType::
  getTimedTextSequenceType ()
  {
    return this->TimedTextSequenceType_.get ();
  }

  void TimedTextVirtualTrackType::
  setTimedTextSequenceType (const TimedTextSequenceTypeType& x)
  {
    this->TimedTextSequenceType_.set (x);
  }

  void TimedTextVirtualTrackType::
  setTimedTextSequenceType (::std::auto_ptr< TimedTextSequenceTypeType > x)
  {
    this->TimedTextSequenceType_.set (x);
  }

  const TimedTextVirtualTrackType::NamespaceURIOptional& TimedTextVirtualTrackType::
  getNamespaceURI () const
  {
    return this->NamespaceURI_;
  }

  TimedTextVirtualTrackType::NamespaceURIOptional& TimedTextVirtualTrackType::
  getNamespaceURI ()
  {
    return this->NamespaceURI_;
  }

  void TimedTextVirtualTrackType::
  setNamespaceURI (const NamespaceURIType& x)
  {
    this->NamespaceURI_.set (x);
  }

  void TimedTextVirtualTrackType::
  setNamespaceURI (const NamespaceURIOptional& x)
  {
    this->NamespaceURI_ = x;
  }

  void TimedTextVirtualTrackType::
  setNamespaceURI (::std::auto_ptr< NamespaceURIType > x)
  {
    this->NamespaceURI_.set (x);
  }


  // DeliverySpecificationList
  // 

  const DeliverySpecificationList::IdType& DeliverySpecificationList::
  getId () const
  {
    return this->Id_.get ();
  }

  DeliverySpecificationList::IdType& DeliverySpecificationList::
  getId ()
  {
    return this->Id_.get ();
  }

  void DeliverySpecificationList::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void DeliverySpecificationList::
  setId (::std::auto_ptr< IdType > x)
  {
    this->Id_.set (x);
  }

  const DeliverySpecificationList::AnnotationTextOptional& DeliverySpecificationList::
  getAnnotationText () const
  {
    return this->AnnotationText_;
  }

  DeliverySpecificationList::AnnotationTextOptional& DeliverySpecificationList::
  getAnnotationText ()
  {
    return this->AnnotationText_;
  }

  void DeliverySpecificationList::
  setAnnotationText (const AnnotationTextType& x)
  {
    this->AnnotationText_.set (x);
  }

  void DeliverySpecificationList::
  setAnnotationText (const AnnotationTextOptional& x)
  {
    this->AnnotationText_ = x;
  }

  void DeliverySpecificationList::
  setAnnotationText (::std::auto_ptr< AnnotationTextType > x)
  {
    this->AnnotationText_.set (x);
  }

  const DeliverySpecificationList::IssueDateType& DeliverySpecificationList::
  getIssueDate () const
  {
    return this->IssueDate_.get ();
  }

  DeliverySpecificationList::IssueDateType& DeliverySpecificationList::
  getIssueDate ()
  {
    return this->IssueDate_.get ();
  }

  void DeliverySpecificationList::
  setIssueDate (const IssueDateType& x)
  {
    this->IssueDate_.set (x);
  }

  void DeliverySpecificationList::
  setIssueDate (::std::auto_ptr< IssueDateType > x)
  {
    this->IssueDate_.set (x);
  }

  const DeliverySpecificationList::IssuerOptional& DeliverySpecificationList::
  getIssuer () const
  {
    return this->Issuer_;
  }

  DeliverySpecificationList::IssuerOptional& DeliverySpecificationList::
  getIssuer ()
  {
    return this->Issuer_;
  }

  void DeliverySpecificationList::
  setIssuer (const IssuerType& x)
  {
    this->Issuer_.set (x);
  }

  void DeliverySpecificationList::
  setIssuer (const IssuerOptional& x)
  {
    this->Issuer_ = x;
  }

  void DeliverySpecificationList::
  setIssuer (::std::auto_ptr< IssuerType > x)
  {
    this->Issuer_.set (x);
  }

  const DeliverySpecificationList::CreatorOptional& DeliverySpecificationList::
  getCreator () const
  {
    return this->Creator_;
  }

  DeliverySpecificationList::CreatorOptional& DeliverySpecificationList::
  getCreator ()
  {
    return this->Creator_;
  }

  void DeliverySpecificationList::
  setCreator (const CreatorType& x)
  {
    this->Creator_.set (x);
  }

  void DeliverySpecificationList::
  setCreator (const CreatorOptional& x)
  {
    this->Creator_ = x;
  }

  void DeliverySpecificationList::
  setCreator (::std::auto_ptr< CreatorType > x)
  {
    this->Creator_.set (x);
  }

  const DeliverySpecificationList::DeliverableListType& DeliverySpecificationList::
  getDeliverableList () const
  {
    return this->DeliverableList_.get ();
  }

  DeliverySpecificationList::DeliverableListType& DeliverySpecificationList::
  getDeliverableList ()
  {
    return this->DeliverableList_.get ();
  }

  void DeliverySpecificationList::
  setDeliverableList (const DeliverableListType& x)
  {
    this->DeliverableList_.set (x);
  }

  void DeliverySpecificationList::
  setDeliverableList (::std::auto_ptr< DeliverableListType > x)
  {
    this->DeliverableList_.set (x);
  }


  // DeliverableType_LabelType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType::OwnerIdType& DeliverableType_CompositionPlaylistConstraintsType::
  getOwnerId () const
  {
    return this->OwnerId_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType::OwnerIdType& DeliverableType_CompositionPlaylistConstraintsType::
  getOwnerId ()
  {
    return this->OwnerId_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setOwnerId (const OwnerIdType& x)
  {
    this->OwnerId_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setOwnerId (::std::auto_ptr< OwnerIdType > x)
  {
    this->OwnerId_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationListOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentificationList () const
  {
    return this->ApplicationIdentificationList_;
  }

  DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationListOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentificationList ()
  {
    return this->ApplicationIdentificationList_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (const ApplicationIdentificationListType& x)
  {
    this->ApplicationIdentificationList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (const ApplicationIdentificationListOptional& x)
  {
    this->ApplicationIdentificationList_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentificationList (::std::auto_ptr< ApplicationIdentificationListType > x)
  {
    this->ApplicationIdentificationList_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentification () const
  {
    return this->ApplicationIdentification_;
  }

  DeliverableType_CompositionPlaylistConstraintsType::ApplicationIdentificationOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getApplicationIdentification ()
  {
    return this->ApplicationIdentification_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (const ApplicationIdentificationType& x)
  {
    this->ApplicationIdentification_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (const ApplicationIdentificationOptional& x)
  {
    this->ApplicationIdentification_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setApplicationIdentification (::std::auto_ptr< ApplicationIdentificationType > x)
  {
    this->ApplicationIdentification_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::SegmentCardinalityOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getSegmentCardinality () const
  {
    return this->SegmentCardinality_;
  }

  DeliverableType_CompositionPlaylistConstraintsType::SegmentCardinalityOptional& DeliverableType_CompositionPlaylistConstraintsType::
  getSegmentCardinality ()
  {
    return this->SegmentCardinality_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setSegmentCardinality (const SegmentCardinalityType& x)
  {
    this->SegmentCardinality_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setSegmentCardinality (const SegmentCardinalityOptional& x)
  {
    this->SegmentCardinality_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setSegmentCardinality (::std::auto_ptr< SegmentCardinalityType > x)
  {
    this->SegmentCardinality_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType::VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType::
  getVirtualTrackList () const
  {
    return this->VirtualTrackList_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType::VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType::
  getVirtualTrackList ()
  {
    return this->VirtualTrackList_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setVirtualTrackList (const VirtualTrackListType& x)
  {
    this->VirtualTrackList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  setVirtualTrackList (::std::auto_ptr< VirtualTrackListType > x)
  {
    this->VirtualTrackList_.set (x);
  }


  // GenericVirtualTrackType_EssenceEncodingConstraintListType
  // 

  const GenericVirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintSequence& GenericVirtualTrackType_EssenceEncodingConstraintListType::
  getEssenceEncodingConstraint () const
  {
    return this->EssenceEncodingConstraint_;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintSequence& GenericVirtualTrackType_EssenceEncodingConstraintListType::
  getEssenceEncodingConstraint ()
  {
    return this->EssenceEncodingConstraint_;
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType::
  setEssenceEncodingConstraint (const EssenceEncodingConstraintSequence& s)
  {
    this->EssenceEncodingConstraint_ = s;
  }

  const GenericVirtualTrackType_EssenceEncodingConstraintListType::ScopeType& GenericVirtualTrackType_EssenceEncodingConstraintListType::
  getScope () const
  {
    return this->scope_.get ();
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType::ScopeType& GenericVirtualTrackType_EssenceEncodingConstraintListType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType::
  setScope (::std::auto_ptr< ScopeType > x)
  {
    this->scope_.set (x);
  }


  // GenericVirtualTrackType_TimelineComplexityType
  // 

  const GenericVirtualTrackType_TimelineComplexityType::SequenceCardinalityOptional& GenericVirtualTrackType_TimelineComplexityType::
  getSequenceCardinality () const
  {
    return this->SequenceCardinality_;
  }

  GenericVirtualTrackType_TimelineComplexityType::SequenceCardinalityOptional& GenericVirtualTrackType_TimelineComplexityType::
  getSequenceCardinality ()
  {
    return this->SequenceCardinality_;
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (const SequenceCardinalityType& x)
  {
    this->SequenceCardinality_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (const SequenceCardinalityOptional& x)
  {
    this->SequenceCardinality_ = x;
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setSequenceCardinality (::std::auto_ptr< SequenceCardinalityType > x)
  {
    this->SequenceCardinality_.set (x);
  }

  const GenericVirtualTrackType_TimelineComplexityType::ResourceCardinalityOptional& GenericVirtualTrackType_TimelineComplexityType::
  getResourceCardinality () const
  {
    return this->ResourceCardinality_;
  }

  GenericVirtualTrackType_TimelineComplexityType::ResourceCardinalityOptional& GenericVirtualTrackType_TimelineComplexityType::
  getResourceCardinality ()
  {
    return this->ResourceCardinality_;
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setResourceCardinality (const ResourceCardinalityType& x)
  {
    this->ResourceCardinality_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setResourceCardinality (const ResourceCardinalityOptional& x)
  {
    this->ResourceCardinality_ = x;
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setResourceCardinality (::std::auto_ptr< ResourceCardinalityType > x)
  {
    this->ResourceCardinality_.set (x);
  }

  const GenericVirtualTrackType_TimelineComplexityType::SequenceType& GenericVirtualTrackType_TimelineComplexityType::
  getSequence () const
  {
    return this->Sequence_.get ();
  }

  GenericVirtualTrackType_TimelineComplexityType::SequenceType& GenericVirtualTrackType_TimelineComplexityType::
  getSequence ()
  {
    return this->Sequence_.get ();
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setSequence (const SequenceType& x)
  {
    this->Sequence_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setSequence (::std::auto_ptr< SequenceType > x)
  {
    this->Sequence_.set (x);
  }

  const GenericVirtualTrackType_TimelineComplexityType::TypeType& GenericVirtualTrackType_TimelineComplexityType::
  getType () const
  {
    return this->type_.get ();
  }

  GenericVirtualTrackType_TimelineComplexityType::TypeType& GenericVirtualTrackType_TimelineComplexityType::
  getType ()
  {
    return this->type_.get ();
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setType (const TypeType& x)
  {
    this->type_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  setType (::std::auto_ptr< TypeType > x)
  {
    this->type_.set (x);
  }


  // GenericVirtualTrackType_ReferenceCardinalityType
  // 

  const GenericVirtualTrackType_ReferenceCardinalityType::SequenceType& GenericVirtualTrackType_ReferenceCardinalityType::
  getSequence () const
  {
    return this->Sequence_.get ();
  }

  GenericVirtualTrackType_ReferenceCardinalityType::SequenceType& GenericVirtualTrackType_ReferenceCardinalityType::
  getSequence ()
  {
    return this->Sequence_.get ();
  }

  void GenericVirtualTrackType_ReferenceCardinalityType::
  setSequence (const SequenceType& x)
  {
    this->Sequence_.set (x);
  }

  void GenericVirtualTrackType_ReferenceCardinalityType::
  setSequence (::std::auto_ptr< SequenceType > x)
  {
    this->Sequence_.set (x);
  }


  // GenericVirtualTrackType_namespaceType
  // 


  // AudioVirtualTrackType_EssenceEncodingType
  // 


  // AudioVirtualTrackType_SoundfieldGroupConfigurationType
  // 

  const AudioVirtualTrackType_SoundfieldGroupConfigurationType::MCATagSymbolType& AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  getMCATagSymbol () const
  {
    return this->MCATagSymbol_.get ();
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType::MCATagSymbolType& AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  getMCATagSymbol ()
  {
    return this->MCATagSymbol_.get ();
  }

  void AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  setMCATagSymbol (const MCATagSymbolType& x)
  {
    this->MCATagSymbol_.set (x);
  }

  void AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  setMCATagSymbol (::std::auto_ptr< MCATagSymbolType > x)
  {
    this->MCATagSymbol_.set (x);
  }


  // AudioVirtualTrackType_AudioChannelMappingType
  // 

  const AudioVirtualTrackType_AudioChannelMappingType::AudioChannelSequence& AudioVirtualTrackType_AudioChannelMappingType::
  getAudioChannel () const
  {
    return this->AudioChannel_;
  }

  AudioVirtualTrackType_AudioChannelMappingType::AudioChannelSequence& AudioVirtualTrackType_AudioChannelMappingType::
  getAudioChannel ()
  {
    return this->AudioChannel_;
  }

  void AudioVirtualTrackType_AudioChannelMappingType::
  setAudioChannel (const AudioChannelSequence& s)
  {
    this->AudioChannel_ = s;
  }


  // AudioVirtualTrackType_SampleRateListType
  // 

  const AudioVirtualTrackType_SampleRateListType::SampleRateSequence& AudioVirtualTrackType_SampleRateListType::
  getSampleRate () const
  {
    return this->SampleRate_;
  }

  AudioVirtualTrackType_SampleRateListType::SampleRateSequence& AudioVirtualTrackType_SampleRateListType::
  getSampleRate ()
  {
    return this->SampleRate_;
  }

  void AudioVirtualTrackType_SampleRateListType::
  setSampleRate (const SampleRateSequence& s)
  {
    this->SampleRate_ = s;
  }


  // ImageVirtualTrackType_EssenceEncodingType
  // 


  // ImageVirtualTrackType_ColorimetryType
  // 


  // ImageVirtualTrackType_SamplingType
  // 


  // ImageVirtualTrackType_QuantizationType
  // 


  // ImageVirtualTrackType_FrameStructureType
  // 


  // ImageVirtualTrackType_StereoscopyType
  // 


  // ImageVirtualTrackType_ColorComponentsType
  // 


  // ImageVirtualTrackType_PixelBitDepthListType
  // 

  const ImageVirtualTrackType_PixelBitDepthListType::PixelBitDepthSequence& ImageVirtualTrackType_PixelBitDepthListType::
  getPixelBitDepth () const
  {
    return this->PixelBitDepth_;
  }

  ImageVirtualTrackType_PixelBitDepthListType::PixelBitDepthSequence& ImageVirtualTrackType_PixelBitDepthListType::
  getPixelBitDepth ()
  {
    return this->PixelBitDepth_;
  }

  void ImageVirtualTrackType_PixelBitDepthListType::
  setPixelBitDepth (const PixelBitDepthSequence& s)
  {
    this->PixelBitDepth_ = s;
  }


  // ImageVirtualTrackType_ImageFrameWidthListType
  // 

  const ImageVirtualTrackType_ImageFrameWidthListType::ImageFrameWidthSequence& ImageVirtualTrackType_ImageFrameWidthListType::
  getImageFrameWidth () const
  {
    return this->ImageFrameWidth_;
  }

  ImageVirtualTrackType_ImageFrameWidthListType::ImageFrameWidthSequence& ImageVirtualTrackType_ImageFrameWidthListType::
  getImageFrameWidth ()
  {
    return this->ImageFrameWidth_;
  }

  void ImageVirtualTrackType_ImageFrameWidthListType::
  setImageFrameWidth (const ImageFrameWidthSequence& s)
  {
    this->ImageFrameWidth_ = s;
  }


  // ImageVirtualTrackType_ImageFrameHeightListType
  // 

  const ImageVirtualTrackType_ImageFrameHeightListType::ImageFrameHeightSequence& ImageVirtualTrackType_ImageFrameHeightListType::
  getImageFrameHeight () const
  {
    return this->ImageFrameHeight_;
  }

  ImageVirtualTrackType_ImageFrameHeightListType::ImageFrameHeightSequence& ImageVirtualTrackType_ImageFrameHeightListType::
  getImageFrameHeight ()
  {
    return this->ImageFrameHeight_;
  }

  void ImageVirtualTrackType_ImageFrameHeightListType::
  setImageFrameHeight (const ImageFrameHeightSequence& s)
  {
    this->ImageFrameHeight_ = s;
  }


  // ImageVirtualTrackType_FrameRateListType
  // 

  const ImageVirtualTrackType_FrameRateListType::FrameRateSequence& ImageVirtualTrackType_FrameRateListType::
  getFrameRate () const
  {
    return this->FrameRate_;
  }

  ImageVirtualTrackType_FrameRateListType::FrameRateSequence& ImageVirtualTrackType_FrameRateListType::
  getFrameRate ()
  {
    return this->FrameRate_;
  }

  void ImageVirtualTrackType_FrameRateListType::
  setFrameRate (const FrameRateSequence& s)
  {
    this->FrameRate_ = s;
  }


  // CardinalityType_MinItemType
  // 


  // CardinalityType_MaxItemType
  // 


  // MarkerVirtualTrackType_MarkerListType
  // 

  const MarkerVirtualTrackType_MarkerListType::MarkerSequence& MarkerVirtualTrackType_MarkerListType::
  getMarker () const
  {
    return this->Marker_;
  }

  MarkerVirtualTrackType_MarkerListType::MarkerSequence& MarkerVirtualTrackType_MarkerListType::
  getMarker ()
  {
    return this->Marker_;
  }

  void MarkerVirtualTrackType_MarkerListType::
  setMarker (const MarkerSequence& s)
  {
    this->Marker_ = s;
  }


  // TimedTextVirtualTrackType_TimedTextSequenceTypeType
  // 


  // TimedTextVirtualTrackType_NamespaceURIType
  // 


  // DeliverySpecificationList_DeliverableListType
  // 

  const DeliverySpecificationList_DeliverableListType::DeliverableSequence& DeliverySpecificationList_DeliverableListType::
  getDeliverable () const
  {
    return this->Deliverable_;
  }

  DeliverySpecificationList_DeliverableListType::DeliverableSequence& DeliverySpecificationList_DeliverableListType::
  getDeliverable ()
  {
    return this->Deliverable_;
  }

  void DeliverySpecificationList_DeliverableListType::
  setDeliverable (const DeliverableSequence& s)
  {
    this->Deliverable_ = s;
  }


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::MatchTypeType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getMatchType () const
  {
    return this->MatchType_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::MatchTypeType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getMatchType ()
  {
    return this->MatchType_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setMatchType (const MatchTypeType& x)
  {
    this->MatchType_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setMatchType (::std::auto_ptr< MatchTypeType > x)
  {
    this->MatchType_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getValueList () const
  {
    return this->ValueList_.get ();
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  getValueList ()
  {
    return this->ValueList_.get ();
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setValueList (const ValueListType& x)
  {
    this->ValueList_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  setValueList (::std::auto_ptr< ValueListType > x)
  {
    this->ValueList_.set (x);
  }


  // DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::ImageVirtualTrackOptional& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getImageVirtualTrack () const
  {
    return this->ImageVirtualTrack_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::ImageVirtualTrackOptional& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getImageVirtualTrack ()
  {
    return this->ImageVirtualTrack_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setImageVirtualTrack (const ImageVirtualTrackType& x)
  {
    this->ImageVirtualTrack_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setImageVirtualTrack (const ImageVirtualTrackOptional& x)
  {
    this->ImageVirtualTrack_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setImageVirtualTrack (::std::auto_ptr< ImageVirtualTrackType > x)
  {
    this->ImageVirtualTrack_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::MarkerVirtualTrackOptional& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getMarkerVirtualTrack () const
  {
    return this->MarkerVirtualTrack_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::MarkerVirtualTrackOptional& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getMarkerVirtualTrack ()
  {
    return this->MarkerVirtualTrack_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setMarkerVirtualTrack (const MarkerVirtualTrackType& x)
  {
    this->MarkerVirtualTrack_.set (x);
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setMarkerVirtualTrack (const MarkerVirtualTrackOptional& x)
  {
    this->MarkerVirtualTrack_ = x;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setMarkerVirtualTrack (::std::auto_ptr< MarkerVirtualTrackType > x)
  {
    this->MarkerVirtualTrack_.set (x);
  }

  const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::AudioVirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getAudioVirtualTrack () const
  {
    return this->AudioVirtualTrack_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::AudioVirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getAudioVirtualTrack ()
  {
    return this->AudioVirtualTrack_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setAudioVirtualTrack (const AudioVirtualTrackSequence& s)
  {
    this->AudioVirtualTrack_ = s;
  }

  const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::TimedTextVirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getTimedTextVirtualTrack () const
  {
    return this->TimedTextVirtualTrack_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::TimedTextVirtualTrackSequence& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  getTimedTextVirtualTrack ()
  {
    return this->TimedTextVirtualTrack_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  setTimedTextVirtualTrack (const TimedTextVirtualTrackSequence& s)
  {
    this->TimedTextVirtualTrack_ = s;
  }


  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType
  // 

  const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::NameType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getName () const
  {
    return this->Name_.get ();
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::NameType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getName ()
  {
    return this->Name_.get ();
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setName (const NameType& x)
  {
    this->Name_.set (x);
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->Name_.set (x);
  }

  const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::PropertyListType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getPropertyList () const
  {
    return this->PropertyList_.get ();
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::PropertyListType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  getPropertyList ()
  {
    return this->PropertyList_.get ();
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setPropertyList (const PropertyListType& x)
  {
    this->PropertyList_.set (x);
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  setPropertyList (::std::auto_ptr< PropertyListType > x)
  {
    this->PropertyList_.set (x);
  }


  // GenericVirtualTrackType_TimelineComplexityType_SequenceType
  // 

  const GenericVirtualTrackType_TimelineComplexityType_SequenceType::CardinalityOptional& GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  getCardinality () const
  {
    return this->Cardinality_;
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::CardinalityOptional& GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  getCardinality ()
  {
    return this->Cardinality_;
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (const CardinalityType& x)
  {
    this->Cardinality_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (const CardinalityOptional& x)
  {
    this->Cardinality_ = x;
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  setCardinality (::std::auto_ptr< CardinalityType > x)
  {
    this->Cardinality_.set (x);
  }

  const GenericVirtualTrackType_TimelineComplexityType_SequenceType::ResourceType& GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  getResource () const
  {
    return this->Resource_.get ();
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::ResourceType& GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  getResource ()
  {
    return this->Resource_.get ();
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  setResource (const ResourceType& x)
  {
    this->Resource_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  setResource (::std::auto_ptr< ResourceType > x)
  {
    this->Resource_.set (x);
  }


  // GenericVirtualTrackType_TimelineComplexityType_typeType
  // 


  // AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType
  // 


  // AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType
  // 

  const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::MCATagSymbolType& AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  getMCATagSymbol () const
  {
    return this->MCATagSymbol_.get ();
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::MCATagSymbolType& AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  getMCATagSymbol ()
  {
    return this->MCATagSymbol_.get ();
  }

  void AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  setMCATagSymbol (const MCATagSymbolType& x)
  {
    this->MCATagSymbol_.set (x);
  }

  void AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  setMCATagSymbol (::std::auto_ptr< MCATagSymbolType > x)
  {
    this->MCATagSymbol_.set (x);
  }


  // AudioVirtualTrackType_SampleRateListType_SampleRateType
  // 


  // ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType
  // 


  // MarkerVirtualTrackType_MarkerListType_MarkerType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType
  // 


  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType
  // 

  const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationSequence& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  getApplicationIdentification () const
  {
    return this->ApplicationIdentification_;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationSequence& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  getApplicationIdentification ()
  {
    return this->ApplicationIdentification_;
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  setApplicationIdentification (const ApplicationIdentificationSequence& s)
  {
    this->ApplicationIdentification_ = s;
  }


  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType
  // 

  const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertySequence& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  getProperty () const
  {
    return this->Property_;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertySequence& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  getProperty ()
  {
    return this->Property_;
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  setProperty (const PropertySequence& s)
  {
    this->Property_ = s;
  }


  // GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType
  // 

  const GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::CardinalityOptional& GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  getCardinality () const
  {
    return this->Cardinality_;
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::CardinalityOptional& GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  getCardinality ()
  {
    return this->Cardinality_;
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (const CardinalityType& x)
  {
    this->Cardinality_.set (x);
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (const CardinalityOptional& x)
  {
    this->Cardinality_ = x;
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  setCardinality (::std::auto_ptr< CardinalityType > x)
  {
    this->Cardinality_.set (x);
  }


  // AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType
  // 


  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType
  // 

  const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::NameType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getName () const
  {
    return this->Name_.get ();
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::NameType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getName ()
  {
    return this->Name_.get ();
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setName (const NameType& x)
  {
    this->Name_.set (x);
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setName (::std::auto_ptr< NameType > x)
  {
    this->Name_.set (x);
  }

  const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::ValueType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getValue () const
  {
    return this->value_.get ();
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::ValueType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  getValue ()
  {
    return this->value_.get ();
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  setValue (::std::auto_ptr< ValueType > x)
  {
    this->value_.set (x);
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace dsl
{
  // DeliverableType
  //

  DeliverableType::
  DeliverableType (const IdType& Id,
                   const LabelType& Label,
                   const CompositionPlaylistConstraintsType& CompositionPlaylistConstraints)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Label_ (Label, this),
    CompositionPlaylistConstraints_ (CompositionPlaylistConstraints, this)
  {
  }

  DeliverableType::
  DeliverableType (const IdType& Id,
                   const LabelType& Label,
                   ::std::auto_ptr< CompositionPlaylistConstraintsType > CompositionPlaylistConstraints)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Label_ (Label, this),
    CompositionPlaylistConstraints_ (CompositionPlaylistConstraints, this)
  {
  }

  DeliverableType::
  DeliverableType (const DeliverableType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    Label_ (x.Label_, f, this),
    CompositionPlaylistConstraints_ (x.CompositionPlaylistConstraints_, f, this)
  {
  }

  DeliverableType::
  DeliverableType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    Label_ (this),
    CompositionPlaylistConstraints_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (r);
          continue;
        }
      }

      // Label
      //
      if (n.name () == "Label" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< LabelType > r (
          LabelTraits::create (i, f, this));

        if (!Label_.present ())
        {
          this->Label_.set (r);
          continue;
        }
      }

      // CompositionPlaylistConstraints
      //
      if (n.name () == "CompositionPlaylistConstraints" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< CompositionPlaylistConstraintsType > r (
          CompositionPlaylistConstraintsTraits::create (i, f, this));

        if (!CompositionPlaylistConstraints_.present ())
        {
          this->CompositionPlaylistConstraints_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!Label_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Label",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!CompositionPlaylistConstraints_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CompositionPlaylistConstraints",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  DeliverableType* DeliverableType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType (*this, f, c);
  }

  DeliverableType& DeliverableType::
  operator= (const DeliverableType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->Label_ = x.Label_;
      this->CompositionPlaylistConstraints_ = x.CompositionPlaylistConstraints_;
    }

    return *this;
  }

  DeliverableType::
  ~DeliverableType ()
  {
  }

  // GenericVirtualTrackType
  //

  GenericVirtualTrackType::
  GenericVirtualTrackType ()
  : ::xml_schema::Type (),
    EssenceEncodingConstraintList_ (this),
    TimelineComplexity_ (this),
    ReferenceCardinality_ (this),
    namespace__ (this)
  {
  }

  GenericVirtualTrackType::
  GenericVirtualTrackType (const GenericVirtualTrackType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EssenceEncodingConstraintList_ (x.EssenceEncodingConstraintList_, f, this),
    TimelineComplexity_ (x.TimelineComplexity_, f, this),
    ReferenceCardinality_ (x.ReferenceCardinality_, f, this),
    namespace__ (x.namespace__, f, this)
  {
  }

  GenericVirtualTrackType::
  GenericVirtualTrackType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EssenceEncodingConstraintList_ (this),
    TimelineComplexity_ (this),
    ReferenceCardinality_ (this),
    namespace__ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceEncodingConstraintList
      //
      if (n.name () == "EssenceEncodingConstraintList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< EssenceEncodingConstraintListType > r (
          EssenceEncodingConstraintListTraits::create (i, f, this));

        if (!this->EssenceEncodingConstraintList_)
        {
          this->EssenceEncodingConstraintList_.set (r);
          continue;
        }
      }

      // TimelineComplexity
      //
      if (n.name () == "TimelineComplexity" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< TimelineComplexityType > r (
          TimelineComplexityTraits::create (i, f, this));

        this->TimelineComplexity_.push_back (r);
        continue;
      }

      // ReferenceCardinality
      //
      if (n.name () == "ReferenceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ReferenceCardinalityType > r (
          ReferenceCardinalityTraits::create (i, f, this));

        if (!this->ReferenceCardinality_)
        {
          this->ReferenceCardinality_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "namespace" && n.namespace_ ().empty ())
      {
        this->namespace__.set (NamespaceTraits::create (i, f, this));
        continue;
      }
    }
  }

  GenericVirtualTrackType* GenericVirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType (*this, f, c);
  }

  GenericVirtualTrackType& GenericVirtualTrackType::
  operator= (const GenericVirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EssenceEncodingConstraintList_ = x.EssenceEncodingConstraintList_;
      this->TimelineComplexity_ = x.TimelineComplexity_;
      this->ReferenceCardinality_ = x.ReferenceCardinality_;
      this->namespace__ = x.namespace__;
    }

    return *this;
  }

  GenericVirtualTrackType::
  ~GenericVirtualTrackType ()
  {
  }

  // AudioVirtualTrackType
  //

  AudioVirtualTrackType::
  AudioVirtualTrackType (const EssenceEncodingType& EssenceEncoding)
  : ::dsl::GenericVirtualTrackType (),
    EssenceEncoding_ (EssenceEncoding, this),
    SoundfieldGroupConfiguration_ (this),
    AudioChannelMapping_ (this),
    SampleRateList_ (this)
  {
  }

  AudioVirtualTrackType::
  AudioVirtualTrackType (const AudioVirtualTrackType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (x, f, c),
    EssenceEncoding_ (x.EssenceEncoding_, f, this),
    SoundfieldGroupConfiguration_ (x.SoundfieldGroupConfiguration_, f, this),
    AudioChannelMapping_ (x.AudioChannelMapping_, f, this),
    SampleRateList_ (x.SampleRateList_, f, this)
  {
  }

  AudioVirtualTrackType::
  AudioVirtualTrackType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (e, f | ::xml_schema::Flags::base, c),
    EssenceEncoding_ (this),
    SoundfieldGroupConfiguration_ (this),
    AudioChannelMapping_ (this),
    SampleRateList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AudioVirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::dsl::GenericVirtualTrackType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceEncoding
      //
      if (n.name () == "EssenceEncoding" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< EssenceEncodingType > r (
          EssenceEncodingTraits::create (i, f, this));

        if (!EssenceEncoding_.present ())
        {
          this->EssenceEncoding_.set (r);
          continue;
        }
      }

      // SoundfieldGroupConfiguration
      //
      if (n.name () == "SoundfieldGroupConfiguration" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SoundfieldGroupConfigurationType > r (
          SoundfieldGroupConfigurationTraits::create (i, f, this));

        if (!this->SoundfieldGroupConfiguration_)
        {
          this->SoundfieldGroupConfiguration_.set (r);
          continue;
        }
      }

      // AudioChannelMapping
      //
      if (n.name () == "AudioChannelMapping" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< AudioChannelMappingType > r (
          AudioChannelMappingTraits::create (i, f, this));

        if (!this->AudioChannelMapping_)
        {
          this->AudioChannelMapping_.set (r);
          continue;
        }
      }

      // SampleRateList
      //
      if (n.name () == "SampleRateList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SampleRateListType > r (
          SampleRateListTraits::create (i, f, this));

        if (!this->SampleRateList_)
        {
          this->SampleRateList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EssenceEncoding_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EssenceEncoding",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  AudioVirtualTrackType* AudioVirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType (*this, f, c);
  }

  AudioVirtualTrackType& AudioVirtualTrackType::
  operator= (const AudioVirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::dsl::GenericVirtualTrackType& > (*this) = x;
      this->EssenceEncoding_ = x.EssenceEncoding_;
      this->SoundfieldGroupConfiguration_ = x.SoundfieldGroupConfiguration_;
      this->AudioChannelMapping_ = x.AudioChannelMapping_;
      this->SampleRateList_ = x.SampleRateList_;
    }

    return *this;
  }

  AudioVirtualTrackType::
  ~AudioVirtualTrackType ()
  {
  }

  // ImageVirtualTrackType
  //

  ImageVirtualTrackType::
  ImageVirtualTrackType (const EssenceEncodingType& EssenceEncoding)
  : ::dsl::GenericVirtualTrackType (),
    EssenceEncoding_ (EssenceEncoding, this),
    Colorimetry_ (this),
    Sampling_ (this),
    Quantization_ (this),
    FrameStructure_ (this),
    Stereoscopy_ (this),
    ColorComponents_ (this),
    PixelBitDepthList_ (this),
    ImageFrameWidthList_ (this),
    ImageFrameHeightList_ (this),
    FrameRateList_ (this)
  {
  }

  ImageVirtualTrackType::
  ImageVirtualTrackType (const ImageVirtualTrackType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (x, f, c),
    EssenceEncoding_ (x.EssenceEncoding_, f, this),
    Colorimetry_ (x.Colorimetry_, f, this),
    Sampling_ (x.Sampling_, f, this),
    Quantization_ (x.Quantization_, f, this),
    FrameStructure_ (x.FrameStructure_, f, this),
    Stereoscopy_ (x.Stereoscopy_, f, this),
    ColorComponents_ (x.ColorComponents_, f, this),
    PixelBitDepthList_ (x.PixelBitDepthList_, f, this),
    ImageFrameWidthList_ (x.ImageFrameWidthList_, f, this),
    ImageFrameHeightList_ (x.ImageFrameHeightList_, f, this),
    FrameRateList_ (x.FrameRateList_, f, this)
  {
  }

  ImageVirtualTrackType::
  ImageVirtualTrackType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (e, f | ::xml_schema::Flags::base, c),
    EssenceEncoding_ (this),
    Colorimetry_ (this),
    Sampling_ (this),
    Quantization_ (this),
    FrameStructure_ (this),
    Stereoscopy_ (this),
    ColorComponents_ (this),
    PixelBitDepthList_ (this),
    ImageFrameWidthList_ (this),
    ImageFrameHeightList_ (this),
    FrameRateList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ImageVirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::dsl::GenericVirtualTrackType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceEncoding
      //
      if (n.name () == "EssenceEncoding" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< EssenceEncodingType > r (
          EssenceEncodingTraits::create (i, f, this));

        if (!EssenceEncoding_.present ())
        {
          this->EssenceEncoding_.set (r);
          continue;
        }
      }

      // Colorimetry
      //
      if (n.name () == "Colorimetry" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ColorimetryType > r (
          ColorimetryTraits::create (i, f, this));

        if (!this->Colorimetry_)
        {
          this->Colorimetry_.set (r);
          continue;
        }
      }

      // Sampling
      //
      if (n.name () == "Sampling" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SamplingType > r (
          SamplingTraits::create (i, f, this));

        if (!this->Sampling_)
        {
          this->Sampling_.set (r);
          continue;
        }
      }

      // Quantization
      //
      if (n.name () == "Quantization" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< QuantizationType > r (
          QuantizationTraits::create (i, f, this));

        if (!this->Quantization_)
        {
          this->Quantization_.set (r);
          continue;
        }
      }

      // FrameStructure
      //
      if (n.name () == "FrameStructure" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< FrameStructureType > r (
          FrameStructureTraits::create (i, f, this));

        if (!this->FrameStructure_)
        {
          this->FrameStructure_.set (r);
          continue;
        }
      }

      // Stereoscopy
      //
      if (n.name () == "Stereoscopy" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< StereoscopyType > r (
          StereoscopyTraits::create (i, f, this));

        if (!this->Stereoscopy_)
        {
          this->Stereoscopy_.set (r);
          continue;
        }
      }

      // ColorComponents
      //
      if (n.name () == "ColorComponents" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ColorComponentsType > r (
          ColorComponentsTraits::create (i, f, this));

        if (!this->ColorComponents_)
        {
          this->ColorComponents_.set (r);
          continue;
        }
      }

      // PixelBitDepthList
      //
      if (n.name () == "PixelBitDepthList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< PixelBitDepthListType > r (
          PixelBitDepthListTraits::create (i, f, this));

        if (!this->PixelBitDepthList_)
        {
          this->PixelBitDepthList_.set (r);
          continue;
        }
      }

      // ImageFrameWidthList
      //
      if (n.name () == "ImageFrameWidthList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ImageFrameWidthListType > r (
          ImageFrameWidthListTraits::create (i, f, this));

        if (!this->ImageFrameWidthList_)
        {
          this->ImageFrameWidthList_.set (r);
          continue;
        }
      }

      // ImageFrameHeightList
      //
      if (n.name () == "ImageFrameHeightList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ImageFrameHeightListType > r (
          ImageFrameHeightListTraits::create (i, f, this));

        if (!this->ImageFrameHeightList_)
        {
          this->ImageFrameHeightList_.set (r);
          continue;
        }
      }

      // FrameRateList
      //
      if (n.name () == "FrameRateList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< FrameRateListType > r (
          FrameRateListTraits::create (i, f, this));

        if (!this->FrameRateList_)
        {
          this->FrameRateList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!EssenceEncoding_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EssenceEncoding",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  ImageVirtualTrackType* ImageVirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType (*this, f, c);
  }

  ImageVirtualTrackType& ImageVirtualTrackType::
  operator= (const ImageVirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::dsl::GenericVirtualTrackType& > (*this) = x;
      this->EssenceEncoding_ = x.EssenceEncoding_;
      this->Colorimetry_ = x.Colorimetry_;
      this->Sampling_ = x.Sampling_;
      this->Quantization_ = x.Quantization_;
      this->FrameStructure_ = x.FrameStructure_;
      this->Stereoscopy_ = x.Stereoscopy_;
      this->ColorComponents_ = x.ColorComponents_;
      this->PixelBitDepthList_ = x.PixelBitDepthList_;
      this->ImageFrameWidthList_ = x.ImageFrameWidthList_;
      this->ImageFrameHeightList_ = x.ImageFrameHeightList_;
      this->FrameRateList_ = x.FrameRateList_;
    }

    return *this;
  }

  ImageVirtualTrackType::
  ~ImageVirtualTrackType ()
  {
  }

  // CardinalityType
  //

  CardinalityType::
  CardinalityType (const MinItemType& MinItem,
                   const MaxItemType& MaxItem)
  : ::xml_schema::Type (),
    MinItem_ (MinItem, this),
    MaxItem_ (MaxItem, this)
  {
  }

  CardinalityType::
  CardinalityType (const CardinalityType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MinItem_ (x.MinItem_, f, this),
    MaxItem_ (x.MaxItem_, f, this)
  {
  }

  CardinalityType::
  CardinalityType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MinItem_ (this),
    MaxItem_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CardinalityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MinItem
      //
      if (n.name () == "MinItem" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MinItemType > r (
          MinItemTraits::create (i, f, this));

        if (!MinItem_.present ())
        {
          this->MinItem_.set (r);
          continue;
        }
      }

      // MaxItem
      //
      if (n.name () == "MaxItem" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MaxItemType > r (
          MaxItemTraits::create (i, f, this));

        if (!MaxItem_.present ())
        {
          this->MaxItem_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MinItem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MinItem",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!MaxItem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MaxItem",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  CardinalityType* CardinalityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType (*this, f, c);
  }

  CardinalityType& CardinalityType::
  operator= (const CardinalityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MinItem_ = x.MinItem_;
      this->MaxItem_ = x.MaxItem_;
    }

    return *this;
  }

  CardinalityType::
  ~CardinalityType ()
  {
  }

  // MarkerVirtualTrackType
  //

  MarkerVirtualTrackType::
  MarkerVirtualTrackType ()
  : ::dsl::GenericVirtualTrackType (),
    MarkerList_ (this)
  {
  }

  MarkerVirtualTrackType::
  MarkerVirtualTrackType (const MarkerVirtualTrackType& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (x, f, c),
    MarkerList_ (x.MarkerList_, f, this)
  {
  }

  MarkerVirtualTrackType::
  MarkerVirtualTrackType (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (e, f | ::xml_schema::Flags::base, c),
    MarkerList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MarkerVirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::dsl::GenericVirtualTrackType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MarkerList
      //
      if (n.name () == "MarkerList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MarkerListType > r (
          MarkerListTraits::create (i, f, this));

        if (!this->MarkerList_)
        {
          this->MarkerList_.set (r);
          continue;
        }
      }

      break;
    }
  }

  MarkerVirtualTrackType* MarkerVirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerVirtualTrackType (*this, f, c);
  }

  MarkerVirtualTrackType& MarkerVirtualTrackType::
  operator= (const MarkerVirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::dsl::GenericVirtualTrackType& > (*this) = x;
      this->MarkerList_ = x.MarkerList_;
    }

    return *this;
  }

  MarkerVirtualTrackType::
  ~MarkerVirtualTrackType ()
  {
  }

  // TimedTextVirtualTrackType
  //

  TimedTextVirtualTrackType::
  TimedTextVirtualTrackType (const TimedTextSequenceTypeType& TimedTextSequenceType)
  : ::dsl::GenericVirtualTrackType (),
    TimedTextSequenceType_ (TimedTextSequenceType, this),
    NamespaceURI_ (this)
  {
  }

  TimedTextVirtualTrackType::
  TimedTextVirtualTrackType (const TimedTextVirtualTrackType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (x, f, c),
    TimedTextSequenceType_ (x.TimedTextSequenceType_, f, this),
    NamespaceURI_ (x.NamespaceURI_, f, this)
  {
  }

  TimedTextVirtualTrackType::
  TimedTextVirtualTrackType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::dsl::GenericVirtualTrackType (e, f | ::xml_schema::Flags::base, c),
    TimedTextSequenceType_ (this),
    NamespaceURI_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TimedTextVirtualTrackType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::dsl::GenericVirtualTrackType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TimedTextSequenceType
      //
      if (n.name () == "TimedTextSequenceType" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< TimedTextSequenceTypeType > r (
          TimedTextSequenceTypeTraits::create (i, f, this));

        if (!TimedTextSequenceType_.present ())
        {
          this->TimedTextSequenceType_.set (r);
          continue;
        }
      }

      // NamespaceURI
      //
      if (n.name () == "NamespaceURI" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< NamespaceURIType > r (
          NamespaceURITraits::create (i, f, this));

        if (!this->NamespaceURI_)
        {
          this->NamespaceURI_.set (r);
          continue;
        }
      }

      break;
    }

    if (!TimedTextSequenceType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TimedTextSequenceType",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  TimedTextVirtualTrackType* TimedTextVirtualTrackType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedTextVirtualTrackType (*this, f, c);
  }

  TimedTextVirtualTrackType& TimedTextVirtualTrackType::
  operator= (const TimedTextVirtualTrackType& x)
  {
    if (this != &x)
    {
      static_cast< ::dsl::GenericVirtualTrackType& > (*this) = x;
      this->TimedTextSequenceType_ = x.TimedTextSequenceType_;
      this->NamespaceURI_ = x.NamespaceURI_;
    }

    return *this;
  }

  TimedTextVirtualTrackType::
  ~TimedTextVirtualTrackType ()
  {
  }

  // DeliverySpecificationList
  //

  DeliverySpecificationList::
  DeliverySpecificationList (const IdType& Id,
                             const IssueDateType& IssueDate,
                             const DeliverableListType& DeliverableList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    AnnotationText_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (DeliverableList, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const IdType& Id,
                             const IssueDateType& IssueDate,
                             ::std::auto_ptr< DeliverableListType > DeliverableList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    AnnotationText_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (DeliverableList, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const DeliverySpecificationList& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    AnnotationText_ (x.AnnotationText_, f, this),
    IssueDate_ (x.IssueDate_, f, this),
    Issuer_ (x.Issuer_, f, this),
    Creator_ (x.Creator_, f, this),
    DeliverableList_ (x.DeliverableList_, f, this)
  {
  }

  DeliverySpecificationList::
  DeliverySpecificationList (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    AnnotationText_ (this),
    IssueDate_ (this),
    Issuer_ (this),
    Creator_ (this),
    DeliverableList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverySpecificationList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (r);
          continue;
        }
      }

      // AnnotationText
      //
      if (n.name () == "AnnotationText" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< AnnotationTextType > r (
          AnnotationTextTraits::create (i, f, this));

        if (!this->AnnotationText_)
        {
          this->AnnotationText_.set (r);
          continue;
        }
      }

      // IssueDate
      //
      if (n.name () == "IssueDate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< IssueDateType > r (
          IssueDateTraits::create (i, f, this));

        if (!IssueDate_.present ())
        {
          this->IssueDate_.set (r);
          continue;
        }
      }

      // Issuer
      //
      if (n.name () == "Issuer" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< IssuerType > r (
          IssuerTraits::create (i, f, this));

        if (!this->Issuer_)
        {
          this->Issuer_.set (r);
          continue;
        }
      }

      // Creator
      //
      if (n.name () == "Creator" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< CreatorType > r (
          CreatorTraits::create (i, f, this));

        if (!this->Creator_)
        {
          this->Creator_.set (r);
          continue;
        }
      }

      // DeliverableList
      //
      if (n.name () == "DeliverableList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< DeliverableListType > r (
          DeliverableListTraits::create (i, f, this));

        if (!DeliverableList_.present ())
        {
          this->DeliverableList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!IssueDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IssueDate",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!DeliverableList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeliverableList",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  DeliverySpecificationList* DeliverySpecificationList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverySpecificationList (*this, f, c);
  }

  DeliverySpecificationList& DeliverySpecificationList::
  operator= (const DeliverySpecificationList& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->AnnotationText_ = x.AnnotationText_;
      this->IssueDate_ = x.IssueDate_;
      this->Issuer_ = x.Issuer_;
      this->Creator_ = x.Creator_;
      this->DeliverableList_ = x.DeliverableList_;
    }

    return *this;
  }

  DeliverySpecificationList::
  ~DeliverySpecificationList ()
  {
  }

  // DeliverableType_LabelType
  //

  DeliverableType_LabelType::
  DeliverableType_LabelType ()
  : ::xml_schema::String ()
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const DeliverableType_LabelType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DeliverableType_LabelType::
  DeliverableType_LabelType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DeliverableType_LabelType* DeliverableType_LabelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_LabelType (*this, f, c);
  }

  DeliverableType_LabelType::
  ~DeliverableType_LabelType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType
  //

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const OwnerIdType& OwnerId,
                                                      const VirtualTrackListType& VirtualTrackList)
  : ::xml_schema::Type (),
    OwnerId_ (OwnerId, this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    SegmentCardinality_ (this),
    VirtualTrackList_ (VirtualTrackList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const OwnerIdType& OwnerId,
                                                      ::std::auto_ptr< VirtualTrackListType > VirtualTrackList)
  : ::xml_schema::Type (),
    OwnerId_ (OwnerId, this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    SegmentCardinality_ (this),
    VirtualTrackList_ (VirtualTrackList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const DeliverableType_CompositionPlaylistConstraintsType& x,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    OwnerId_ (x.OwnerId_, f, this),
    ApplicationIdentificationList_ (x.ApplicationIdentificationList_, f, this),
    ApplicationIdentification_ (x.ApplicationIdentification_, f, this),
    SegmentCardinality_ (x.SegmentCardinality_, f, this),
    VirtualTrackList_ (x.VirtualTrackList_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  DeliverableType_CompositionPlaylistConstraintsType (const ::xercesc::DOMElement& e,
                                                      ::xml_schema::Flags f,
                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    OwnerId_ (this),
    ApplicationIdentificationList_ (this),
    ApplicationIdentification_ (this),
    SegmentCardinality_ (this),
    VirtualTrackList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OwnerId
      //
      if (n.name () == "OwnerId" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< OwnerIdType > r (
          OwnerIdTraits::create (i, f, this));

        if (!OwnerId_.present ())
        {
          this->OwnerId_.set (r);
          continue;
        }
      }

      // ApplicationIdentificationList
      //
      if (n.name () == "ApplicationIdentificationList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ApplicationIdentificationListType > r (
          ApplicationIdentificationListTraits::create (i, f, this));

        if (!this->ApplicationIdentificationList_)
        {
          this->ApplicationIdentificationList_.set (r);
          continue;
        }
      }

      // ApplicationIdentification
      //
      if (n.name () == "ApplicationIdentification" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ApplicationIdentificationType > r (
          ApplicationIdentificationTraits::create (i, f, this));

        if (!this->ApplicationIdentification_)
        {
          this->ApplicationIdentification_.set (r);
          continue;
        }
      }

      // SegmentCardinality
      //
      if (n.name () == "SegmentCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SegmentCardinalityType > r (
          SegmentCardinalityTraits::create (i, f, this));

        if (!this->SegmentCardinality_)
        {
          this->SegmentCardinality_.set (r);
          continue;
        }
      }

      // VirtualTrackList
      //
      if (n.name () == "VirtualTrackList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< VirtualTrackListType > r (
          VirtualTrackListTraits::create (i, f, this));

        if (!VirtualTrackList_.present ())
        {
          this->VirtualTrackList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!OwnerId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OwnerId",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!VirtualTrackList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "VirtualTrackList",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType* DeliverableType_CompositionPlaylistConstraintsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType& DeliverableType_CompositionPlaylistConstraintsType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->OwnerId_ = x.OwnerId_;
      this->ApplicationIdentificationList_ = x.ApplicationIdentificationList_;
      this->ApplicationIdentification_ = x.ApplicationIdentification_;
      this->SegmentCardinality_ = x.SegmentCardinality_;
      this->VirtualTrackList_ = x.VirtualTrackList_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType::
  ~DeliverableType_CompositionPlaylistConstraintsType ()
  {
  }

  // GenericVirtualTrackType_EssenceEncodingConstraintListType
  //

  GenericVirtualTrackType_EssenceEncodingConstraintListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType (const ScopeType& scope)
  : ::xml_schema::Type (),
    EssenceEncodingConstraint_ (this),
    scope_ (scope, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType (const GenericVirtualTrackType_EssenceEncodingConstraintListType& x,
                                                             ::xml_schema::Flags f,
                                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EssenceEncodingConstraint_ (x.EssenceEncodingConstraint_, f, this),
    scope_ (x.scope_, f, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType (const ::xercesc::DOMElement& e,
                                                             ::xml_schema::Flags f,
                                                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EssenceEncodingConstraint_ (this),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceEncodingConstraint
      //
      if (n.name () == "EssenceEncodingConstraint" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< EssenceEncodingConstraintType > r (
          EssenceEncodingConstraintTraits::create (i, f, this));

        this->EssenceEncodingConstraint_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scope",
        "");
    }
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType* GenericVirtualTrackType_EssenceEncodingConstraintListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_EssenceEncodingConstraintListType (*this, f, c);
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType& GenericVirtualTrackType_EssenceEncodingConstraintListType::
  operator= (const GenericVirtualTrackType_EssenceEncodingConstraintListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EssenceEncodingConstraint_ = x.EssenceEncodingConstraint_;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType::
  ~GenericVirtualTrackType_EssenceEncodingConstraintListType ()
  {
  }

  // GenericVirtualTrackType_TimelineComplexityType
  //

  GenericVirtualTrackType_TimelineComplexityType::
  GenericVirtualTrackType_TimelineComplexityType (const SequenceType& Sequence,
                                                  const TypeType& type)
  : ::xml_schema::Type (),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (Sequence, this),
    type_ (type, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType::
  GenericVirtualTrackType_TimelineComplexityType (::std::auto_ptr< SequenceType > Sequence,
                                                  const TypeType& type)
  : ::xml_schema::Type (),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (Sequence, this),
    type_ (type, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType::
  GenericVirtualTrackType_TimelineComplexityType (const GenericVirtualTrackType_TimelineComplexityType& x,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SequenceCardinality_ (x.SequenceCardinality_, f, this),
    ResourceCardinality_ (x.ResourceCardinality_, f, this),
    Sequence_ (x.Sequence_, f, this),
    type_ (x.type_, f, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType::
  GenericVirtualTrackType_TimelineComplexityType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SequenceCardinality_ (this),
    ResourceCardinality_ (this),
    Sequence_ (this),
    type_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_TimelineComplexityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SequenceCardinality
      //
      if (n.name () == "SequenceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SequenceCardinalityType > r (
          SequenceCardinalityTraits::create (i, f, this));

        if (!this->SequenceCardinality_)
        {
          this->SequenceCardinality_.set (r);
          continue;
        }
      }

      // ResourceCardinality
      //
      if (n.name () == "ResourceCardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ResourceCardinalityType > r (
          ResourceCardinalityTraits::create (i, f, this));

        if (!this->ResourceCardinality_)
        {
          this->ResourceCardinality_.set (r);
          continue;
        }
      }

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SequenceType > r (
          SequenceTraits::create (i, f, this));

        if (!Sequence_.present ())
        {
          this->Sequence_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Sequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Sequence",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        this->type_.set (TypeTraits::create (i, f, this));
        continue;
      }
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "type",
        "");
    }
  }

  GenericVirtualTrackType_TimelineComplexityType* GenericVirtualTrackType_TimelineComplexityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_TimelineComplexityType (*this, f, c);
  }

  GenericVirtualTrackType_TimelineComplexityType& GenericVirtualTrackType_TimelineComplexityType::
  operator= (const GenericVirtualTrackType_TimelineComplexityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SequenceCardinality_ = x.SequenceCardinality_;
      this->ResourceCardinality_ = x.ResourceCardinality_;
      this->Sequence_ = x.Sequence_;
      this->type_ = x.type_;
    }

    return *this;
  }

  GenericVirtualTrackType_TimelineComplexityType::
  ~GenericVirtualTrackType_TimelineComplexityType ()
  {
  }

  // GenericVirtualTrackType_ReferenceCardinalityType
  //

  GenericVirtualTrackType_ReferenceCardinalityType::
  GenericVirtualTrackType_ReferenceCardinalityType (const SequenceType& Sequence)
  : ::xml_schema::Type (),
    Sequence_ (Sequence, this)
  {
  }

  GenericVirtualTrackType_ReferenceCardinalityType::
  GenericVirtualTrackType_ReferenceCardinalityType (::std::auto_ptr< SequenceType > Sequence)
  : ::xml_schema::Type (),
    Sequence_ (Sequence, this)
  {
  }

  GenericVirtualTrackType_ReferenceCardinalityType::
  GenericVirtualTrackType_ReferenceCardinalityType (const GenericVirtualTrackType_ReferenceCardinalityType& x,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Sequence_ (x.Sequence_, f, this)
  {
  }

  GenericVirtualTrackType_ReferenceCardinalityType::
  GenericVirtualTrackType_ReferenceCardinalityType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Sequence_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_ReferenceCardinalityType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sequence
      //
      if (n.name () == "Sequence" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SequenceType > r (
          SequenceTraits::create (i, f, this));

        if (!Sequence_.present ())
        {
          this->Sequence_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Sequence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Sequence",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  GenericVirtualTrackType_ReferenceCardinalityType* GenericVirtualTrackType_ReferenceCardinalityType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_ReferenceCardinalityType (*this, f, c);
  }

  GenericVirtualTrackType_ReferenceCardinalityType& GenericVirtualTrackType_ReferenceCardinalityType::
  operator= (const GenericVirtualTrackType_ReferenceCardinalityType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Sequence_ = x.Sequence_;
    }

    return *this;
  }

  GenericVirtualTrackType_ReferenceCardinalityType::
  ~GenericVirtualTrackType_ReferenceCardinalityType ()
  {
  }

  // GenericVirtualTrackType_namespaceType
  //

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType ()
  : ::xml_schema::String ()
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const GenericVirtualTrackType_namespaceType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  GenericVirtualTrackType_namespaceType::
  GenericVirtualTrackType_namespaceType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  GenericVirtualTrackType_namespaceType* GenericVirtualTrackType_namespaceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_namespaceType (*this, f, c);
  }

  GenericVirtualTrackType_namespaceType::
  ~GenericVirtualTrackType_namespaceType ()
  {
  }

  // AudioVirtualTrackType_EssenceEncodingType
  //

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType ()
  : ::xml_schema::String ()
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const AudioVirtualTrackType_EssenceEncodingType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType::
  AudioVirtualTrackType_EssenceEncodingType (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  AudioVirtualTrackType_EssenceEncodingType* AudioVirtualTrackType_EssenceEncodingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_EssenceEncodingType (*this, f, c);
  }

  AudioVirtualTrackType_EssenceEncodingType::
  ~AudioVirtualTrackType_EssenceEncodingType ()
  {
  }

  // AudioVirtualTrackType_SoundfieldGroupConfigurationType
  //

  AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType (const MCATagSymbolType& MCATagSymbol)
  : ::xml_schema::Type (),
    MCATagSymbol_ (MCATagSymbol, this)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType (const AudioVirtualTrackType_SoundfieldGroupConfigurationType& x,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MCATagSymbol_ (x.MCATagSymbol_, f, this)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType (const ::xercesc::DOMElement& e,
                                                          ::xml_schema::Flags f,
                                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MCATagSymbol_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MCATagSymbol
      //
      if (n.name () == "MCATagSymbol" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MCATagSymbolType > r (
          MCATagSymbolTraits::create (i, f, this));

        if (!MCATagSymbol_.present ())
        {
          this->MCATagSymbol_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MCATagSymbol_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MCATagSymbol",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType* AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_SoundfieldGroupConfigurationType (*this, f, c);
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType& AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  operator= (const AudioVirtualTrackType_SoundfieldGroupConfigurationType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MCATagSymbol_ = x.MCATagSymbol_;
    }

    return *this;
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType::
  ~AudioVirtualTrackType_SoundfieldGroupConfigurationType ()
  {
  }

  // AudioVirtualTrackType_AudioChannelMappingType
  //

  AudioVirtualTrackType_AudioChannelMappingType::
  AudioVirtualTrackType_AudioChannelMappingType ()
  : ::xml_schema::Type (),
    AudioChannel_ (this)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType::
  AudioVirtualTrackType_AudioChannelMappingType (const AudioVirtualTrackType_AudioChannelMappingType& x,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    AudioChannel_ (x.AudioChannel_, f, this)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType::
  AudioVirtualTrackType_AudioChannelMappingType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    AudioChannel_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AudioVirtualTrackType_AudioChannelMappingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AudioChannel
      //
      if (n.name () == "AudioChannel" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< AudioChannelType > r (
          AudioChannelTraits::create (i, f, this));

        this->AudioChannel_.push_back (r);
        continue;
      }

      break;
    }
  }

  AudioVirtualTrackType_AudioChannelMappingType* AudioVirtualTrackType_AudioChannelMappingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_AudioChannelMappingType (*this, f, c);
  }

  AudioVirtualTrackType_AudioChannelMappingType& AudioVirtualTrackType_AudioChannelMappingType::
  operator= (const AudioVirtualTrackType_AudioChannelMappingType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->AudioChannel_ = x.AudioChannel_;
    }

    return *this;
  }

  AudioVirtualTrackType_AudioChannelMappingType::
  ~AudioVirtualTrackType_AudioChannelMappingType ()
  {
  }

  // AudioVirtualTrackType_SampleRateListType
  //

  AudioVirtualTrackType_SampleRateListType::
  AudioVirtualTrackType_SampleRateListType ()
  : ::xml_schema::Type (),
    SampleRate_ (this)
  {
  }

  AudioVirtualTrackType_SampleRateListType::
  AudioVirtualTrackType_SampleRateListType (const AudioVirtualTrackType_SampleRateListType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    SampleRate_ (x.SampleRate_, f, this)
  {
  }

  AudioVirtualTrackType_SampleRateListType::
  AudioVirtualTrackType_SampleRateListType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    SampleRate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AudioVirtualTrackType_SampleRateListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SampleRate
      //
      if (n.name () == "SampleRate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< SampleRateType > r (
          SampleRateTraits::create (i, f, this));

        this->SampleRate_.push_back (r);
        continue;
      }

      break;
    }
  }

  AudioVirtualTrackType_SampleRateListType* AudioVirtualTrackType_SampleRateListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_SampleRateListType (*this, f, c);
  }

  AudioVirtualTrackType_SampleRateListType& AudioVirtualTrackType_SampleRateListType::
  operator= (const AudioVirtualTrackType_SampleRateListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->SampleRate_ = x.SampleRate_;
    }

    return *this;
  }

  AudioVirtualTrackType_SampleRateListType::
  ~AudioVirtualTrackType_SampleRateListType ()
  {
  }

  // ImageVirtualTrackType_EssenceEncodingType
  //

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ImageVirtualTrackType_EssenceEncodingType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ImageVirtualTrackType_EssenceEncodingType (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_EssenceEncodingType* ImageVirtualTrackType_EssenceEncodingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_EssenceEncodingType (*this, f, c);
  }

  ImageVirtualTrackType_EssenceEncodingType::
  ~ImageVirtualTrackType_EssenceEncodingType ()
  {
  }

  // ImageVirtualTrackType_ColorimetryType
  //

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ImageVirtualTrackType_ColorimetryType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_ColorimetryType::
  ImageVirtualTrackType_ColorimetryType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_ColorimetryType* ImageVirtualTrackType_ColorimetryType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_ColorimetryType (*this, f, c);
  }

  ImageVirtualTrackType_ColorimetryType::
  ~ImageVirtualTrackType_ColorimetryType ()
  {
  }

  // ImageVirtualTrackType_SamplingType
  //

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ImageVirtualTrackType_SamplingType& x,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ::xercesc::DOMAttr& a,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_SamplingType::
  ImageVirtualTrackType_SamplingType (const ::std::string& s,
                                      const ::xercesc::DOMElement* e,
                                      ::xml_schema::Flags f,
                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_SamplingType* ImageVirtualTrackType_SamplingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_SamplingType (*this, f, c);
  }

  ImageVirtualTrackType_SamplingType::
  ~ImageVirtualTrackType_SamplingType ()
  {
  }

  // ImageVirtualTrackType_QuantizationType
  //

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ImageVirtualTrackType_QuantizationType& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ::xercesc::DOMAttr& a,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_QuantizationType::
  ImageVirtualTrackType_QuantizationType (const ::std::string& s,
                                          const ::xercesc::DOMElement* e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_QuantizationType* ImageVirtualTrackType_QuantizationType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_QuantizationType (*this, f, c);
  }

  ImageVirtualTrackType_QuantizationType::
  ~ImageVirtualTrackType_QuantizationType ()
  {
  }

  // ImageVirtualTrackType_FrameStructureType
  //

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ImageVirtualTrackType_FrameStructureType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ::xercesc::DOMAttr& a,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_FrameStructureType::
  ImageVirtualTrackType_FrameStructureType (const ::std::string& s,
                                            const ::xercesc::DOMElement* e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_FrameStructureType* ImageVirtualTrackType_FrameStructureType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_FrameStructureType (*this, f, c);
  }

  ImageVirtualTrackType_FrameStructureType::
  ~ImageVirtualTrackType_FrameStructureType ()
  {
  }

  // ImageVirtualTrackType_StereoscopyType
  //

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ImageVirtualTrackType_StereoscopyType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ::xercesc::DOMAttr& a,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_StereoscopyType::
  ImageVirtualTrackType_StereoscopyType (const ::std::string& s,
                                         const ::xercesc::DOMElement* e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_StereoscopyType* ImageVirtualTrackType_StereoscopyType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_StereoscopyType (*this, f, c);
  }

  ImageVirtualTrackType_StereoscopyType::
  ~ImageVirtualTrackType_StereoscopyType ()
  {
  }

  // ImageVirtualTrackType_ColorComponentsType
  //

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType ()
  : ::xml_schema::String ()
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ImageVirtualTrackType_ColorComponentsType& x,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ::xercesc::DOMElement& e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ::xercesc::DOMAttr& a,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  ImageVirtualTrackType_ColorComponentsType::
  ImageVirtualTrackType_ColorComponentsType (const ::std::string& s,
                                             const ::xercesc::DOMElement* e,
                                             ::xml_schema::Flags f,
                                             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  ImageVirtualTrackType_ColorComponentsType* ImageVirtualTrackType_ColorComponentsType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_ColorComponentsType (*this, f, c);
  }

  ImageVirtualTrackType_ColorComponentsType::
  ~ImageVirtualTrackType_ColorComponentsType ()
  {
  }

  // ImageVirtualTrackType_PixelBitDepthListType
  //

  ImageVirtualTrackType_PixelBitDepthListType::
  ImageVirtualTrackType_PixelBitDepthListType ()
  : ::xml_schema::Type (),
    PixelBitDepth_ (this)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType::
  ImageVirtualTrackType_PixelBitDepthListType (const ImageVirtualTrackType_PixelBitDepthListType& x,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PixelBitDepth_ (x.PixelBitDepth_, f, this)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType::
  ImageVirtualTrackType_PixelBitDepthListType (const ::xercesc::DOMElement& e,
                                               ::xml_schema::Flags f,
                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PixelBitDepth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImageVirtualTrackType_PixelBitDepthListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PixelBitDepth
      //
      if (n.name () == "PixelBitDepth" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< PixelBitDepthType > r (
          PixelBitDepthTraits::create (i, f, this));

        this->PixelBitDepth_.push_back (r);
        continue;
      }

      break;
    }
  }

  ImageVirtualTrackType_PixelBitDepthListType* ImageVirtualTrackType_PixelBitDepthListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_PixelBitDepthListType (*this, f, c);
  }

  ImageVirtualTrackType_PixelBitDepthListType& ImageVirtualTrackType_PixelBitDepthListType::
  operator= (const ImageVirtualTrackType_PixelBitDepthListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->PixelBitDepth_ = x.PixelBitDepth_;
    }

    return *this;
  }

  ImageVirtualTrackType_PixelBitDepthListType::
  ~ImageVirtualTrackType_PixelBitDepthListType ()
  {
  }

  // ImageVirtualTrackType_ImageFrameWidthListType
  //

  ImageVirtualTrackType_ImageFrameWidthListType::
  ImageVirtualTrackType_ImageFrameWidthListType ()
  : ::xml_schema::Type (),
    ImageFrameWidth_ (this)
  {
  }

  ImageVirtualTrackType_ImageFrameWidthListType::
  ImageVirtualTrackType_ImageFrameWidthListType (const ImageVirtualTrackType_ImageFrameWidthListType& x,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ImageFrameWidth_ (x.ImageFrameWidth_, f, this)
  {
  }

  ImageVirtualTrackType_ImageFrameWidthListType::
  ImageVirtualTrackType_ImageFrameWidthListType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ImageFrameWidth_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImageVirtualTrackType_ImageFrameWidthListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ImageFrameWidth
      //
      if (n.name () == "ImageFrameWidth" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        this->ImageFrameWidth_.push_back (ImageFrameWidthTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  ImageVirtualTrackType_ImageFrameWidthListType* ImageVirtualTrackType_ImageFrameWidthListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_ImageFrameWidthListType (*this, f, c);
  }

  ImageVirtualTrackType_ImageFrameWidthListType& ImageVirtualTrackType_ImageFrameWidthListType::
  operator= (const ImageVirtualTrackType_ImageFrameWidthListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ImageFrameWidth_ = x.ImageFrameWidth_;
    }

    return *this;
  }

  ImageVirtualTrackType_ImageFrameWidthListType::
  ~ImageVirtualTrackType_ImageFrameWidthListType ()
  {
  }

  // ImageVirtualTrackType_ImageFrameHeightListType
  //

  ImageVirtualTrackType_ImageFrameHeightListType::
  ImageVirtualTrackType_ImageFrameHeightListType ()
  : ::xml_schema::Type (),
    ImageFrameHeight_ (this)
  {
  }

  ImageVirtualTrackType_ImageFrameHeightListType::
  ImageVirtualTrackType_ImageFrameHeightListType (const ImageVirtualTrackType_ImageFrameHeightListType& x,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ImageFrameHeight_ (x.ImageFrameHeight_, f, this)
  {
  }

  ImageVirtualTrackType_ImageFrameHeightListType::
  ImageVirtualTrackType_ImageFrameHeightListType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ImageFrameHeight_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImageVirtualTrackType_ImageFrameHeightListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ImageFrameHeight
      //
      if (n.name () == "ImageFrameHeight" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        this->ImageFrameHeight_.push_back (ImageFrameHeightTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  ImageVirtualTrackType_ImageFrameHeightListType* ImageVirtualTrackType_ImageFrameHeightListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_ImageFrameHeightListType (*this, f, c);
  }

  ImageVirtualTrackType_ImageFrameHeightListType& ImageVirtualTrackType_ImageFrameHeightListType::
  operator= (const ImageVirtualTrackType_ImageFrameHeightListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ImageFrameHeight_ = x.ImageFrameHeight_;
    }

    return *this;
  }

  ImageVirtualTrackType_ImageFrameHeightListType::
  ~ImageVirtualTrackType_ImageFrameHeightListType ()
  {
  }

  // ImageVirtualTrackType_FrameRateListType
  //

  ImageVirtualTrackType_FrameRateListType::
  ImageVirtualTrackType_FrameRateListType ()
  : ::xml_schema::Type (),
    FrameRate_ (this)
  {
  }

  ImageVirtualTrackType_FrameRateListType::
  ImageVirtualTrackType_FrameRateListType (const ImageVirtualTrackType_FrameRateListType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    FrameRate_ (x.FrameRate_, f, this)
  {
  }

  ImageVirtualTrackType_FrameRateListType::
  ImageVirtualTrackType_FrameRateListType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    FrameRate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ImageVirtualTrackType_FrameRateListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FrameRate
      //
      if (n.name () == "FrameRate" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< FrameRateType > r (
          FrameRateTraits::create (i, f, this));

        this->FrameRate_.push_back (r);
        continue;
      }

      break;
    }
  }

  ImageVirtualTrackType_FrameRateListType* ImageVirtualTrackType_FrameRateListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_FrameRateListType (*this, f, c);
  }

  ImageVirtualTrackType_FrameRateListType& ImageVirtualTrackType_FrameRateListType::
  operator= (const ImageVirtualTrackType_FrameRateListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->FrameRate_ = x.FrameRate_;
    }

    return *this;
  }

  ImageVirtualTrackType_FrameRateListType::
  ~ImageVirtualTrackType_FrameRateListType ()
  {
  }

  // CardinalityType_MinItemType
  //

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const CardinalityType_MinItemType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  CardinalityType_MinItemType::
  CardinalityType_MinItemType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  CardinalityType_MinItemType* CardinalityType_MinItemType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType_MinItemType (*this, f, c);
  }

  CardinalityType_MinItemType::
  ~CardinalityType_MinItemType ()
  {
  }

  // CardinalityType_MaxItemType
  //

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const CardinalityType_MaxItemType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::xercesc::DOMAttr& a,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  CardinalityType_MaxItemType::
  CardinalityType_MaxItemType (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  CardinalityType_MaxItemType* CardinalityType_MaxItemType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CardinalityType_MaxItemType (*this, f, c);
  }

  CardinalityType_MaxItemType::
  ~CardinalityType_MaxItemType ()
  {
  }

  // MarkerVirtualTrackType_MarkerListType
  //

  MarkerVirtualTrackType_MarkerListType::
  MarkerVirtualTrackType_MarkerListType ()
  : ::xml_schema::Type (),
    Marker_ (this)
  {
  }

  MarkerVirtualTrackType_MarkerListType::
  MarkerVirtualTrackType_MarkerListType (const MarkerVirtualTrackType_MarkerListType& x,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Marker_ (x.Marker_, f, this)
  {
  }

  MarkerVirtualTrackType_MarkerListType::
  MarkerVirtualTrackType_MarkerListType (const ::xercesc::DOMElement& e,
                                         ::xml_schema::Flags f,
                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Marker_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MarkerVirtualTrackType_MarkerListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Marker
      //
      if (n.name () == "Marker" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MarkerType > r (
          MarkerTraits::create (i, f, this));

        this->Marker_.push_back (r);
        continue;
      }

      break;
    }
  }

  MarkerVirtualTrackType_MarkerListType* MarkerVirtualTrackType_MarkerListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerVirtualTrackType_MarkerListType (*this, f, c);
  }

  MarkerVirtualTrackType_MarkerListType& MarkerVirtualTrackType_MarkerListType::
  operator= (const MarkerVirtualTrackType_MarkerListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Marker_ = x.Marker_;
    }

    return *this;
  }

  MarkerVirtualTrackType_MarkerListType::
  ~MarkerVirtualTrackType_MarkerListType ()
  {
  }

  // TimedTextVirtualTrackType_TimedTextSequenceTypeType
  //

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType ()
  : ::xml_schema::String ()
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const TimedTextVirtualTrackType_TimedTextSequenceTypeType& x,
                                                       ::xml_schema::Flags f,
                                                       ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const ::xercesc::DOMElement& e,
                                                       ::xml_schema::Flags f,
                                                       ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const ::xercesc::DOMAttr& a,
                                                       ::xml_schema::Flags f,
                                                       ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  TimedTextVirtualTrackType_TimedTextSequenceTypeType (const ::std::string& s,
                                                       const ::xercesc::DOMElement* e,
                                                       ::xml_schema::Flags f,
                                                       ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType* TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedTextVirtualTrackType_TimedTextSequenceTypeType (*this, f, c);
  }

  TimedTextVirtualTrackType_TimedTextSequenceTypeType::
  ~TimedTextVirtualTrackType_TimedTextSequenceTypeType ()
  {
  }

  // TimedTextVirtualTrackType_NamespaceURIType
  //

  TimedTextVirtualTrackType_NamespaceURIType::
  TimedTextVirtualTrackType_NamespaceURIType (const ::xml_schema::Uri& _xsd_Uri_base)
  : ::xml_schema::Uri (_xsd_Uri_base)
  {
  }

  TimedTextVirtualTrackType_NamespaceURIType::
  TimedTextVirtualTrackType_NamespaceURIType (const TimedTextVirtualTrackType_NamespaceURIType& x,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Uri (x, f, c)
  {
  }

  TimedTextVirtualTrackType_NamespaceURIType::
  TimedTextVirtualTrackType_NamespaceURIType (const ::xercesc::DOMElement& e,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Uri (e, f, c)
  {
  }

  TimedTextVirtualTrackType_NamespaceURIType::
  TimedTextVirtualTrackType_NamespaceURIType (const ::xercesc::DOMAttr& a,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Uri (a, f, c)
  {
  }

  TimedTextVirtualTrackType_NamespaceURIType::
  TimedTextVirtualTrackType_NamespaceURIType (const ::std::string& s,
                                              const ::xercesc::DOMElement* e,
                                              ::xml_schema::Flags f,
                                              ::xml_schema::Container* c)
  : ::xml_schema::Uri (s, e, f, c)
  {
  }

  TimedTextVirtualTrackType_NamespaceURIType* TimedTextVirtualTrackType_NamespaceURIType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedTextVirtualTrackType_NamespaceURIType (*this, f, c);
  }

  TimedTextVirtualTrackType_NamespaceURIType::
  ~TimedTextVirtualTrackType_NamespaceURIType ()
  {
  }

  // DeliverySpecificationList_DeliverableListType
  //

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType ()
  : ::xml_schema::Type (),
    Deliverable_ (this)
  {
  }

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType (const DeliverySpecificationList_DeliverableListType& x,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Deliverable_ (x.Deliverable_, f, this)
  {
  }

  DeliverySpecificationList_DeliverableListType::
  DeliverySpecificationList_DeliverableListType (const ::xercesc::DOMElement& e,
                                                 ::xml_schema::Flags f,
                                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Deliverable_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverySpecificationList_DeliverableListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Deliverable
      //
      if (n.name () == "Deliverable" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< DeliverableType > r (
          DeliverableTraits::create (i, f, this));

        this->Deliverable_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverySpecificationList_DeliverableListType* DeliverySpecificationList_DeliverableListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverySpecificationList_DeliverableListType (*this, f, c);
  }

  DeliverySpecificationList_DeliverableListType& DeliverySpecificationList_DeliverableListType::
  operator= (const DeliverySpecificationList_DeliverableListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Deliverable_ = x.Deliverable_;
    }

    return *this;
  }

  DeliverySpecificationList_DeliverableListType::
  ~DeliverySpecificationList_DeliverableListType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const MatchTypeType& MatchType,
                                                                                        const ValueListType& ValueList)
  : ::xml_schema::Type (),
    MatchType_ (MatchType, this),
    ValueList_ (ValueList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const MatchTypeType& MatchType,
                                                                                        ::std::auto_ptr< ValueListType > ValueList)
  : ::xml_schema::Type (),
    MatchType_ (MatchType, this),
    ValueList_ (ValueList, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& x,
                                                                                        ::xml_schema::Flags f,
                                                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MatchType_ (x.MatchType_, f, this),
    ValueList_ (x.ValueList_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (const ::xercesc::DOMElement& e,
                                                                                        ::xml_schema::Flags f,
                                                                                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MatchType_ (this),
    ValueList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MatchType
      //
      if (n.name () == "MatchType" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MatchTypeType > r (
          MatchTypeTraits::create (i, f, this));

        if (!MatchType_.present ())
        {
          this->MatchType_.set (r);
          continue;
        }
      }

      // ValueList
      //
      if (n.name () == "ValueList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ValueListType > r (
          ValueListTraits::create (i, f, this));

        if (!ValueList_.present ())
        {
          this->ValueList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MatchType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MatchType",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!ValueList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ValueList",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MatchType_ = x.MatchType_;
      this->ValueList_ = x.ValueList_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType ()
  : ::xml_schema::Type (),
    ImageVirtualTrack_ (this),
    MarkerVirtualTrack_ (this),
    AudioVirtualTrack_ (this),
    TimedTextVirtualTrack_ (this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& x,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ImageVirtualTrack_ (x.ImageVirtualTrack_, f, this),
    MarkerVirtualTrack_ (x.MarkerVirtualTrack_, f, this),
    AudioVirtualTrack_ (x.AudioVirtualTrack_, f, this),
    TimedTextVirtualTrack_ (x.TimedTextVirtualTrack_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ImageVirtualTrack_ (this),
    MarkerVirtualTrack_ (this),
    AudioVirtualTrack_ (this),
    TimedTextVirtualTrack_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ImageVirtualTrack
      //
      if (n.name () == "ImageVirtualTrack" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ImageVirtualTrackType > r (
          ImageVirtualTrackTraits::create (i, f, this));

        if (!this->ImageVirtualTrack_)
        {
          this->ImageVirtualTrack_.set (r);
          continue;
        }
      }

      // MarkerVirtualTrack
      //
      if (n.name () == "MarkerVirtualTrack" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MarkerVirtualTrackType > r (
          MarkerVirtualTrackTraits::create (i, f, this));

        if (!this->MarkerVirtualTrack_)
        {
          this->MarkerVirtualTrack_.set (r);
          continue;
        }
      }

      // AudioVirtualTrack
      //
      if (n.name () == "AudioVirtualTrack" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< AudioVirtualTrackType > r (
          AudioVirtualTrackTraits::create (i, f, this));

        this->AudioVirtualTrack_.push_back (r);
        continue;
      }

      // TimedTextVirtualTrack
      //
      if (n.name () == "TimedTextVirtualTrack" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< TimedTextVirtualTrackType > r (
          TimedTextVirtualTrackTraits::create (i, f, this));

        this->TimedTextVirtualTrack_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType* DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ImageVirtualTrack_ = x.ImageVirtualTrack_;
      this->MarkerVirtualTrack_ = x.MarkerVirtualTrack_;
      this->AudioVirtualTrack_ = x.AudioVirtualTrack_;
      this->TimedTextVirtualTrack_ = x.TimedTextVirtualTrack_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType ()
  {
  }

  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType
  //

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const NameType& Name,
                                                                                           const PropertyListType& PropertyList)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    PropertyList_ (PropertyList, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const NameType& Name,
                                                                                           ::std::auto_ptr< PropertyListType > PropertyList)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    PropertyList_ (PropertyList, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& x,
                                                                                           ::xml_schema::Flags f,
                                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    PropertyList_ (x.PropertyList_, f, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (const ::xercesc::DOMElement& e,
                                                                                           ::xml_schema::Flags f,
                                                                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    PropertyList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // PropertyList
      //
      if (n.name () == "PropertyList" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< PropertyListType > r (
          PropertyListTraits::create (i, f, this));

        if (!PropertyList_.present ())
        {
          this->PropertyList_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!PropertyList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PropertyList",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType* GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType (*this, f, c);
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  operator= (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->PropertyList_ = x.PropertyList_;
    }

    return *this;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType::
  ~GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType ()
  {
  }

  // GenericVirtualTrackType_TimelineComplexityType_SequenceType
  //

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType (const ResourceType& Resource)
  : ::xml_schema::Type (),
    Cardinality_ (this),
    Resource_ (Resource, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType (::std::auto_ptr< ResourceType > Resource)
  : ::xml_schema::Type (),
    Cardinality_ (this),
    Resource_ (Resource, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType (const GenericVirtualTrackType_TimelineComplexityType_SequenceType& x,
                                                               ::xml_schema::Flags f,
                                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Cardinality_ (x.Cardinality_, f, this),
    Resource_ (x.Resource_, f, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType (const ::xercesc::DOMElement& e,
                                                               ::xml_schema::Flags f,
                                                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Cardinality_ (this),
    Resource_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Cardinality
      //
      if (n.name () == "Cardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< CardinalityType > r (
          CardinalityTraits::create (i, f, this));

        if (!this->Cardinality_)
        {
          this->Cardinality_.set (r);
          continue;
        }
      }

      // Resource
      //
      if (n.name () == "Resource" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ResourceType > r (
          ResourceTraits::create (i, f, this));

        if (!Resource_.present ())
        {
          this->Resource_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Resource_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Resource",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType* GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_TimelineComplexityType_SequenceType (*this, f, c);
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType& GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  operator= (const GenericVirtualTrackType_TimelineComplexityType_SequenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Cardinality_ = x.Cardinality_;
      this->Resource_ = x.Resource_;
    }

    return *this;
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType::
  ~GenericVirtualTrackType_TimelineComplexityType_SequenceType ()
  {
  }

  // GenericVirtualTrackType_TimelineComplexityType_typeType
  //

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType ()
  : ::xml_schema::String ()
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const GenericVirtualTrackType_TimelineComplexityType_typeType& x,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const ::xercesc::DOMAttr& a,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  GenericVirtualTrackType_TimelineComplexityType_typeType (const ::std::string& s,
                                                           const ::xercesc::DOMElement* e,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType* GenericVirtualTrackType_TimelineComplexityType_typeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_TimelineComplexityType_typeType (*this, f, c);
  }

  GenericVirtualTrackType_TimelineComplexityType_typeType::
  ~GenericVirtualTrackType_TimelineComplexityType_typeType ()
  {
  }

  // AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType
  //

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType ()
  : ::xml_schema::String ()
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& x,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xercesc::DOMElement& e,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::xercesc::DOMAttr& a,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (const ::std::string& s,
                                                                           const ::xercesc::DOMElement* e,
                                                                           ::xml_schema::Flags f,
                                                                           ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType* AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType (*this, f, c);
  }

  AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType::
  ~AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType ()
  {
  }

  // AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType
  //

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType (const MCATagSymbolType& MCATagSymbol)
  : ::xml_schema::Type (),
    MCATagSymbol_ (MCATagSymbol, this)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType (const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType& x,
                                                                  ::xml_schema::Flags f,
                                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    MCATagSymbol_ (x.MCATagSymbol_, f, this)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType (const ::xercesc::DOMElement& e,
                                                                  ::xml_schema::Flags f,
                                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    MCATagSymbol_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MCATagSymbol
      //
      if (n.name () == "MCATagSymbol" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< MCATagSymbolType > r (
          MCATagSymbolTraits::create (i, f, this));

        if (!MCATagSymbol_.present ())
        {
          this->MCATagSymbol_.set (r);
          continue;
        }
      }

      break;
    }

    if (!MCATagSymbol_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "MCATagSymbol",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType* AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType (*this, f, c);
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType& AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  operator= (const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MCATagSymbol_ = x.MCATagSymbol_;
    }

    return *this;
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType::
  ~AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType ()
  {
  }

  // AudioVirtualTrackType_SampleRateListType_SampleRateType
  //

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType ()
  : ::dcml::RationalType ()
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType (const ::dcml::RationalType_base& _xsd_RationalType_base_base)
  : ::dcml::RationalType (_xsd_RationalType_base_base)
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType (const AudioVirtualTrackType_SampleRateListType_SampleRateType& x,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::dcml::RationalType (x, f, c)
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType (const ::xercesc::DOMElement& e,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::dcml::RationalType (e, f, c)
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType (const ::xercesc::DOMAttr& a,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::dcml::RationalType (a, f, c)
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  AudioVirtualTrackType_SampleRateListType_SampleRateType (const ::std::string& s,
                                                           const ::xercesc::DOMElement* e,
                                                           ::xml_schema::Flags f,
                                                           ::xml_schema::Container* c)
  : ::dcml::RationalType (s, e, f, c)
  {
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType* AudioVirtualTrackType_SampleRateListType_SampleRateType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_SampleRateListType_SampleRateType (*this, f, c);
  }

  AudioVirtualTrackType_SampleRateListType_SampleRateType::
  ~AudioVirtualTrackType_SampleRateListType_SampleRateType ()
  {
  }

  // ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType
  //

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (const ::xml_schema::Integer& _xsd_Integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (_xsd_Integer_base)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (const ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType& x,
                                                                 ::xml_schema::Flags f,
                                                                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (x, f, c)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (const ::xercesc::DOMElement& e,
                                                                 ::xml_schema::Flags f,
                                                                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (e, f, c)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (const ::xercesc::DOMAttr& a,
                                                                 ::xml_schema::Flags f,
                                                                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (a, f, c)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (const ::std::string& s,
                                                                 const ::xercesc::DOMElement* e,
                                                                 ::xml_schema::Flags f,
                                                                 ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType > (s, e, f, c)
  {
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType* ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType (*this, f, c);
  }

  ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType::
  ~ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType ()
  {
  }

  // MarkerVirtualTrackType_MarkerListType_MarkerType
  //

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType ()
  : ::xml_schema::String ()
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const MarkerVirtualTrackType_MarkerListType_MarkerType& x,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const ::xercesc::DOMElement& e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const ::xercesc::DOMAttr& a,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  MarkerVirtualTrackType_MarkerListType_MarkerType (const ::std::string& s,
                                                    const ::xercesc::DOMElement* e,
                                                    ::xml_schema::Flags f,
                                                    ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType* MarkerVirtualTrackType_MarkerListType_MarkerType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerVirtualTrackType_MarkerListType_MarkerType (*this, f, c);
  }

  MarkerVirtualTrackType_MarkerListType_MarkerType::
  ~MarkerVirtualTrackType_MarkerListType_MarkerType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType ()
  : ::xml_schema::String ()
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& x,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xercesc::DOMElement& e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::xercesc::DOMAttr& a,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (const ::std::string& s,
                                                                                                      const ::xercesc::DOMElement* e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType ()
  {
  }

  // DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType
  //

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType ()
  : ::xml_schema::Type (),
    ApplicationIdentification_ (this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& x,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ApplicationIdentification_ (x.ApplicationIdentification_, f, this)
  {
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (const ::xercesc::DOMElement& e,
                                                                                                      ::xml_schema::Flags f,
                                                                                                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ApplicationIdentification_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ApplicationIdentification
      //
      if (n.name () == "ApplicationIdentification" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ApplicationIdentificationType > r (
          ApplicationIdentificationTraits::create (i, f, this));

        this->ApplicationIdentification_.push_back (r);
        continue;
      }

      break;
    }
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType* DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType (*this, f, c);
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  operator= (const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ApplicationIdentification_ = x.ApplicationIdentification_;
    }

    return *this;
  }

  DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::
  ~DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType ()
  {
  }

  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType
  //

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType ()
  : ::xml_schema::Type (),
    Property_ (this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& x,
                                                                                                            ::xml_schema::Flags f,
                                                                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Property_ (x.Property_, f, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (const ::xercesc::DOMElement& e,
                                                                                                            ::xml_schema::Flags f,
                                                                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Property_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Property
      //
      if (n.name () == "Property" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< PropertyType > r (
          PropertyTraits::create (i, f, this));

        this->Property_.push_back (r);
        continue;
      }

      break;
    }
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType* GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType (*this, f, c);
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  operator= (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Property_ = x.Property_;
    }

    return *this;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::
  ~GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType ()
  {
  }

  // GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType
  //

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType ()
  : ::xml_schema::Type (),
    Cardinality_ (this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (const GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& x,
                                                                            ::xml_schema::Flags f,
                                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Cardinality_ (x.Cardinality_, f, this)
  {
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (const ::xercesc::DOMElement& e,
                                                                            ::xml_schema::Flags f,
                                                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Cardinality_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Cardinality
      //
      if (n.name () == "Cardinality" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< CardinalityType > r (
          CardinalityTraits::create (i, f, this));

        if (!this->Cardinality_)
        {
          this->Cardinality_.set (r);
          continue;
        }
      }

      break;
    }
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType* GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType (*this, f, c);
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  operator= (const GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Cardinality_ = x.Cardinality_;
    }

    return *this;
  }

  GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType::
  ~GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType ()
  {
  }

  // AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType
  //

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType ()
  : ::xml_schema::String ()
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& x,
                                                                                   ::xml_schema::Flags f,
                                                                                   ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xercesc::DOMElement& e,
                                                                                   ::xml_schema::Flags f,
                                                                                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::xercesc::DOMAttr& a,
                                                                                   ::xml_schema::Flags f,
                                                                                   ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (const ::std::string& s,
                                                                                   const ::xercesc::DOMElement* e,
                                                                                   ::xml_schema::Flags f,
                                                                                   ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType* AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType (*this, f, c);
  }

  AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType::
  ~AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType ()
  {
  }

  // GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType
  //

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const NameType& Name,
                                                                                                                         const ValueType& value)
  : ::xml_schema::Type (),
    Name_ (Name, this),
    value_ (value, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& x,
                                                                                                                         ::xml_schema::Flags f,
                                                                                                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Name_ (x.Name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (const ::xercesc::DOMElement& e,
                                                                                                                         ::xml_schema::Flags f,
                                                                                                                         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Name_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Name
      //
      if (n.name () == "Name" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< NameType > r (
          NameTraits::create (i, f, this));

        if (!Name_.present ())
        {
          this->Name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
      {
        ::std::auto_ptr< ValueType > r (
          ValueTraits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!Name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Name",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType* GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType (*this, f, c);
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  operator= (const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Name_ = x.Name_;
      this->value_ = x.value_;
    }

    return *this;
  }

  GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType::
  ~GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType ()
  {
  }
}

#include <ostream>

namespace dsl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    o << ::std::endl << "Label: " << i.getLabel ();
    o << ::std::endl << "CompositionPlaylistConstraints: " << i.getCompositionPlaylistConstraints ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType& i)
  {
    if (i.getEssenceEncodingConstraintList ())
    {
      o << ::std::endl << "EssenceEncodingConstraintList: " << *i.getEssenceEncodingConstraintList ();
    }

    for (GenericVirtualTrackType::TimelineComplexityConstIterator
         b (i.getTimelineComplexity ().begin ()), e (i.getTimelineComplexity ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "TimelineComplexity: " << *b;
    }

    if (i.getReferenceCardinality ())
    {
      o << ::std::endl << "ReferenceCardinality: " << *i.getReferenceCardinality ();
    }

    if (i.getNamespace ())
    {
      o << ::std::endl << "namespace: " << *i.getNamespace ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType& i)
  {
    o << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    o << ::std::endl << "EssenceEncoding: " << i.getEssenceEncoding ();
    if (i.getSoundfieldGroupConfiguration ())
    {
      o << ::std::endl << "SoundfieldGroupConfiguration: " << *i.getSoundfieldGroupConfiguration ();
    }

    if (i.getAudioChannelMapping ())
    {
      o << ::std::endl << "AudioChannelMapping: " << *i.getAudioChannelMapping ();
    }

    if (i.getSampleRateList ())
    {
      o << ::std::endl << "SampleRateList: " << *i.getSampleRateList ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType& i)
  {
    o << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    o << ::std::endl << "EssenceEncoding: " << i.getEssenceEncoding ();
    if (i.getColorimetry ())
    {
      o << ::std::endl << "Colorimetry: " << *i.getColorimetry ();
    }

    if (i.getSampling ())
    {
      o << ::std::endl << "Sampling: " << *i.getSampling ();
    }

    if (i.getQuantization ())
    {
      o << ::std::endl << "Quantization: " << *i.getQuantization ();
    }

    if (i.getFrameStructure ())
    {
      o << ::std::endl << "FrameStructure: " << *i.getFrameStructure ();
    }

    if (i.getStereoscopy ())
    {
      o << ::std::endl << "Stereoscopy: " << *i.getStereoscopy ();
    }

    if (i.getColorComponents ())
    {
      o << ::std::endl << "ColorComponents: " << *i.getColorComponents ();
    }

    if (i.getPixelBitDepthList ())
    {
      o << ::std::endl << "PixelBitDepthList: " << *i.getPixelBitDepthList ();
    }

    if (i.getImageFrameWidthList ())
    {
      o << ::std::endl << "ImageFrameWidthList: " << *i.getImageFrameWidthList ();
    }

    if (i.getImageFrameHeightList ())
    {
      o << ::std::endl << "ImageFrameHeightList: " << *i.getImageFrameHeightList ();
    }

    if (i.getFrameRateList ())
    {
      o << ::std::endl << "FrameRateList: " << *i.getFrameRateList ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType& i)
  {
    o << ::std::endl << "MinItem: " << i.getMinItem ();
    o << ::std::endl << "MaxItem: " << i.getMaxItem ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerVirtualTrackType& i)
  {
    o << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    if (i.getMarkerList ())
    {
      o << ::std::endl << "MarkerList: " << *i.getMarkerList ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimedTextVirtualTrackType& i)
  {
    o << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    o << ::std::endl << "TimedTextSequenceType: " << i.getTimedTextSequenceType ();
    if (i.getNamespaceURI ())
    {
      o << ::std::endl << "NamespaceURI: " << *i.getNamespaceURI ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverySpecificationList& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    if (i.getAnnotationText ())
    {
      o << ::std::endl << "AnnotationText: " << *i.getAnnotationText ();
    }

    o << ::std::endl << "IssueDate: " << i.getIssueDate ();
    if (i.getIssuer ())
    {
      o << ::std::endl << "Issuer: " << *i.getIssuer ();
    }

    if (i.getCreator ())
    {
      o << ::std::endl << "Creator: " << *i.getCreator ();
    }

    o << ::std::endl << "DeliverableList: " << i.getDeliverableList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_LabelType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType& i)
  {
    o << ::std::endl << "OwnerId: " << i.getOwnerId ();
    if (i.getApplicationIdentificationList ())
    {
      o << ::std::endl << "ApplicationIdentificationList: " << *i.getApplicationIdentificationList ();
    }

    if (i.getApplicationIdentification ())
    {
      o << ::std::endl << "ApplicationIdentification: " << *i.getApplicationIdentification ();
    }

    if (i.getSegmentCardinality ())
    {
      o << ::std::endl << "SegmentCardinality: " << *i.getSegmentCardinality ();
    }

    o << ::std::endl << "VirtualTrackList: " << i.getVirtualTrackList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_EssenceEncodingConstraintListType& i)
  {
    for (GenericVirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintConstIterator
         b (i.getEssenceEncodingConstraint ().begin ()), e (i.getEssenceEncodingConstraint ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "EssenceEncodingConstraint: " << *b;
    }

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_TimelineComplexityType& i)
  {
    if (i.getSequenceCardinality ())
    {
      o << ::std::endl << "SequenceCardinality: " << *i.getSequenceCardinality ();
    }

    if (i.getResourceCardinality ())
    {
      o << ::std::endl << "ResourceCardinality: " << *i.getResourceCardinality ();
    }

    o << ::std::endl << "Sequence: " << i.getSequence ();
    o << ::std::endl << "type: " << i.getType ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_ReferenceCardinalityType& i)
  {
    o << ::std::endl << "Sequence: " << i.getSequence ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_namespaceType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_EssenceEncodingType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_SoundfieldGroupConfigurationType& i)
  {
    o << ::std::endl << "MCATagSymbol: " << i.getMCATagSymbol ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_AudioChannelMappingType& i)
  {
    for (AudioVirtualTrackType_AudioChannelMappingType::AudioChannelConstIterator
         b (i.getAudioChannel ().begin ()), e (i.getAudioChannel ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "AudioChannel: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_SampleRateListType& i)
  {
    for (AudioVirtualTrackType_SampleRateListType::SampleRateConstIterator
         b (i.getSampleRate ().begin ()), e (i.getSampleRate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "SampleRate: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_EssenceEncodingType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_ColorimetryType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_SamplingType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_QuantizationType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_FrameStructureType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_StereoscopyType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_ColorComponentsType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_PixelBitDepthListType& i)
  {
    for (ImageVirtualTrackType_PixelBitDepthListType::PixelBitDepthConstIterator
         b (i.getPixelBitDepth ().begin ()), e (i.getPixelBitDepth ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "PixelBitDepth: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_ImageFrameWidthListType& i)
  {
    for (ImageVirtualTrackType_ImageFrameWidthListType::ImageFrameWidthConstIterator
         b (i.getImageFrameWidth ().begin ()), e (i.getImageFrameWidth ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ImageFrameWidth: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_ImageFrameHeightListType& i)
  {
    for (ImageVirtualTrackType_ImageFrameHeightListType::ImageFrameHeightConstIterator
         b (i.getImageFrameHeight ().begin ()), e (i.getImageFrameHeight ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ImageFrameHeight: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_FrameRateListType& i)
  {
    for (ImageVirtualTrackType_FrameRateListType::FrameRateConstIterator
         b (i.getFrameRate ().begin ()), e (i.getFrameRate ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "FrameRate: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType_MinItemType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CardinalityType_MaxItemType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerVirtualTrackType_MarkerListType& i)
  {
    for (MarkerVirtualTrackType_MarkerListType::MarkerConstIterator
         b (i.getMarker ().begin ()), e (i.getMarker ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Marker: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimedTextVirtualTrackType_TimedTextSequenceTypeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimedTextVirtualTrackType_NamespaceURIType& i)
  {
    o << static_cast< const ::xml_schema::Uri& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverySpecificationList_DeliverableListType& i)
  {
    for (DeliverySpecificationList_DeliverableListType::DeliverableConstIterator
         b (i.getDeliverable ().begin ()), e (i.getDeliverable ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Deliverable: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& i)
  {
    o << ::std::endl << "MatchType: " << i.getMatchType ();
    o << ::std::endl << "ValueList: " << i.getValueList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& i)
  {
    if (i.getImageVirtualTrack ())
    {
      o << ::std::endl << "ImageVirtualTrack: " << *i.getImageVirtualTrack ();
    }

    if (i.getMarkerVirtualTrack ())
    {
      o << ::std::endl << "MarkerVirtualTrack: " << *i.getMarkerVirtualTrack ();
    }

    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::AudioVirtualTrackConstIterator
         b (i.getAudioVirtualTrack ().begin ()), e (i.getAudioVirtualTrack ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "AudioVirtualTrack: " << *b;
    }

    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::TimedTextVirtualTrackConstIterator
         b (i.getTimedTextVirtualTrack ().begin ()), e (i.getTimedTextVirtualTrack ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "TimedTextVirtualTrack: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& i)
  {
    o << ::std::endl << "Name: " << i.getName ();
    o << ::std::endl << "PropertyList: " << i.getPropertyList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_TimelineComplexityType_SequenceType& i)
  {
    if (i.getCardinality ())
    {
      o << ::std::endl << "Cardinality: " << *i.getCardinality ();
    }

    o << ::std::endl << "Resource: " << i.getResource ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_TimelineComplexityType_typeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType& i)
  {
    o << ::std::endl << "MCATagSymbol: " << i.getMCATagSymbol ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_SampleRateListType_SampleRateType& i)
  {
    o << static_cast< const ::dcml::RationalType& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType& i)
  {
    o << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerVirtualTrackType_MarkerListType_MarkerType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& i)
  {
    for (DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationConstIterator
         b (i.getApplicationIdentification ().begin ()), e (i.getApplicationIdentification ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ApplicationIdentification: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& i)
  {
    for (GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertyConstIterator
         b (i.getProperty ().begin ()), e (i.getProperty ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Property: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& i)
  {
    if (i.getCardinality ())
    {
      o << ::std::endl << "Cardinality: " << *i.getCardinality ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& i)
  {
    o << ::std::endl << "Name: " << i.getName ();
    o << ::std::endl << "value: " << i.getValue ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dsl
{
  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::std::string& u,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::std::istream& is,
                                  const ::std::string& sid,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dsl::parseDeliverySpecificationList (isrc, h, f, p);
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xml_schema::ErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xercesc::InputSource& i,
                                  ::xercesc::DOMErrorHandler& h,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
      ::dsl::parseDeliverySpecificationList (
        d, f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (const ::xercesc::DOMDocument& doc,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::dsl::DeliverySpecificationList > (
        ::dsl::parseDeliverySpecificationList (
          d, f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
    {
      ::std::auto_ptr< ::dsl::DeliverySpecificationList > r (
        ::xsd::cxx::tree::traits< ::dsl::DeliverySpecificationList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DeliverySpecificationList",
      "http://www.imfug.com/ns/delivery-schema/2019");
  }

  ::std::auto_ptr< ::dsl::DeliverySpecificationList >
  parseDeliverySpecificationList (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                                  ::xml_schema::Flags f,
                                  const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
    {
      ::std::auto_ptr< ::dsl::DeliverySpecificationList > r (
        ::xsd::cxx::tree::traits< ::dsl::DeliverySpecificationList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DeliverySpecificationList",
      "http://www.imfug.com/ns/delivery-schema/2019");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace dsl
{
  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::std::ostream& o,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::ErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::XMLFormatTarget& t,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xercesc::DOMErrorHandler& h,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      const ::std::string& e,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::dsl::serializeDeliverySpecificationList (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeDeliverySpecificationList (::xercesc::DOMDocument& d,
                                      const ::dsl::DeliverySpecificationList& s,
                                      ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DeliverySpecificationList" &&
        n.namespace_ () == "http://www.imfug.com/ns/delivery-schema/2019")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "DeliverySpecificationList",
        "http://www.imfug.com/ns/delivery-schema/2019");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  serializeDeliverySpecificationList (const ::dsl::DeliverySpecificationList& s,
                                      const ::xml_schema::NamespaceInfomap& m,
                                      ::xml_schema::Flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "DeliverySpecificationList",
        "http://www.imfug.com/ns/delivery-schema/2019",
        m, f));

    ::dsl::serializeDeliverySpecificationList (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getId ();
    }

    // Label
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Label",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getLabel ();
    }

    // CompositionPlaylistConstraints
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CompositionPlaylistConstraints",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getCompositionPlaylistConstraints ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EssenceEncodingConstraintList
    //
    if (i.getEssenceEncodingConstraintList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncodingConstraintList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getEssenceEncodingConstraintList ();
    }

    // TimelineComplexity
    //
    for (GenericVirtualTrackType::TimelineComplexityConstIterator
         b (i.getTimelineComplexity ().begin ()), n (i.getTimelineComplexity ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimelineComplexity",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }

    // ReferenceCardinality
    //
    if (i.getReferenceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ReferenceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getReferenceCardinality ();
    }

    // namespace
    //
    if (i.getNamespace ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "namespace",
          e));

      a << *i.getNamespace ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType& i)
  {
    e << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    // EssenceEncoding
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncoding",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getEssenceEncoding ();
    }

    // SoundfieldGroupConfiguration
    //
    if (i.getSoundfieldGroupConfiguration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SoundfieldGroupConfiguration",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getSoundfieldGroupConfiguration ();
    }

    // AudioChannelMapping
    //
    if (i.getAudioChannelMapping ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AudioChannelMapping",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getAudioChannelMapping ();
    }

    // SampleRateList
    //
    if (i.getSampleRateList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SampleRateList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getSampleRateList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType& i)
  {
    e << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    // EssenceEncoding
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncoding",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getEssenceEncoding ();
    }

    // Colorimetry
    //
    if (i.getColorimetry ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Colorimetry",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getColorimetry ();
    }

    // Sampling
    //
    if (i.getSampling ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sampling",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getSampling ();
    }

    // Quantization
    //
    if (i.getQuantization ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Quantization",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getQuantization ();
    }

    // FrameStructure
    //
    if (i.getFrameStructure ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameStructure",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getFrameStructure ();
    }

    // Stereoscopy
    //
    if (i.getStereoscopy ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Stereoscopy",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getStereoscopy ();
    }

    // ColorComponents
    //
    if (i.getColorComponents ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ColorComponents",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getColorComponents ();
    }

    // PixelBitDepthList
    //
    if (i.getPixelBitDepthList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PixelBitDepthList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getPixelBitDepthList ();
    }

    // ImageFrameWidthList
    //
    if (i.getImageFrameWidthList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameWidthList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getImageFrameWidthList ();
    }

    // ImageFrameHeightList
    //
    if (i.getImageFrameHeightList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameHeightList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getImageFrameHeightList ();
    }

    // FrameRateList
    //
    if (i.getFrameRateList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameRateList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getFrameRateList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MinItem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MinItem",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getMinItem ();
    }

    // MaxItem
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MaxItem",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getMaxItem ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MarkerVirtualTrackType& i)
  {
    e << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    // MarkerList
    //
    if (i.getMarkerList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MarkerList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getMarkerList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimedTextVirtualTrackType& i)
  {
    e << static_cast< const ::dsl::GenericVirtualTrackType& > (i);

    // TimedTextSequenceType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimedTextSequenceType",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getTimedTextSequenceType ();
    }

    // NamespaceURI
    //
    if (i.getNamespaceURI ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "NamespaceURI",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getNamespaceURI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverySpecificationList& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getId ();
    }

    // AnnotationText
    //
    if (i.getAnnotationText ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AnnotationText",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getAnnotationText ();
    }

    // IssueDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IssueDate",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getIssueDate ();
    }

    // Issuer
    //
    if (i.getIssuer ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Issuer",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getIssuer ();
    }

    // Creator
    //
    if (i.getCreator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Creator",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getCreator ();
    }

    // DeliverableList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "DeliverableList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getDeliverableList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_LabelType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeliverableType_LabelType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeliverableType_LabelType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // OwnerId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "OwnerId",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getOwnerId ();
    }

    // ApplicationIdentificationList
    //
    if (i.getApplicationIdentificationList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentificationList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getApplicationIdentificationList ();
    }

    // ApplicationIdentification
    //
    if (i.getApplicationIdentification ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentification",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getApplicationIdentification ();
    }

    // SegmentCardinality
    //
    if (i.getSegmentCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SegmentCardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getSegmentCardinality ();
    }

    // VirtualTrackList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "VirtualTrackList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getVirtualTrackList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_EssenceEncodingConstraintListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EssenceEncodingConstraint
    //
    for (GenericVirtualTrackType_EssenceEncodingConstraintListType::EssenceEncodingConstraintConstIterator
         b (i.getEssenceEncodingConstraint ().begin ()), n (i.getEssenceEncodingConstraint ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceEncodingConstraint",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_TimelineComplexityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SequenceCardinality
    //
    if (i.getSequenceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SequenceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getSequenceCardinality ();
    }

    // ResourceCardinality
    //
    if (i.getResourceCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ResourceCardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getResourceCardinality ();
    }

    // Sequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sequence",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getSequence ();
    }

    // type
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "type",
          e));

      a << i.getType ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_ReferenceCardinalityType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Sequence
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Sequence",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getSequence ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_namespaceType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const GenericVirtualTrackType_namespaceType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const GenericVirtualTrackType_namespaceType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_EssenceEncodingType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AudioVirtualTrackType_EssenceEncodingType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AudioVirtualTrackType_EssenceEncodingType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_SoundfieldGroupConfigurationType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MCATagSymbol
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MCATagSymbol",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getMCATagSymbol ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_AudioChannelMappingType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // AudioChannel
    //
    for (AudioVirtualTrackType_AudioChannelMappingType::AudioChannelConstIterator
         b (i.getAudioChannel ().begin ()), n (i.getAudioChannel ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AudioChannel",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_SampleRateListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // SampleRate
    //
    for (AudioVirtualTrackType_SampleRateListType::SampleRateConstIterator
         b (i.getSampleRate ().begin ()), n (i.getSampleRate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SampleRate",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_EssenceEncodingType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_EssenceEncodingType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_EssenceEncodingType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_ColorimetryType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_ColorimetryType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_ColorimetryType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_SamplingType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_SamplingType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_SamplingType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_QuantizationType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_QuantizationType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_QuantizationType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_FrameStructureType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_FrameStructureType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_FrameStructureType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_StereoscopyType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_StereoscopyType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_StereoscopyType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_ColorComponentsType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_ColorComponentsType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_ColorComponentsType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_PixelBitDepthListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // PixelBitDepth
    //
    for (ImageVirtualTrackType_PixelBitDepthListType::PixelBitDepthConstIterator
         b (i.getPixelBitDepth ().begin ()), n (i.getPixelBitDepth ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PixelBitDepth",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_ImageFrameWidthListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ImageFrameWidth
    //
    for (ImageVirtualTrackType_ImageFrameWidthListType::ImageFrameWidthConstIterator
         b (i.getImageFrameWidth ().begin ()), n (i.getImageFrameWidth ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameWidth",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_ImageFrameHeightListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ImageFrameHeight
    //
    for (ImageVirtualTrackType_ImageFrameHeightListType::ImageFrameHeightConstIterator
         b (i.getImageFrameHeight ().begin ()), n (i.getImageFrameHeight ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageFrameHeight",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_FrameRateListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // FrameRate
    //
    for (ImageVirtualTrackType_FrameRateListType::FrameRateConstIterator
         b (i.getFrameRate ().begin ()), n (i.getFrameRate ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "FrameRate",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType_MinItemType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CardinalityType_MinItemType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CardinalityType_MinItemType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CardinalityType_MaxItemType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CardinalityType_MaxItemType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CardinalityType_MaxItemType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MarkerVirtualTrackType_MarkerListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Marker
    //
    for (MarkerVirtualTrackType_MarkerListType::MarkerConstIterator
         b (i.getMarker ().begin ()), n (i.getMarker ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Marker",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimedTextVirtualTrackType_TimedTextSequenceTypeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimedTextVirtualTrackType_TimedTextSequenceTypeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimedTextVirtualTrackType_TimedTextSequenceTypeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimedTextVirtualTrackType_NamespaceURIType& i)
  {
    e << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimedTextVirtualTrackType_NamespaceURIType& i)
  {
    a << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimedTextVirtualTrackType_NamespaceURIType& i)
  {
    l << static_cast< const ::xml_schema::Uri& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverySpecificationList_DeliverableListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Deliverable
    //
    for (DeliverySpecificationList_DeliverableListType::DeliverableConstIterator
         b (i.getDeliverable ().begin ()), n (i.getDeliverable ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Deliverable",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MatchType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MatchType",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getMatchType ();
    }

    // ValueList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ValueList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getValueList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ImageVirtualTrack
    //
    if (i.getImageVirtualTrack ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ImageVirtualTrack",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getImageVirtualTrack ();
    }

    // MarkerVirtualTrack
    //
    if (i.getMarkerVirtualTrack ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MarkerVirtualTrack",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getMarkerVirtualTrack ();
    }

    // AudioVirtualTrack
    //
    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::AudioVirtualTrackConstIterator
         b (i.getAudioVirtualTrack ().begin ()), n (i.getAudioVirtualTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AudioVirtualTrack",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }

    // TimedTextVirtualTrack
    //
    for (DeliverableType_CompositionPlaylistConstraintsType_VirtualTrackListType::TimedTextVirtualTrackConstIterator
         b (i.getTimedTextVirtualTrack ().begin ()), n (i.getTimedTextVirtualTrack ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimedTextVirtualTrack",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getName ();
    }

    // PropertyList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "PropertyList",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getPropertyList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_TimelineComplexityType_SequenceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Cardinality
    //
    if (i.getCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Cardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getCardinality ();
    }

    // Resource
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Resource",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getResource ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_TimelineComplexityType_typeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const GenericVirtualTrackType_TimelineComplexityType_typeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const GenericVirtualTrackType_TimelineComplexityType_typeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AudioVirtualTrackType_SoundfieldGroupConfigurationType_MCATagSymbolType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MCATagSymbol
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MCATagSymbol",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getMCATagSymbol ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_SampleRateListType_SampleRateType& i)
  {
    e << static_cast< const ::dcml::RationalType& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AudioVirtualTrackType_SampleRateListType_SampleRateType& i)
  {
    a << static_cast< const ::dcml::RationalType& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AudioVirtualTrackType_SampleRateListType_SampleRateType& i)
  {
    l << static_cast< const ::dcml::RationalType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const ImageVirtualTrackType_PixelBitDepthListType_PixelBitDepthType& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::Integer, char, ::xml_schema::SimpleType >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const MarkerVirtualTrackType_MarkerListType_MarkerType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const MarkerVirtualTrackType_MarkerListType_MarkerType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const MarkerVirtualTrackType_MarkerListType_MarkerType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_MatchTypeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ApplicationIdentification
    //
    for (DeliverableType_CompositionPlaylistConstraintsType_ApplicationIdentificationListType_ValueListType::ApplicationIdentificationConstIterator
         b (i.getApplicationIdentification ().begin ()), n (i.getApplicationIdentification ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ApplicationIdentification",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Property
    //
    for (GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType::PropertyConstIterator
         b (i.getProperty ().begin ()), n (i.getProperty ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Property",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_TimelineComplexityType_SequenceType_ResourceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Cardinality
    //
    if (i.getCardinality ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Cardinality",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << *i.getCardinality ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const AudioVirtualTrackType_AudioChannelMappingType_AudioChannelType_MCATagSymbolType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const GenericVirtualTrackType_EssenceEncodingConstraintListType_EssenceEncodingConstraintType_PropertyListType_PropertyType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Name",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getName ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.imfug.com/ns/delivery-schema/2019",
          e));

      s << i.getValue ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

