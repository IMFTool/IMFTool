// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SMPTE-2067-3-2013-CPL.h"

namespace cpl
{
  // CompositionPlaylistType
  // 

  const CompositionPlaylistType::IdType& CompositionPlaylistType::
  getId () const
  {
    return this->Id_.get ();
  }

  CompositionPlaylistType::IdType& CompositionPlaylistType::
  getId ()
  {
    return this->Id_.get ();
  }

  void CompositionPlaylistType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void CompositionPlaylistType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const CompositionPlaylistType::AnnotationOptional& CompositionPlaylistType::
  getAnnotation () const
  {
    return this->Annotation_;
  }

  CompositionPlaylistType::AnnotationOptional& CompositionPlaylistType::
  getAnnotation ()
  {
    return this->Annotation_;
  }

  void CompositionPlaylistType::
  setAnnotation (const AnnotationType& x)
  {
    this->Annotation_.set (x);
  }

  void CompositionPlaylistType::
  setAnnotation (const AnnotationOptional& x)
  {
    this->Annotation_ = x;
  }

  void CompositionPlaylistType::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->Annotation_.set (std::move (x));
  }

  const CompositionPlaylistType::IssueDateType& CompositionPlaylistType::
  getIssueDate () const
  {
    return this->IssueDate_.get ();
  }

  CompositionPlaylistType::IssueDateType& CompositionPlaylistType::
  getIssueDate ()
  {
    return this->IssueDate_.get ();
  }

  void CompositionPlaylistType::
  setIssueDate (const IssueDateType& x)
  {
    this->IssueDate_.set (x);
  }

  void CompositionPlaylistType::
  setIssueDate (::std::unique_ptr< IssueDateType > x)
  {
    this->IssueDate_.set (std::move (x));
  }

  const CompositionPlaylistType::IssuerOptional& CompositionPlaylistType::
  getIssuer () const
  {
    return this->Issuer_;
  }

  CompositionPlaylistType::IssuerOptional& CompositionPlaylistType::
  getIssuer ()
  {
    return this->Issuer_;
  }

  void CompositionPlaylistType::
  setIssuer (const IssuerType& x)
  {
    this->Issuer_.set (x);
  }

  void CompositionPlaylistType::
  setIssuer (const IssuerOptional& x)
  {
    this->Issuer_ = x;
  }

  void CompositionPlaylistType::
  setIssuer (::std::unique_ptr< IssuerType > x)
  {
    this->Issuer_.set (std::move (x));
  }

  const CompositionPlaylistType::CreatorOptional& CompositionPlaylistType::
  getCreator () const
  {
    return this->Creator_;
  }

  CompositionPlaylistType::CreatorOptional& CompositionPlaylistType::
  getCreator ()
  {
    return this->Creator_;
  }

  void CompositionPlaylistType::
  setCreator (const CreatorType& x)
  {
    this->Creator_.set (x);
  }

  void CompositionPlaylistType::
  setCreator (const CreatorOptional& x)
  {
    this->Creator_ = x;
  }

  void CompositionPlaylistType::
  setCreator (::std::unique_ptr< CreatorType > x)
  {
    this->Creator_.set (std::move (x));
  }

  const CompositionPlaylistType::ContentOriginatorOptional& CompositionPlaylistType::
  getContentOriginator () const
  {
    return this->ContentOriginator_;
  }

  CompositionPlaylistType::ContentOriginatorOptional& CompositionPlaylistType::
  getContentOriginator ()
  {
    return this->ContentOriginator_;
  }

  void CompositionPlaylistType::
  setContentOriginator (const ContentOriginatorType& x)
  {
    this->ContentOriginator_.set (x);
  }

  void CompositionPlaylistType::
  setContentOriginator (const ContentOriginatorOptional& x)
  {
    this->ContentOriginator_ = x;
  }

  void CompositionPlaylistType::
  setContentOriginator (::std::unique_ptr< ContentOriginatorType > x)
  {
    this->ContentOriginator_.set (std::move (x));
  }

  const CompositionPlaylistType::ContentTitleType& CompositionPlaylistType::
  getContentTitle () const
  {
    return this->ContentTitle_.get ();
  }

  CompositionPlaylistType::ContentTitleType& CompositionPlaylistType::
  getContentTitle ()
  {
    return this->ContentTitle_.get ();
  }

  void CompositionPlaylistType::
  setContentTitle (const ContentTitleType& x)
  {
    this->ContentTitle_.set (x);
  }

  void CompositionPlaylistType::
  setContentTitle (::std::unique_ptr< ContentTitleType > x)
  {
    this->ContentTitle_.set (std::move (x));
  }

  const CompositionPlaylistType::ContentKindOptional& CompositionPlaylistType::
  getContentKind () const
  {
    return this->ContentKind_;
  }

  CompositionPlaylistType::ContentKindOptional& CompositionPlaylistType::
  getContentKind ()
  {
    return this->ContentKind_;
  }

  void CompositionPlaylistType::
  setContentKind (const ContentKindType& x)
  {
    this->ContentKind_.set (x);
  }

  void CompositionPlaylistType::
  setContentKind (const ContentKindOptional& x)
  {
    this->ContentKind_ = x;
  }

  void CompositionPlaylistType::
  setContentKind (::std::unique_ptr< ContentKindType > x)
  {
    this->ContentKind_.set (std::move (x));
  }

  const CompositionPlaylistType::ContentVersionListOptional& CompositionPlaylistType::
  getContentVersionList () const
  {
    return this->ContentVersionList_;
  }

  CompositionPlaylistType::ContentVersionListOptional& CompositionPlaylistType::
  getContentVersionList ()
  {
    return this->ContentVersionList_;
  }

  void CompositionPlaylistType::
  setContentVersionList (const ContentVersionListType& x)
  {
    this->ContentVersionList_.set (x);
  }

  void CompositionPlaylistType::
  setContentVersionList (const ContentVersionListOptional& x)
  {
    this->ContentVersionList_ = x;
  }

  void CompositionPlaylistType::
  setContentVersionList (::std::unique_ptr< ContentVersionListType > x)
  {
    this->ContentVersionList_.set (std::move (x));
  }

  const CompositionPlaylistType::EssenceDescriptorListOptional& CompositionPlaylistType::
  getEssenceDescriptorList () const
  {
    return this->EssenceDescriptorList_;
  }

  CompositionPlaylistType::EssenceDescriptorListOptional& CompositionPlaylistType::
  getEssenceDescriptorList ()
  {
    return this->EssenceDescriptorList_;
  }

  void CompositionPlaylistType::
  setEssenceDescriptorList (const EssenceDescriptorListType& x)
  {
    this->EssenceDescriptorList_.set (x);
  }

  void CompositionPlaylistType::
  setEssenceDescriptorList (const EssenceDescriptorListOptional& x)
  {
    this->EssenceDescriptorList_ = x;
  }

  void CompositionPlaylistType::
  setEssenceDescriptorList (::std::unique_ptr< EssenceDescriptorListType > x)
  {
    this->EssenceDescriptorList_.set (std::move (x));
  }

  const CompositionPlaylistType::CompositionTimecodeOptional& CompositionPlaylistType::
  getCompositionTimecode () const
  {
    return this->CompositionTimecode_;
  }

  CompositionPlaylistType::CompositionTimecodeOptional& CompositionPlaylistType::
  getCompositionTimecode ()
  {
    return this->CompositionTimecode_;
  }

  void CompositionPlaylistType::
  setCompositionTimecode (const CompositionTimecodeType& x)
  {
    this->CompositionTimecode_.set (x);
  }

  void CompositionPlaylistType::
  setCompositionTimecode (const CompositionTimecodeOptional& x)
  {
    this->CompositionTimecode_ = x;
  }

  void CompositionPlaylistType::
  setCompositionTimecode (::std::unique_ptr< CompositionTimecodeType > x)
  {
    this->CompositionTimecode_.set (std::move (x));
  }

  const CompositionPlaylistType::EditRateType& CompositionPlaylistType::
  getEditRate () const
  {
    return this->EditRate_.get ();
  }

  CompositionPlaylistType::EditRateType& CompositionPlaylistType::
  getEditRate ()
  {
    return this->EditRate_.get ();
  }

  void CompositionPlaylistType::
  setEditRate (const EditRateType& x)
  {
    this->EditRate_.set (x);
  }

  void CompositionPlaylistType::
  setEditRate (::std::unique_ptr< EditRateType > x)
  {
    this->EditRate_.set (std::move (x));
  }

  const CompositionPlaylistType::TotalRunningTimeOptional& CompositionPlaylistType::
  getTotalRunningTime () const
  {
    return this->TotalRunningTime_;
  }

  CompositionPlaylistType::TotalRunningTimeOptional& CompositionPlaylistType::
  getTotalRunningTime ()
  {
    return this->TotalRunningTime_;
  }

  void CompositionPlaylistType::
  setTotalRunningTime (const TotalRunningTimeType& x)
  {
    this->TotalRunningTime_.set (x);
  }

  void CompositionPlaylistType::
  setTotalRunningTime (const TotalRunningTimeOptional& x)
  {
    this->TotalRunningTime_ = x;
  }

  void CompositionPlaylistType::
  setTotalRunningTime (::std::unique_ptr< TotalRunningTimeType > x)
  {
    this->TotalRunningTime_.set (std::move (x));
  }

  const CompositionPlaylistType::LocaleListOptional& CompositionPlaylistType::
  getLocaleList () const
  {
    return this->LocaleList_;
  }

  CompositionPlaylistType::LocaleListOptional& CompositionPlaylistType::
  getLocaleList ()
  {
    return this->LocaleList_;
  }

  void CompositionPlaylistType::
  setLocaleList (const LocaleListType& x)
  {
    this->LocaleList_.set (x);
  }

  void CompositionPlaylistType::
  setLocaleList (const LocaleListOptional& x)
  {
    this->LocaleList_ = x;
  }

  void CompositionPlaylistType::
  setLocaleList (::std::unique_ptr< LocaleListType > x)
  {
    this->LocaleList_.set (std::move (x));
  }

  const CompositionPlaylistType::ExtensionPropertiesOptional& CompositionPlaylistType::
  getExtensionProperties () const
  {
    return this->ExtensionProperties_;
  }

  CompositionPlaylistType::ExtensionPropertiesOptional& CompositionPlaylistType::
  getExtensionProperties ()
  {
    return this->ExtensionProperties_;
  }

  void CompositionPlaylistType::
  setExtensionProperties (const ExtensionPropertiesType& x)
  {
    this->ExtensionProperties_.set (x);
  }

  void CompositionPlaylistType::
  setExtensionProperties (const ExtensionPropertiesOptional& x)
  {
    this->ExtensionProperties_ = x;
  }

  void CompositionPlaylistType::
  setExtensionProperties (::std::unique_ptr< ExtensionPropertiesType > x)
  {
    this->ExtensionProperties_.set (std::move (x));
  }

  const CompositionPlaylistType::SegmentListType& CompositionPlaylistType::
  getSegmentList () const
  {
    return this->SegmentList_.get ();
  }

  CompositionPlaylistType::SegmentListType& CompositionPlaylistType::
  getSegmentList ()
  {
    return this->SegmentList_.get ();
  }

  void CompositionPlaylistType::
  setSegmentList (const SegmentListType& x)
  {
    this->SegmentList_.set (x);
  }

  void CompositionPlaylistType::
  setSegmentList (::std::unique_ptr< SegmentListType > x)
  {
    this->SegmentList_.set (std::move (x));
  }

  const CompositionPlaylistType::SignerOptional& CompositionPlaylistType::
  getSigner () const
  {
    return this->Signer_;
  }

  CompositionPlaylistType::SignerOptional& CompositionPlaylistType::
  getSigner ()
  {
    return this->Signer_;
  }

  void CompositionPlaylistType::
  setSigner (const SignerType& x)
  {
    this->Signer_.set (x);
  }

  void CompositionPlaylistType::
  setSigner (const SignerOptional& x)
  {
    this->Signer_ = x;
  }

  void CompositionPlaylistType::
  setSigner (::std::unique_ptr< SignerType > x)
  {
    this->Signer_.set (std::move (x));
  }

  const CompositionPlaylistType::SignatureOptional& CompositionPlaylistType::
  getSignature () const
  {
    return this->Signature_;
  }

  CompositionPlaylistType::SignatureOptional& CompositionPlaylistType::
  getSignature ()
  {
    return this->Signature_;
  }

  void CompositionPlaylistType::
  setSignature (const SignatureType& x)
  {
    this->Signature_.set (x);
  }

  void CompositionPlaylistType::
  setSignature (const SignatureOptional& x)
  {
    this->Signature_ = x;
  }

  void CompositionPlaylistType::
  setSignature (::std::unique_ptr< SignatureType > x)
  {
    this->Signature_.set (std::move (x));
  }


  // CompositionTimecodeType
  // 

  const CompositionTimecodeType::TimecodeDropFrameType& CompositionTimecodeType::
  getTimecodeDropFrame () const
  {
    return this->TimecodeDropFrame_.get ();
  }

  CompositionTimecodeType::TimecodeDropFrameType& CompositionTimecodeType::
  getTimecodeDropFrame ()
  {
    return this->TimecodeDropFrame_.get ();
  }

  void CompositionTimecodeType::
  setTimecodeDropFrame (const TimecodeDropFrameType& x)
  {
    this->TimecodeDropFrame_.set (x);
  }

  const CompositionTimecodeType::TimecodeRateType& CompositionTimecodeType::
  getTimecodeRate () const
  {
    return this->TimecodeRate_.get ();
  }

  CompositionTimecodeType::TimecodeRateType& CompositionTimecodeType::
  getTimecodeRate ()
  {
    return this->TimecodeRate_.get ();
  }

  void CompositionTimecodeType::
  setTimecodeRate (const TimecodeRateType& x)
  {
    this->TimecodeRate_.set (x);
  }

  const CompositionTimecodeType::TimecodeStartAddressType& CompositionTimecodeType::
  getTimecodeStartAddress () const
  {
    return this->TimecodeStartAddress_.get ();
  }

  CompositionTimecodeType::TimecodeStartAddressType& CompositionTimecodeType::
  getTimecodeStartAddress ()
  {
    return this->TimecodeStartAddress_.get ();
  }

  void CompositionTimecodeType::
  setTimecodeStartAddress (const TimecodeStartAddressType& x)
  {
    this->TimecodeStartAddress_.set (x);
  }

  void CompositionTimecodeType::
  setTimecodeStartAddress (::std::unique_ptr< TimecodeStartAddressType > x)
  {
    this->TimecodeStartAddress_.set (std::move (x));
  }


  // TimecodeType
  // 


  // ContentKindType
  // 

  const ContentKindType::ScopeType& ContentKindType::
  getScope () const
  {
    return this->scope_.get ();
  }

  ContentKindType::ScopeType& ContentKindType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void ContentKindType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void ContentKindType::
  setScope (::std::unique_ptr< ScopeType > x)
  {
    this->scope_.set (std::move (x));
  }

  const ContentKindType::ScopeType& ContentKindType::
  getScopeDefaultValue ()
  {
    return scope_default_value_;
  }


  // LocaleType
  // 

  const LocaleType::AnnotationOptional& LocaleType::
  getAnnotation () const
  {
    return this->Annotation_;
  }

  LocaleType::AnnotationOptional& LocaleType::
  getAnnotation ()
  {
    return this->Annotation_;
  }

  void LocaleType::
  setAnnotation (const AnnotationType& x)
  {
    this->Annotation_.set (x);
  }

  void LocaleType::
  setAnnotation (const AnnotationOptional& x)
  {
    this->Annotation_ = x;
  }

  void LocaleType::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->Annotation_.set (std::move (x));
  }

  const LocaleType::LanguageListOptional& LocaleType::
  getLanguageList () const
  {
    return this->LanguageList_;
  }

  LocaleType::LanguageListOptional& LocaleType::
  getLanguageList ()
  {
    return this->LanguageList_;
  }

  void LocaleType::
  setLanguageList (const LanguageListType& x)
  {
    this->LanguageList_.set (x);
  }

  void LocaleType::
  setLanguageList (const LanguageListOptional& x)
  {
    this->LanguageList_ = x;
  }

  void LocaleType::
  setLanguageList (::std::unique_ptr< LanguageListType > x)
  {
    this->LanguageList_.set (std::move (x));
  }

  const LocaleType::RegionListOptional& LocaleType::
  getRegionList () const
  {
    return this->RegionList_;
  }

  LocaleType::RegionListOptional& LocaleType::
  getRegionList ()
  {
    return this->RegionList_;
  }

  void LocaleType::
  setRegionList (const RegionListType& x)
  {
    this->RegionList_.set (x);
  }

  void LocaleType::
  setRegionList (const RegionListOptional& x)
  {
    this->RegionList_ = x;
  }

  void LocaleType::
  setRegionList (::std::unique_ptr< RegionListType > x)
  {
    this->RegionList_.set (std::move (x));
  }

  const LocaleType::ContentMaturityRatingListOptional& LocaleType::
  getContentMaturityRatingList () const
  {
    return this->ContentMaturityRatingList_;
  }

  LocaleType::ContentMaturityRatingListOptional& LocaleType::
  getContentMaturityRatingList ()
  {
    return this->ContentMaturityRatingList_;
  }

  void LocaleType::
  setContentMaturityRatingList (const ContentMaturityRatingListType& x)
  {
    this->ContentMaturityRatingList_.set (x);
  }

  void LocaleType::
  setContentMaturityRatingList (const ContentMaturityRatingListOptional& x)
  {
    this->ContentMaturityRatingList_ = x;
  }

  void LocaleType::
  setContentMaturityRatingList (::std::unique_ptr< ContentMaturityRatingListType > x)
  {
    this->ContentMaturityRatingList_.set (std::move (x));
  }


  // ContentMaturityRatingType
  // 

  const ContentMaturityRatingType::AgencyType& ContentMaturityRatingType::
  getAgency () const
  {
    return this->Agency_.get ();
  }

  ContentMaturityRatingType::AgencyType& ContentMaturityRatingType::
  getAgency ()
  {
    return this->Agency_.get ();
  }

  void ContentMaturityRatingType::
  setAgency (const AgencyType& x)
  {
    this->Agency_.set (x);
  }

  void ContentMaturityRatingType::
  setAgency (::std::unique_ptr< AgencyType > x)
  {
    this->Agency_.set (std::move (x));
  }

  const ContentMaturityRatingType::RatingType& ContentMaturityRatingType::
  getRating () const
  {
    return this->Rating_.get ();
  }

  ContentMaturityRatingType::RatingType& ContentMaturityRatingType::
  getRating ()
  {
    return this->Rating_.get ();
  }

  void ContentMaturityRatingType::
  setRating (const RatingType& x)
  {
    this->Rating_.set (x);
  }

  void ContentMaturityRatingType::
  setRating (::std::unique_ptr< RatingType > x)
  {
    this->Rating_.set (std::move (x));
  }

  const ContentMaturityRatingType::AudienceOptional& ContentMaturityRatingType::
  getAudience () const
  {
    return this->Audience_;
  }

  ContentMaturityRatingType::AudienceOptional& ContentMaturityRatingType::
  getAudience ()
  {
    return this->Audience_;
  }

  void ContentMaturityRatingType::
  setAudience (const AudienceType& x)
  {
    this->Audience_.set (x);
  }

  void ContentMaturityRatingType::
  setAudience (const AudienceOptional& x)
  {
    this->Audience_ = x;
  }

  void ContentMaturityRatingType::
  setAudience (::std::unique_ptr< AudienceType > x)
  {
    this->Audience_.set (std::move (x));
  }

  const ContentMaturityRatingType::AnySequence& ContentMaturityRatingType::
  getAny () const
  {
    return this->any_;
  }

  ContentMaturityRatingType::AnySequence& ContentMaturityRatingType::
  getAny ()
  {
    return this->any_;
  }

  void ContentMaturityRatingType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& ContentMaturityRatingType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& ContentMaturityRatingType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // EssenceDescriptorBaseType
  // 

  const EssenceDescriptorBaseType::IdType& EssenceDescriptorBaseType::
  getId () const
  {
    return this->Id_.get ();
  }

  EssenceDescriptorBaseType::IdType& EssenceDescriptorBaseType::
  getId ()
  {
    return this->Id_.get ();
  }

  void EssenceDescriptorBaseType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void EssenceDescriptorBaseType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const EssenceDescriptorBaseType::AnySequence& EssenceDescriptorBaseType::
  getAny () const
  {
    return this->any_;
  }

  EssenceDescriptorBaseType::AnySequence& EssenceDescriptorBaseType::
  getAny ()
  {
    return this->any_;
  }

  void EssenceDescriptorBaseType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& EssenceDescriptorBaseType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& EssenceDescriptorBaseType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // ContentVersionType
  // 

  const ContentVersionType::IdType& ContentVersionType::
  getId () const
  {
    return this->Id_.get ();
  }

  ContentVersionType::IdType& ContentVersionType::
  getId ()
  {
    return this->Id_.get ();
  }

  void ContentVersionType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void ContentVersionType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const ContentVersionType::LabelTextType& ContentVersionType::
  getLabelText () const
  {
    return this->LabelText_.get ();
  }

  ContentVersionType::LabelTextType& ContentVersionType::
  getLabelText ()
  {
    return this->LabelText_.get ();
  }

  void ContentVersionType::
  setLabelText (const LabelTextType& x)
  {
    this->LabelText_.set (x);
  }

  void ContentVersionType::
  setLabelText (::std::unique_ptr< LabelTextType > x)
  {
    this->LabelText_.set (std::move (x));
  }

  const ContentVersionType::AnySequence& ContentVersionType::
  getAny () const
  {
    return this->any_;
  }

  ContentVersionType::AnySequence& ContentVersionType::
  getAny ()
  {
    return this->any_;
  }

  void ContentVersionType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& ContentVersionType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& ContentVersionType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // SegmentType
  // 

  const SegmentType::IdType& SegmentType::
  getId () const
  {
    return this->Id_.get ();
  }

  SegmentType::IdType& SegmentType::
  getId ()
  {
    return this->Id_.get ();
  }

  void SegmentType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SegmentType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const SegmentType::AnnotationOptional& SegmentType::
  getAnnotation () const
  {
    return this->Annotation_;
  }

  SegmentType::AnnotationOptional& SegmentType::
  getAnnotation ()
  {
    return this->Annotation_;
  }

  void SegmentType::
  setAnnotation (const AnnotationType& x)
  {
    this->Annotation_.set (x);
  }

  void SegmentType::
  setAnnotation (const AnnotationOptional& x)
  {
    this->Annotation_ = x;
  }

  void SegmentType::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->Annotation_.set (std::move (x));
  }

  const SegmentType::SequenceListType& SegmentType::
  getSequenceList () const
  {
    return this->SequenceList_.get ();
  }

  SegmentType::SequenceListType& SegmentType::
  getSequenceList ()
  {
    return this->SequenceList_.get ();
  }

  void SegmentType::
  setSequenceList (const SequenceListType& x)
  {
    this->SequenceList_.set (x);
  }

  void SegmentType::
  setSequenceList (::std::unique_ptr< SequenceListType > x)
  {
    this->SequenceList_.set (std::move (x));
  }


  // SequenceType
  // 

  const SequenceType::IdType& SequenceType::
  getId () const
  {
    return this->Id_.get ();
  }

  SequenceType::IdType& SequenceType::
  getId ()
  {
    return this->Id_.get ();
  }

  void SequenceType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void SequenceType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const SequenceType::TrackIdType& SequenceType::
  getTrackId () const
  {
    return this->TrackId_.get ();
  }

  SequenceType::TrackIdType& SequenceType::
  getTrackId ()
  {
    return this->TrackId_.get ();
  }

  void SequenceType::
  setTrackId (const TrackIdType& x)
  {
    this->TrackId_.set (x);
  }

  void SequenceType::
  setTrackId (::std::unique_ptr< TrackIdType > x)
  {
    this->TrackId_.set (std::move (x));
  }

  const SequenceType::ResourceListType& SequenceType::
  getResourceList () const
  {
    return this->ResourceList_.get ();
  }

  SequenceType::ResourceListType& SequenceType::
  getResourceList ()
  {
    return this->ResourceList_.get ();
  }

  void SequenceType::
  setResourceList (const ResourceListType& x)
  {
    this->ResourceList_.set (x);
  }

  void SequenceType::
  setResourceList (::std::unique_ptr< ResourceListType > x)
  {
    this->ResourceList_.set (std::move (x));
  }


  // BaseResourceType
  // 

  const BaseResourceType::IdType& BaseResourceType::
  getId () const
  {
    return this->Id_.get ();
  }

  BaseResourceType::IdType& BaseResourceType::
  getId ()
  {
    return this->Id_.get ();
  }

  void BaseResourceType::
  setId (const IdType& x)
  {
    this->Id_.set (x);
  }

  void BaseResourceType::
  setId (::std::unique_ptr< IdType > x)
  {
    this->Id_.set (std::move (x));
  }

  const BaseResourceType::AnnotationOptional& BaseResourceType::
  getAnnotation () const
  {
    return this->Annotation_;
  }

  BaseResourceType::AnnotationOptional& BaseResourceType::
  getAnnotation ()
  {
    return this->Annotation_;
  }

  void BaseResourceType::
  setAnnotation (const AnnotationType& x)
  {
    this->Annotation_.set (x);
  }

  void BaseResourceType::
  setAnnotation (const AnnotationOptional& x)
  {
    this->Annotation_ = x;
  }

  void BaseResourceType::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->Annotation_.set (std::move (x));
  }

  const BaseResourceType::EditRateOptional& BaseResourceType::
  getEditRate () const
  {
    return this->EditRate_;
  }

  BaseResourceType::EditRateOptional& BaseResourceType::
  getEditRate ()
  {
    return this->EditRate_;
  }

  void BaseResourceType::
  setEditRate (const EditRateType& x)
  {
    this->EditRate_.set (x);
  }

  void BaseResourceType::
  setEditRate (const EditRateOptional& x)
  {
    this->EditRate_ = x;
  }

  void BaseResourceType::
  setEditRate (::std::unique_ptr< EditRateType > x)
  {
    this->EditRate_.set (std::move (x));
  }

  const BaseResourceType::IntrinsicDurationType& BaseResourceType::
  getIntrinsicDuration () const
  {
    return this->IntrinsicDuration_.get ();
  }

  BaseResourceType::IntrinsicDurationType& BaseResourceType::
  getIntrinsicDuration ()
  {
    return this->IntrinsicDuration_.get ();
  }

  void BaseResourceType::
  setIntrinsicDuration (const IntrinsicDurationType& x)
  {
    this->IntrinsicDuration_.set (x);
  }

  const BaseResourceType::EntryPointOptional& BaseResourceType::
  getEntryPoint () const
  {
    return this->EntryPoint_;
  }

  BaseResourceType::EntryPointOptional& BaseResourceType::
  getEntryPoint ()
  {
    return this->EntryPoint_;
  }

  void BaseResourceType::
  setEntryPoint (const EntryPointType& x)
  {
    this->EntryPoint_.set (x);
  }

  void BaseResourceType::
  setEntryPoint (const EntryPointOptional& x)
  {
    this->EntryPoint_ = x;
  }

  const BaseResourceType::SourceDurationOptional& BaseResourceType::
  getSourceDuration () const
  {
    return this->SourceDuration_;
  }

  BaseResourceType::SourceDurationOptional& BaseResourceType::
  getSourceDuration ()
  {
    return this->SourceDuration_;
  }

  void BaseResourceType::
  setSourceDuration (const SourceDurationType& x)
  {
    this->SourceDuration_.set (x);
  }

  void BaseResourceType::
  setSourceDuration (const SourceDurationOptional& x)
  {
    this->SourceDuration_ = x;
  }

  const BaseResourceType::RepeatCountOptional& BaseResourceType::
  getRepeatCount () const
  {
    return this->RepeatCount_;
  }

  BaseResourceType::RepeatCountOptional& BaseResourceType::
  getRepeatCount ()
  {
    return this->RepeatCount_;
  }

  void BaseResourceType::
  setRepeatCount (const RepeatCountType& x)
  {
    this->RepeatCount_.set (x);
  }

  void BaseResourceType::
  setRepeatCount (const RepeatCountOptional& x)
  {
    this->RepeatCount_ = x;
  }


  // TrackFileResourceType
  // 

  const TrackFileResourceType::SourceEncodingType& TrackFileResourceType::
  getSourceEncoding () const
  {
    return this->SourceEncoding_.get ();
  }

  TrackFileResourceType::SourceEncodingType& TrackFileResourceType::
  getSourceEncoding ()
  {
    return this->SourceEncoding_.get ();
  }

  void TrackFileResourceType::
  setSourceEncoding (const SourceEncodingType& x)
  {
    this->SourceEncoding_.set (x);
  }

  void TrackFileResourceType::
  setSourceEncoding (::std::unique_ptr< SourceEncodingType > x)
  {
    this->SourceEncoding_.set (std::move (x));
  }

  const TrackFileResourceType::TrackFileIdType& TrackFileResourceType::
  getTrackFileId () const
  {
    return this->TrackFileId_.get ();
  }

  TrackFileResourceType::TrackFileIdType& TrackFileResourceType::
  getTrackFileId ()
  {
    return this->TrackFileId_.get ();
  }

  void TrackFileResourceType::
  setTrackFileId (const TrackFileIdType& x)
  {
    this->TrackFileId_.set (x);
  }

  void TrackFileResourceType::
  setTrackFileId (::std::unique_ptr< TrackFileIdType > x)
  {
    this->TrackFileId_.set (std::move (x));
  }

  const TrackFileResourceType::KeyIdOptional& TrackFileResourceType::
  getKeyId () const
  {
    return this->KeyId_;
  }

  TrackFileResourceType::KeyIdOptional& TrackFileResourceType::
  getKeyId ()
  {
    return this->KeyId_;
  }

  void TrackFileResourceType::
  setKeyId (const KeyIdType& x)
  {
    this->KeyId_.set (x);
  }

  void TrackFileResourceType::
  setKeyId (const KeyIdOptional& x)
  {
    this->KeyId_ = x;
  }

  void TrackFileResourceType::
  setKeyId (::std::unique_ptr< KeyIdType > x)
  {
    this->KeyId_.set (std::move (x));
  }

  const TrackFileResourceType::HashOptional& TrackFileResourceType::
  getHash () const
  {
    return this->Hash_;
  }

  TrackFileResourceType::HashOptional& TrackFileResourceType::
  getHash ()
  {
    return this->Hash_;
  }

  void TrackFileResourceType::
  setHash (const HashType& x)
  {
    this->Hash_.set (x);
  }

  void TrackFileResourceType::
  setHash (const HashOptional& x)
  {
    this->Hash_ = x;
  }

  void TrackFileResourceType::
  setHash (::std::unique_ptr< HashType > x)
  {
    this->Hash_.set (std::move (x));
  }


  // MarkerResourceType
  // 

  const MarkerResourceType::MarkerSequence& MarkerResourceType::
  getMarker () const
  {
    return this->Marker_;
  }

  MarkerResourceType::MarkerSequence& MarkerResourceType::
  getMarker ()
  {
    return this->Marker_;
  }

  void MarkerResourceType::
  setMarker (const MarkerSequence& s)
  {
    this->Marker_ = s;
  }


  // MarkerType
  // 

  const MarkerType::AnnotationOptional& MarkerType::
  getAnnotation () const
  {
    return this->Annotation_;
  }

  MarkerType::AnnotationOptional& MarkerType::
  getAnnotation ()
  {
    return this->Annotation_;
  }

  void MarkerType::
  setAnnotation (const AnnotationType& x)
  {
    this->Annotation_.set (x);
  }

  void MarkerType::
  setAnnotation (const AnnotationOptional& x)
  {
    this->Annotation_ = x;
  }

  void MarkerType::
  setAnnotation (::std::unique_ptr< AnnotationType > x)
  {
    this->Annotation_.set (std::move (x));
  }

  const MarkerType::LabelType& MarkerType::
  getLabel () const
  {
    return this->Label_.get ();
  }

  MarkerType::LabelType& MarkerType::
  getLabel ()
  {
    return this->Label_.get ();
  }

  void MarkerType::
  setLabel (const LabelType& x)
  {
    this->Label_.set (x);
  }

  void MarkerType::
  setLabel (::std::unique_ptr< LabelType > x)
  {
    this->Label_.set (std::move (x));
  }

  const MarkerType::OffsetType& MarkerType::
  getOffset () const
  {
    return this->Offset_.get ();
  }

  MarkerType::OffsetType& MarkerType::
  getOffset ()
  {
    return this->Offset_.get ();
  }

  void MarkerType::
  setOffset (const OffsetType& x)
  {
    this->Offset_.set (x);
  }


  // CompositionPlaylistType_ContentVersionListType
  // 

  const CompositionPlaylistType_ContentVersionListType::ContentVersionSequence& CompositionPlaylistType_ContentVersionListType::
  getContentVersion () const
  {
    return this->ContentVersion_;
  }

  CompositionPlaylistType_ContentVersionListType::ContentVersionSequence& CompositionPlaylistType_ContentVersionListType::
  getContentVersion ()
  {
    return this->ContentVersion_;
  }

  void CompositionPlaylistType_ContentVersionListType::
  setContentVersion (const ContentVersionSequence& s)
  {
    this->ContentVersion_ = s;
  }


  // CompositionPlaylistType_EssenceDescriptorListType
  // 

  const CompositionPlaylistType_EssenceDescriptorListType::EssenceDescriptorSequence& CompositionPlaylistType_EssenceDescriptorListType::
  getEssenceDescriptor () const
  {
    return this->EssenceDescriptor_;
  }

  CompositionPlaylistType_EssenceDescriptorListType::EssenceDescriptorSequence& CompositionPlaylistType_EssenceDescriptorListType::
  getEssenceDescriptor ()
  {
    return this->EssenceDescriptor_;
  }

  void CompositionPlaylistType_EssenceDescriptorListType::
  setEssenceDescriptor (const EssenceDescriptorSequence& s)
  {
    this->EssenceDescriptor_ = s;
  }


  // CompositionPlaylistType_TotalRunningTimeType
  // 


  // CompositionPlaylistType_LocaleListType
  // 

  const CompositionPlaylistType_LocaleListType::LocaleSequence& CompositionPlaylistType_LocaleListType::
  getLocale () const
  {
    return this->Locale_;
  }

  CompositionPlaylistType_LocaleListType::LocaleSequence& CompositionPlaylistType_LocaleListType::
  getLocale ()
  {
    return this->Locale_;
  }

  void CompositionPlaylistType_LocaleListType::
  setLocale (const LocaleSequence& s)
  {
    this->Locale_ = s;
  }


  // CompositionPlaylistType_ExtensionPropertiesType
  // 

  const CompositionPlaylistType_ExtensionPropertiesType::AnySequence& CompositionPlaylistType_ExtensionPropertiesType::
  getAny () const
  {
    return this->any_;
  }

  CompositionPlaylistType_ExtensionPropertiesType::AnySequence& CompositionPlaylistType_ExtensionPropertiesType::
  getAny ()
  {
    return this->any_;
  }

  void CompositionPlaylistType_ExtensionPropertiesType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& CompositionPlaylistType_ExtensionPropertiesType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& CompositionPlaylistType_ExtensionPropertiesType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // CompositionPlaylistType_SegmentListType
  // 

  const CompositionPlaylistType_SegmentListType::SegmentSequence& CompositionPlaylistType_SegmentListType::
  getSegment () const
  {
    return this->Segment_;
  }

  CompositionPlaylistType_SegmentListType::SegmentSequence& CompositionPlaylistType_SegmentListType::
  getSegment ()
  {
    return this->Segment_;
  }

  void CompositionPlaylistType_SegmentListType::
  setSegment (const SegmentSequence& s)
  {
    this->Segment_ = s;
  }


  // LocaleType_LanguageListType
  // 

  const LocaleType_LanguageListType::LanguageSequence& LocaleType_LanguageListType::
  getLanguage () const
  {
    return this->Language_;
  }

  LocaleType_LanguageListType::LanguageSequence& LocaleType_LanguageListType::
  getLanguage ()
  {
    return this->Language_;
  }

  void LocaleType_LanguageListType::
  setLanguage (const LanguageSequence& s)
  {
    this->Language_ = s;
  }


  // LocaleType_RegionListType
  // 

  const LocaleType_RegionListType::RegionSequence& LocaleType_RegionListType::
  getRegion () const
  {
    return this->Region_;
  }

  LocaleType_RegionListType::RegionSequence& LocaleType_RegionListType::
  getRegion ()
  {
    return this->Region_;
  }

  void LocaleType_RegionListType::
  setRegion (const RegionSequence& s)
  {
    this->Region_ = s;
  }


  // LocaleType_ContentMaturityRatingListType
  // 

  const LocaleType_ContentMaturityRatingListType::ContentMaturityRatingSequence& LocaleType_ContentMaturityRatingListType::
  getContentMaturityRating () const
  {
    return this->ContentMaturityRating_;
  }

  LocaleType_ContentMaturityRatingListType::ContentMaturityRatingSequence& LocaleType_ContentMaturityRatingListType::
  getContentMaturityRating ()
  {
    return this->ContentMaturityRating_;
  }

  void LocaleType_ContentMaturityRatingListType::
  setContentMaturityRating (const ContentMaturityRatingSequence& s)
  {
    this->ContentMaturityRating_ = s;
  }


  // ContentMaturityRatingType_AudienceType
  // 

  const ContentMaturityRatingType_AudienceType::ScopeType& ContentMaturityRatingType_AudienceType::
  getScope () const
  {
    return this->scope_.get ();
  }

  ContentMaturityRatingType_AudienceType::ScopeType& ContentMaturityRatingType_AudienceType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void ContentMaturityRatingType_AudienceType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void ContentMaturityRatingType_AudienceType::
  setScope (::std::unique_ptr< ScopeType > x)
  {
    this->scope_.set (std::move (x));
  }


  // SegmentType_SequenceListType
  // 

  const SegmentType_SequenceListType::MarkerSequenceOptional& SegmentType_SequenceListType::
  getMarkerSequence () const
  {
    return this->MarkerSequence_;
  }

  SegmentType_SequenceListType::MarkerSequenceOptional& SegmentType_SequenceListType::
  getMarkerSequence ()
  {
    return this->MarkerSequence_;
  }

  void SegmentType_SequenceListType::
  setMarkerSequence (const MarkerSequenceType& x)
  {
    this->MarkerSequence_.set (x);
  }

  void SegmentType_SequenceListType::
  setMarkerSequence (const MarkerSequenceOptional& x)
  {
    this->MarkerSequence_ = x;
  }

  void SegmentType_SequenceListType::
  setMarkerSequence (::std::unique_ptr< MarkerSequenceType > x)
  {
    this->MarkerSequence_.set (std::move (x));
  }

  const SegmentType_SequenceListType::AnySequence& SegmentType_SequenceListType::
  getAny () const
  {
    return this->any_;
  }

  SegmentType_SequenceListType::AnySequence& SegmentType_SequenceListType::
  getAny ()
  {
    return this->any_;
  }

  void SegmentType_SequenceListType::
  setAny (const AnySequence& s)
  {
    this->any_ = s;
  }

  const ::xercesc::DOMDocument& SegmentType_SequenceListType::
  getDomDocument () const
  {
    return *this->dom_document_;
  }

  ::xercesc::DOMDocument& SegmentType_SequenceListType::
  getDomDocument ()
  {
    return *this->dom_document_;
  }


  // SequenceType_ResourceListType
  // 

  const SequenceType_ResourceListType::ResourceSequence& SequenceType_ResourceListType::
  getResource () const
  {
    return this->Resource_;
  }

  SequenceType_ResourceListType::ResourceSequence& SequenceType_ResourceListType::
  getResource ()
  {
    return this->Resource_;
  }

  void SequenceType_ResourceListType::
  setResource (const ResourceSequence& s)
  {
    this->Resource_ = s;
  }


  // MarkerType_LabelType
  // 

  const MarkerType_LabelType::ScopeType& MarkerType_LabelType::
  getScope () const
  {
    return this->scope_.get ();
  }

  MarkerType_LabelType::ScopeType& MarkerType_LabelType::
  getScope ()
  {
    return this->scope_.get ();
  }

  void MarkerType_LabelType::
  setScope (const ScopeType& x)
  {
    this->scope_.set (x);
  }

  void MarkerType_LabelType::
  setScope (::std::unique_ptr< ScopeType > x)
  {
    this->scope_.set (std::move (x));
  }

  const MarkerType_LabelType::ScopeType& MarkerType_LabelType::
  getScopeDefaultValue ()
  {
    return scope_default_value_;
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace cpl
{
  // CompositionPlaylistType
  //

  CompositionPlaylistType::
  CompositionPlaylistType (const IdType& Id,
                           const IssueDateType& IssueDate,
                           const ContentTitleType& ContentTitle,
                           const EditRateType& EditRate,
                           const SegmentListType& SegmentList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Annotation_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    ContentOriginator_ (this),
    ContentTitle_ (ContentTitle, this),
    ContentKind_ (this),
    ContentVersionList_ (this),
    EssenceDescriptorList_ (this),
    CompositionTimecode_ (this),
    EditRate_ (EditRate, this),
    TotalRunningTime_ (this),
    LocaleList_ (this),
    ExtensionProperties_ (this),
    SegmentList_ (SegmentList, this),
    Signer_ (this),
    Signature_ (this)
  {
  }

  CompositionPlaylistType::
  CompositionPlaylistType (const IdType& Id,
                           const IssueDateType& IssueDate,
                           ::std::unique_ptr< ContentTitleType > ContentTitle,
                           const EditRateType& EditRate,
                           ::std::unique_ptr< SegmentListType > SegmentList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Annotation_ (this),
    IssueDate_ (IssueDate, this),
    Issuer_ (this),
    Creator_ (this),
    ContentOriginator_ (this),
    ContentTitle_ (std::move (ContentTitle), this),
    ContentKind_ (this),
    ContentVersionList_ (this),
    EssenceDescriptorList_ (this),
    CompositionTimecode_ (this),
    EditRate_ (EditRate, this),
    TotalRunningTime_ (this),
    LocaleList_ (this),
    ExtensionProperties_ (this),
    SegmentList_ (std::move (SegmentList), this),
    Signer_ (this),
    Signature_ (this)
  {
  }

  CompositionPlaylistType::
  CompositionPlaylistType (const CompositionPlaylistType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    Annotation_ (x.Annotation_, f, this),
    IssueDate_ (x.IssueDate_, f, this),
    Issuer_ (x.Issuer_, f, this),
    Creator_ (x.Creator_, f, this),
    ContentOriginator_ (x.ContentOriginator_, f, this),
    ContentTitle_ (x.ContentTitle_, f, this),
    ContentKind_ (x.ContentKind_, f, this),
    ContentVersionList_ (x.ContentVersionList_, f, this),
    EssenceDescriptorList_ (x.EssenceDescriptorList_, f, this),
    CompositionTimecode_ (x.CompositionTimecode_, f, this),
    EditRate_ (x.EditRate_, f, this),
    TotalRunningTime_ (x.TotalRunningTime_, f, this),
    LocaleList_ (x.LocaleList_, f, this),
    ExtensionProperties_ (x.ExtensionProperties_, f, this),
    SegmentList_ (x.SegmentList_, f, this),
    Signer_ (x.Signer_, f, this),
    Signature_ (x.Signature_, f, this)
  {
  }

  CompositionPlaylistType::
  CompositionPlaylistType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    Annotation_ (this),
    IssueDate_ (this),
    Issuer_ (this),
    Creator_ (this),
    ContentOriginator_ (this),
    ContentTitle_ (this),
    ContentKind_ (this),
    ContentVersionList_ (this),
    EssenceDescriptorList_ (this),
    CompositionTimecode_ (this),
    EditRate_ (this),
    TotalRunningTime_ (this),
    LocaleList_ (this),
    ExtensionProperties_ (this),
    SegmentList_ (this),
    Signer_ (this),
    Signature_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->Annotation_)
        {
          this->Annotation_.set (::std::move (r));
          continue;
        }
      }

      // IssueDate
      //
      if (n.name () == "IssueDate" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IssueDateType > r (
          IssueDateTraits::create (i, f, this));

        if (!IssueDate_.present ())
        {
          this->IssueDate_.set (::std::move (r));
          continue;
        }
      }

      // Issuer
      //
      if (n.name () == "Issuer" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IssuerType > r (
          IssuerTraits::create (i, f, this));

        if (!this->Issuer_)
        {
          this->Issuer_.set (::std::move (r));
          continue;
        }
      }

      // Creator
      //
      if (n.name () == "Creator" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< CreatorType > r (
          CreatorTraits::create (i, f, this));

        if (!this->Creator_)
        {
          this->Creator_.set (::std::move (r));
          continue;
        }
      }

      // ContentOriginator
      //
      if (n.name () == "ContentOriginator" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentOriginatorType > r (
          ContentOriginatorTraits::create (i, f, this));

        if (!this->ContentOriginator_)
        {
          this->ContentOriginator_.set (::std::move (r));
          continue;
        }
      }

      // ContentTitle
      //
      if (n.name () == "ContentTitle" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentTitleType > r (
          ContentTitleTraits::create (i, f, this));

        if (!ContentTitle_.present ())
        {
          this->ContentTitle_.set (::std::move (r));
          continue;
        }
      }

      // ContentKind
      //
      if (n.name () == "ContentKind" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentKindType > r (
          ContentKindTraits::create (i, f, this));

        if (!this->ContentKind_)
        {
          this->ContentKind_.set (::std::move (r));
          continue;
        }
      }

      // ContentVersionList
      //
      if (n.name () == "ContentVersionList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentVersionListType > r (
          ContentVersionListTraits::create (i, f, this));

        if (!this->ContentVersionList_)
        {
          this->ContentVersionList_.set (::std::move (r));
          continue;
        }
      }

      // EssenceDescriptorList
      //
      if (n.name () == "EssenceDescriptorList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< EssenceDescriptorListType > r (
          EssenceDescriptorListTraits::create (i, f, this));

        if (!this->EssenceDescriptorList_)
        {
          this->EssenceDescriptorList_.set (::std::move (r));
          continue;
        }
      }

      // CompositionTimecode
      //
      if (n.name () == "CompositionTimecode" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< CompositionTimecodeType > r (
          CompositionTimecodeTraits::create (i, f, this));

        if (!this->CompositionTimecode_)
        {
          this->CompositionTimecode_.set (::std::move (r));
          continue;
        }
      }

      // EditRate
      //
      if (n.name () == "EditRate" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< EditRateType > r (
          EditRateTraits::create (i, f, this));

        if (!EditRate_.present ())
        {
          this->EditRate_.set (::std::move (r));
          continue;
        }
      }

      // TotalRunningTime
      //
      if (n.name () == "TotalRunningTime" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< TotalRunningTimeType > r (
          TotalRunningTimeTraits::create (i, f, this));

        if (!this->TotalRunningTime_)
        {
          this->TotalRunningTime_.set (::std::move (r));
          continue;
        }
      }

      // LocaleList
      //
      if (n.name () == "LocaleList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LocaleListType > r (
          LocaleListTraits::create (i, f, this));

        if (!this->LocaleList_)
        {
          this->LocaleList_.set (::std::move (r));
          continue;
        }
      }

      // ExtensionProperties
      //
      if (n.name () == "ExtensionProperties" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ExtensionPropertiesType > r (
          ExtensionPropertiesTraits::create (i, f, this));

        if (!this->ExtensionProperties_)
        {
          this->ExtensionProperties_.set (::std::move (r));
          continue;
        }
      }

      // SegmentList
      //
      if (n.name () == "SegmentList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< SegmentListType > r (
          SegmentListTraits::create (i, f, this));

        if (!SegmentList_.present ())
        {
          this->SegmentList_.set (::std::move (r));
          continue;
        }
      }

      // Signer
      //
      if (n.name () == "Signer" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< SignerType > r (
          SignerTraits::create (i, f, this));

        if (!this->Signer_)
        {
          this->Signer_.set (::std::move (r));
          continue;
        }
      }

      // Signature
      //
      if (n.name () == "Signature" && n.namespace_ () == "http://www.w3.org/2000/09/xmldsig#")
      {
        ::std::unique_ptr< SignatureType > r (
          SignatureTraits::create (i, f, this));

        if (!this->Signature_)
        {
          this->Signature_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!IssueDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IssueDate",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!ContentTitle_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ContentTitle",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!EditRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EditRate",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!SegmentList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SegmentList",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  CompositionPlaylistType* CompositionPlaylistType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType (*this, f, c);
  }

  CompositionPlaylistType& CompositionPlaylistType::
  operator= (const CompositionPlaylistType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->Annotation_ = x.Annotation_;
      this->IssueDate_ = x.IssueDate_;
      this->Issuer_ = x.Issuer_;
      this->Creator_ = x.Creator_;
      this->ContentOriginator_ = x.ContentOriginator_;
      this->ContentTitle_ = x.ContentTitle_;
      this->ContentKind_ = x.ContentKind_;
      this->ContentVersionList_ = x.ContentVersionList_;
      this->EssenceDescriptorList_ = x.EssenceDescriptorList_;
      this->CompositionTimecode_ = x.CompositionTimecode_;
      this->EditRate_ = x.EditRate_;
      this->TotalRunningTime_ = x.TotalRunningTime_;
      this->LocaleList_ = x.LocaleList_;
      this->ExtensionProperties_ = x.ExtensionProperties_;
      this->SegmentList_ = x.SegmentList_;
      this->Signer_ = x.Signer_;
      this->Signature_ = x.Signature_;
    }

    return *this;
  }

  CompositionPlaylistType::
  ~CompositionPlaylistType ()
  {
  }

  // CompositionTimecodeType
  //

  CompositionTimecodeType::
  CompositionTimecodeType (const TimecodeDropFrameType& TimecodeDropFrame,
                           const TimecodeRateType& TimecodeRate,
                           const TimecodeStartAddressType& TimecodeStartAddress)
  : ::xml_schema::Type (),
    TimecodeDropFrame_ (TimecodeDropFrame, this),
    TimecodeRate_ (TimecodeRate, this),
    TimecodeStartAddress_ (TimecodeStartAddress, this)
  {
  }

  CompositionTimecodeType::
  CompositionTimecodeType (const CompositionTimecodeType& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    TimecodeDropFrame_ (x.TimecodeDropFrame_, f, this),
    TimecodeRate_ (x.TimecodeRate_, f, this),
    TimecodeStartAddress_ (x.TimecodeStartAddress_, f, this)
  {
  }

  CompositionTimecodeType::
  CompositionTimecodeType (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    TimecodeDropFrame_ (this),
    TimecodeRate_ (this),
    TimecodeStartAddress_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionTimecodeType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TimecodeDropFrame
      //
      if (n.name () == "TimecodeDropFrame" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!TimecodeDropFrame_.present ())
        {
          this->TimecodeDropFrame_.set (TimecodeDropFrameTraits::create (i, f, this));
          continue;
        }
      }

      // TimecodeRate
      //
      if (n.name () == "TimecodeRate" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!TimecodeRate_.present ())
        {
          this->TimecodeRate_.set (TimecodeRateTraits::create (i, f, this));
          continue;
        }
      }

      // TimecodeStartAddress
      //
      if (n.name () == "TimecodeStartAddress" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< TimecodeStartAddressType > r (
          TimecodeStartAddressTraits::create (i, f, this));

        if (!TimecodeStartAddress_.present ())
        {
          this->TimecodeStartAddress_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!TimecodeDropFrame_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TimecodeDropFrame",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!TimecodeRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TimecodeRate",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!TimecodeStartAddress_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TimecodeStartAddress",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  CompositionTimecodeType* CompositionTimecodeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionTimecodeType (*this, f, c);
  }

  CompositionTimecodeType& CompositionTimecodeType::
  operator= (const CompositionTimecodeType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->TimecodeDropFrame_ = x.TimecodeDropFrame_;
      this->TimecodeRate_ = x.TimecodeRate_;
      this->TimecodeStartAddress_ = x.TimecodeStartAddress_;
    }

    return *this;
  }

  CompositionTimecodeType::
  ~CompositionTimecodeType ()
  {
  }

  // TimecodeType
  //

  TimecodeType::
  TimecodeType ()
  : ::xml_schema::String ()
  {
  }

  TimecodeType::
  TimecodeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimecodeType::
  TimecodeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimecodeType::
  TimecodeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  TimecodeType::
  TimecodeType (const TimecodeType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  TimecodeType::
  TimecodeType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  TimecodeType::
  TimecodeType (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  TimecodeType::
  TimecodeType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  TimecodeType* TimecodeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimecodeType (*this, f, c);
  }

  TimecodeType::
  ~TimecodeType ()
  {
  }

  // ContentKindType
  //

  const ContentKindType::ScopeType ContentKindType::scope_default_value_ (
    "http://www.smpte-ra.org/schemas/2067-3/2013#content-kind");

  ContentKindType::
  ContentKindType ()
  : ::xml_schema::String (),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  ContentKindType::
  ContentKindType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  ContentKindType::
  ContentKindType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  ContentKindType::
  ContentKindType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  ContentKindType::
  ContentKindType (const ContentKindType& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    scope_ (x.scope_, f, this)
  {
  }

  ContentKindType::
  ContentKindType (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContentKindType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      this->scope_.set (getScopeDefaultValue ());
    }
  }

  ContentKindType* ContentKindType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContentKindType (*this, f, c);
  }

  ContentKindType& ContentKindType::
  operator= (const ContentKindType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  ContentKindType::
  ~ContentKindType ()
  {
  }

  // LocaleType
  //

  LocaleType::
  LocaleType ()
  : ::xml_schema::Type (),
    Annotation_ (this),
    LanguageList_ (this),
    RegionList_ (this),
    ContentMaturityRatingList_ (this)
  {
  }

  LocaleType::
  LocaleType (const LocaleType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Annotation_ (x.Annotation_, f, this),
    LanguageList_ (x.LanguageList_, f, this),
    RegionList_ (x.RegionList_, f, this),
    ContentMaturityRatingList_ (x.ContentMaturityRatingList_, f, this)
  {
  }

  LocaleType::
  LocaleType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Annotation_ (this),
    LanguageList_ (this),
    RegionList_ (this),
    ContentMaturityRatingList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LocaleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->Annotation_)
        {
          this->Annotation_.set (::std::move (r));
          continue;
        }
      }

      // LanguageList
      //
      if (n.name () == "LanguageList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LanguageListType > r (
          LanguageListTraits::create (i, f, this));

        if (!this->LanguageList_)
        {
          this->LanguageList_.set (::std::move (r));
          continue;
        }
      }

      // RegionList
      //
      if (n.name () == "RegionList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< RegionListType > r (
          RegionListTraits::create (i, f, this));

        if (!this->RegionList_)
        {
          this->RegionList_.set (::std::move (r));
          continue;
        }
      }

      // ContentMaturityRatingList
      //
      if (n.name () == "ContentMaturityRatingList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentMaturityRatingListType > r (
          ContentMaturityRatingListTraits::create (i, f, this));

        if (!this->ContentMaturityRatingList_)
        {
          this->ContentMaturityRatingList_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LocaleType* LocaleType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocaleType (*this, f, c);
  }

  LocaleType& LocaleType::
  operator= (const LocaleType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Annotation_ = x.Annotation_;
      this->LanguageList_ = x.LanguageList_;
      this->RegionList_ = x.RegionList_;
      this->ContentMaturityRatingList_ = x.ContentMaturityRatingList_;
    }

    return *this;
  }

  LocaleType::
  ~LocaleType ()
  {
  }

  // ContentMaturityRatingType
  //

  ContentMaturityRatingType::
  ContentMaturityRatingType (const AgencyType& Agency,
                             const RatingType& Rating)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Agency_ (Agency, this),
    Rating_ (Rating, this),
    Audience_ (this),
    any_ (this->getDomDocument ())
  {
  }

  ContentMaturityRatingType::
  ContentMaturityRatingType (const ContentMaturityRatingType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Agency_ (x.Agency_, f, this),
    Rating_ (x.Rating_, f, this),
    Audience_ (x.Audience_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  ContentMaturityRatingType::
  ContentMaturityRatingType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Agency_ (this),
    Rating_ (this),
    Audience_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ContentMaturityRatingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Agency
      //
      if (n.name () == "Agency" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AgencyType > r (
          AgencyTraits::create (i, f, this));

        if (!Agency_.present ())
        {
          this->Agency_.set (::std::move (r));
          continue;
        }
      }

      // Rating
      //
      if (n.name () == "Rating" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< RatingType > r (
          RatingTraits::create (i, f, this));

        if (!Rating_.present ())
        {
          this->Rating_.set (::std::move (r));
          continue;
        }
      }

      // Audience
      //
      if (n.name () == "Audience" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AudienceType > r (
          AudienceTraits::create (i, f, this));

        if (!this->Audience_)
        {
          this->Audience_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.smpte-ra.org/schemas/2067-3/2013"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    if (!Agency_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Agency",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!Rating_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Rating",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  ContentMaturityRatingType* ContentMaturityRatingType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContentMaturityRatingType (*this, f, c);
  }

  ContentMaturityRatingType& ContentMaturityRatingType::
  operator= (const ContentMaturityRatingType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Agency_ = x.Agency_;
      this->Rating_ = x.Rating_;
      this->Audience_ = x.Audience_;
      this->any_ = x.any_;
    }

    return *this;
  }

  ContentMaturityRatingType::
  ~ContentMaturityRatingType ()
  {
  }

  // EssenceDescriptorBaseType
  //

  EssenceDescriptorBaseType::
  EssenceDescriptorBaseType (const IdType& Id)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (Id, this),
    any_ (this->getDomDocument ())
  {
  }

  EssenceDescriptorBaseType::
  EssenceDescriptorBaseType (const EssenceDescriptorBaseType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (x.Id_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  EssenceDescriptorBaseType::
  EssenceDescriptorBaseType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void EssenceDescriptorBaseType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.smpte-ra.org/schemas/2067-3/2013"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  EssenceDescriptorBaseType* EssenceDescriptorBaseType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EssenceDescriptorBaseType (*this, f, c);
  }

  EssenceDescriptorBaseType& EssenceDescriptorBaseType::
  operator= (const EssenceDescriptorBaseType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->any_ = x.any_;
    }

    return *this;
  }

  EssenceDescriptorBaseType::
  ~EssenceDescriptorBaseType ()
  {
  }

  // ContentVersionType
  //

  ContentVersionType::
  ContentVersionType (const IdType& Id,
                      const LabelTextType& LabelText)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (Id, this),
    LabelText_ (LabelText, this),
    any_ (this->getDomDocument ())
  {
  }

  ContentVersionType::
  ContentVersionType (const IdType& Id,
                      ::std::unique_ptr< LabelTextType > LabelText)
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (Id, this),
    LabelText_ (std::move (LabelText), this),
    any_ (this->getDomDocument ())
  {
  }

  ContentVersionType::
  ContentVersionType (const ContentVersionType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (x.Id_, f, this),
    LabelText_ (x.LabelText_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  ContentVersionType::
  ContentVersionType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    Id_ (this),
    LabelText_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ContentVersionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // LabelText
      //
      if (n.name () == "LabelText" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LabelTextType > r (
          LabelTextTraits::create (i, f, this));

        if (!LabelText_.present ())
        {
          this->LabelText_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.smpte-ra.org/schemas/2067-3/2013"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!LabelText_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LabelText",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  ContentVersionType* ContentVersionType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContentVersionType (*this, f, c);
  }

  ContentVersionType& ContentVersionType::
  operator= (const ContentVersionType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->LabelText_ = x.LabelText_;
      this->any_ = x.any_;
    }

    return *this;
  }

  ContentVersionType::
  ~ContentVersionType ()
  {
  }

  // SegmentType
  //

  SegmentType::
  SegmentType (const IdType& Id,
               const SequenceListType& SequenceList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Annotation_ (this),
    SequenceList_ (SequenceList, this)
  {
  }

  SegmentType::
  SegmentType (const IdType& Id,
               ::std::unique_ptr< SequenceListType > SequenceList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Annotation_ (this),
    SequenceList_ (std::move (SequenceList), this)
  {
  }

  SegmentType::
  SegmentType (const SegmentType& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    Annotation_ (x.Annotation_, f, this),
    SequenceList_ (x.SequenceList_, f, this)
  {
  }

  SegmentType::
  SegmentType (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    Annotation_ (this),
    SequenceList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SegmentType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->Annotation_)
        {
          this->Annotation_.set (::std::move (r));
          continue;
        }
      }

      // SequenceList
      //
      if (n.name () == "SequenceList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< SequenceListType > r (
          SequenceListTraits::create (i, f, this));

        if (!SequenceList_.present ())
        {
          this->SequenceList_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!SequenceList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SequenceList",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  SegmentType* SegmentType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SegmentType (*this, f, c);
  }

  SegmentType& SegmentType::
  operator= (const SegmentType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->Annotation_ = x.Annotation_;
      this->SequenceList_ = x.SequenceList_;
    }

    return *this;
  }

  SegmentType::
  ~SegmentType ()
  {
  }

  // SequenceType
  //

  SequenceType::
  SequenceType (const IdType& Id,
                const TrackIdType& TrackId,
                const ResourceListType& ResourceList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    TrackId_ (TrackId, this),
    ResourceList_ (ResourceList, this)
  {
  }

  SequenceType::
  SequenceType (const IdType& Id,
                const TrackIdType& TrackId,
                ::std::unique_ptr< ResourceListType > ResourceList)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    TrackId_ (TrackId, this),
    ResourceList_ (std::move (ResourceList), this)
  {
  }

  SequenceType::
  SequenceType (const SequenceType& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    TrackId_ (x.TrackId_, f, this),
    ResourceList_ (x.ResourceList_, f, this)
  {
  }

  SequenceType::
  SequenceType (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    TrackId_ (this),
    ResourceList_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SequenceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // TrackId
      //
      if (n.name () == "TrackId" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< TrackIdType > r (
          TrackIdTraits::create (i, f, this));

        if (!TrackId_.present ())
        {
          this->TrackId_.set (::std::move (r));
          continue;
        }
      }

      // ResourceList
      //
      if (n.name () == "ResourceList" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ResourceListType > r (
          ResourceListTraits::create (i, f, this));

        if (!ResourceList_.present ())
        {
          this->ResourceList_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!TrackId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TrackId",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!ResourceList_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ResourceList",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  SequenceType* SequenceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SequenceType (*this, f, c);
  }

  SequenceType& SequenceType::
  operator= (const SequenceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->TrackId_ = x.TrackId_;
      this->ResourceList_ = x.ResourceList_;
    }

    return *this;
  }

  SequenceType::
  ~SequenceType ()
  {
  }

  // BaseResourceType
  //

  BaseResourceType::
  BaseResourceType (const IdType& Id,
                    const IntrinsicDurationType& IntrinsicDuration)
  : ::xml_schema::Type (),
    Id_ (Id, this),
    Annotation_ (this),
    EditRate_ (this),
    IntrinsicDuration_ (IntrinsicDuration, this),
    EntryPoint_ (this),
    SourceDuration_ (this),
    RepeatCount_ (this)
  {
  }

  BaseResourceType::
  BaseResourceType (const BaseResourceType& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Id_ (x.Id_, f, this),
    Annotation_ (x.Annotation_, f, this),
    EditRate_ (x.EditRate_, f, this),
    IntrinsicDuration_ (x.IntrinsicDuration_, f, this),
    EntryPoint_ (x.EntryPoint_, f, this),
    SourceDuration_ (x.SourceDuration_, f, this),
    RepeatCount_ (x.RepeatCount_, f, this)
  {
  }

  BaseResourceType::
  BaseResourceType (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Id_ (this),
    Annotation_ (this),
    EditRate_ (this),
    IntrinsicDuration_ (this),
    EntryPoint_ (this),
    SourceDuration_ (this),
    RepeatCount_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void BaseResourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Id
      //
      if (n.name () == "Id" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< IdType > r (
          IdTraits::create (i, f, this));

        if (!Id_.present ())
        {
          this->Id_.set (::std::move (r));
          continue;
        }
      }

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->Annotation_)
        {
          this->Annotation_.set (::std::move (r));
          continue;
        }
      }

      // EditRate
      //
      if (n.name () == "EditRate" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< EditRateType > r (
          EditRateTraits::create (i, f, this));

        if (!this->EditRate_)
        {
          this->EditRate_.set (::std::move (r));
          continue;
        }
      }

      // IntrinsicDuration
      //
      if (n.name () == "IntrinsicDuration" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!IntrinsicDuration_.present ())
        {
          this->IntrinsicDuration_.set (IntrinsicDurationTraits::create (i, f, this));
          continue;
        }
      }

      // EntryPoint
      //
      if (n.name () == "EntryPoint" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!this->EntryPoint_)
        {
          this->EntryPoint_.set (EntryPointTraits::create (i, f, this));
          continue;
        }
      }

      // SourceDuration
      //
      if (n.name () == "SourceDuration" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!this->SourceDuration_)
        {
          this->SourceDuration_.set (SourceDurationTraits::create (i, f, this));
          continue;
        }
      }

      // RepeatCount
      //
      if (n.name () == "RepeatCount" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!this->RepeatCount_)
        {
          this->RepeatCount_.set (RepeatCountTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!Id_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Id",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!IntrinsicDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IntrinsicDuration",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  BaseResourceType* BaseResourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BaseResourceType (*this, f, c);
  }

  BaseResourceType& BaseResourceType::
  operator= (const BaseResourceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Id_ = x.Id_;
      this->Annotation_ = x.Annotation_;
      this->EditRate_ = x.EditRate_;
      this->IntrinsicDuration_ = x.IntrinsicDuration_;
      this->EntryPoint_ = x.EntryPoint_;
      this->SourceDuration_ = x.SourceDuration_;
      this->RepeatCount_ = x.RepeatCount_;
    }

    return *this;
  }

  BaseResourceType::
  ~BaseResourceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, BaseResourceType >
  _xsd_BaseResourceType_type_factory_init (
    "BaseResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");

  // TrackFileResourceType
  //

  TrackFileResourceType::
  TrackFileResourceType (const IdType& Id,
                         const IntrinsicDurationType& IntrinsicDuration,
                         const SourceEncodingType& SourceEncoding,
                         const TrackFileIdType& TrackFileId)
  : ::cpl::BaseResourceType (Id,
                             IntrinsicDuration),
    SourceEncoding_ (SourceEncoding, this),
    TrackFileId_ (TrackFileId, this),
    KeyId_ (this),
    Hash_ (this)
  {
  }

  TrackFileResourceType::
  TrackFileResourceType (const TrackFileResourceType& x,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::cpl::BaseResourceType (x, f, c),
    SourceEncoding_ (x.SourceEncoding_, f, this),
    TrackFileId_ (x.TrackFileId_, f, this),
    KeyId_ (x.KeyId_, f, this),
    Hash_ (x.Hash_, f, this)
  {
  }

  TrackFileResourceType::
  TrackFileResourceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::Flags f,
                         ::xml_schema::Container* c)
  : ::cpl::BaseResourceType (e, f | ::xml_schema::Flags::base, c),
    SourceEncoding_ (this),
    TrackFileId_ (this),
    KeyId_ (this),
    Hash_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TrackFileResourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::cpl::BaseResourceType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // SourceEncoding
      //
      if (n.name () == "SourceEncoding" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< SourceEncodingType > r (
          SourceEncodingTraits::create (i, f, this));

        if (!SourceEncoding_.present ())
        {
          this->SourceEncoding_.set (::std::move (r));
          continue;
        }
      }

      // TrackFileId
      //
      if (n.name () == "TrackFileId" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< TrackFileIdType > r (
          TrackFileIdTraits::create (i, f, this));

        if (!TrackFileId_.present ())
        {
          this->TrackFileId_.set (::std::move (r));
          continue;
        }
      }

      // KeyId
      //
      if (n.name () == "KeyId" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< KeyIdType > r (
          KeyIdTraits::create (i, f, this));

        if (!this->KeyId_)
        {
          this->KeyId_.set (::std::move (r));
          continue;
        }
      }

      // Hash
      //
      if (n.name () == "Hash" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< HashType > r (
          HashTraits::create (i, f, this));

        if (!this->Hash_)
        {
          this->Hash_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SourceEncoding_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SourceEncoding",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!TrackFileId_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TrackFileId",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  TrackFileResourceType* TrackFileResourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TrackFileResourceType (*this, f, c);
  }

  TrackFileResourceType& TrackFileResourceType::
  operator= (const TrackFileResourceType& x)
  {
    if (this != &x)
    {
      static_cast< ::cpl::BaseResourceType& > (*this) = x;
      this->SourceEncoding_ = x.SourceEncoding_;
      this->TrackFileId_ = x.TrackFileId_;
      this->KeyId_ = x.KeyId_;
      this->Hash_ = x.Hash_;
    }

    return *this;
  }

  TrackFileResourceType::
  ~TrackFileResourceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, TrackFileResourceType >
  _xsd_TrackFileResourceType_type_factory_init (
    "TrackFileResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");

  // MarkerResourceType
  //

  MarkerResourceType::
  MarkerResourceType (const IdType& Id,
                      const IntrinsicDurationType& IntrinsicDuration)
  : ::cpl::BaseResourceType (Id,
                             IntrinsicDuration),
    Marker_ (this)
  {
  }

  MarkerResourceType::
  MarkerResourceType (const MarkerResourceType& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::cpl::BaseResourceType (x, f, c),
    Marker_ (x.Marker_, f, this)
  {
  }

  MarkerResourceType::
  MarkerResourceType (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::cpl::BaseResourceType (e, f | ::xml_schema::Flags::base, c),
    Marker_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MarkerResourceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::cpl::BaseResourceType::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Marker
      //
      if (n.name () == "Marker" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< MarkerType > r (
          MarkerTraits::create (i, f, this));

        this->Marker_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MarkerResourceType* MarkerResourceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerResourceType (*this, f, c);
  }

  MarkerResourceType& MarkerResourceType::
  operator= (const MarkerResourceType& x)
  {
    if (this != &x)
    {
      static_cast< ::cpl::BaseResourceType& > (*this) = x;
      this->Marker_ = x.Marker_;
    }

    return *this;
  }

  MarkerResourceType::
  ~MarkerResourceType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, MarkerResourceType >
  _xsd_MarkerResourceType_type_factory_init (
    "MarkerResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");

  // MarkerType
  //

  MarkerType::
  MarkerType (const LabelType& Label,
              const OffsetType& Offset)
  : ::xml_schema::Type (),
    Annotation_ (this),
    Label_ (Label, this),
    Offset_ (Offset, this)
  {
  }

  MarkerType::
  MarkerType (::std::unique_ptr< LabelType > Label,
              const OffsetType& Offset)
  : ::xml_schema::Type (),
    Annotation_ (this),
    Label_ (std::move (Label), this),
    Offset_ (Offset, this)
  {
  }

  MarkerType::
  MarkerType (const MarkerType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Annotation_ (x.Annotation_, f, this),
    Label_ (x.Label_, f, this),
    Offset_ (x.Offset_, f, this)
  {
  }

  MarkerType::
  MarkerType (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Annotation_ (this),
    Label_ (this),
    Offset_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MarkerType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Annotation
      //
      if (n.name () == "Annotation" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< AnnotationType > r (
          AnnotationTraits::create (i, f, this));

        if (!this->Annotation_)
        {
          this->Annotation_.set (::std::move (r));
          continue;
        }
      }

      // Label
      //
      if (n.name () == "Label" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LabelType > r (
          LabelTraits::create (i, f, this));

        if (!Label_.present ())
        {
          this->Label_.set (::std::move (r));
          continue;
        }
      }

      // Offset
      //
      if (n.name () == "Offset" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        if (!Offset_.present ())
        {
          this->Offset_.set (OffsetTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!Label_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Label",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }

    if (!Offset_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Offset",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  MarkerType* MarkerType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerType (*this, f, c);
  }

  MarkerType& MarkerType::
  operator= (const MarkerType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Annotation_ = x.Annotation_;
      this->Label_ = x.Label_;
      this->Offset_ = x.Offset_;
    }

    return *this;
  }

  MarkerType::
  ~MarkerType ()
  {
  }

  // CompositionPlaylistType_ContentVersionListType
  //

  CompositionPlaylistType_ContentVersionListType::
  CompositionPlaylistType_ContentVersionListType ()
  : ::xml_schema::Type (),
    ContentVersion_ (this)
  {
  }

  CompositionPlaylistType_ContentVersionListType::
  CompositionPlaylistType_ContentVersionListType (const CompositionPlaylistType_ContentVersionListType& x,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ContentVersion_ (x.ContentVersion_, f, this)
  {
  }

  CompositionPlaylistType_ContentVersionListType::
  CompositionPlaylistType_ContentVersionListType (const ::xercesc::DOMElement& e,
                                                  ::xml_schema::Flags f,
                                                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ContentVersion_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType_ContentVersionListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContentVersion
      //
      if (n.name () == "ContentVersion" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentVersionType > r (
          ContentVersionTraits::create (i, f, this));

        this->ContentVersion_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompositionPlaylistType_ContentVersionListType* CompositionPlaylistType_ContentVersionListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_ContentVersionListType (*this, f, c);
  }

  CompositionPlaylistType_ContentVersionListType& CompositionPlaylistType_ContentVersionListType::
  operator= (const CompositionPlaylistType_ContentVersionListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ContentVersion_ = x.ContentVersion_;
    }

    return *this;
  }

  CompositionPlaylistType_ContentVersionListType::
  ~CompositionPlaylistType_ContentVersionListType ()
  {
  }

  // CompositionPlaylistType_EssenceDescriptorListType
  //

  CompositionPlaylistType_EssenceDescriptorListType::
  CompositionPlaylistType_EssenceDescriptorListType ()
  : ::xml_schema::Type (),
    EssenceDescriptor_ (this)
  {
  }

  CompositionPlaylistType_EssenceDescriptorListType::
  CompositionPlaylistType_EssenceDescriptorListType (const CompositionPlaylistType_EssenceDescriptorListType& x,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EssenceDescriptor_ (x.EssenceDescriptor_, f, this)
  {
  }

  CompositionPlaylistType_EssenceDescriptorListType::
  CompositionPlaylistType_EssenceDescriptorListType (const ::xercesc::DOMElement& e,
                                                     ::xml_schema::Flags f,
                                                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EssenceDescriptor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType_EssenceDescriptorListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EssenceDescriptor
      //
      if (n.name () == "EssenceDescriptor" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< EssenceDescriptorType > r (
          EssenceDescriptorTraits::create (i, f, this));

        this->EssenceDescriptor_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompositionPlaylistType_EssenceDescriptorListType* CompositionPlaylistType_EssenceDescriptorListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_EssenceDescriptorListType (*this, f, c);
  }

  CompositionPlaylistType_EssenceDescriptorListType& CompositionPlaylistType_EssenceDescriptorListType::
  operator= (const CompositionPlaylistType_EssenceDescriptorListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EssenceDescriptor_ = x.EssenceDescriptor_;
    }

    return *this;
  }

  CompositionPlaylistType_EssenceDescriptorListType::
  ~CompositionPlaylistType_EssenceDescriptorListType ()
  {
  }

  // CompositionPlaylistType_TotalRunningTimeType
  //

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType ()
  : ::xml_schema::String ()
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const CompositionPlaylistType_TotalRunningTimeType& x,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const ::xercesc::DOMElement& e,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const ::xercesc::DOMAttr& a,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType::
  CompositionPlaylistType_TotalRunningTimeType (const ::std::string& s,
                                                const ::xercesc::DOMElement* e,
                                                ::xml_schema::Flags f,
                                                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
  }

  CompositionPlaylistType_TotalRunningTimeType* CompositionPlaylistType_TotalRunningTimeType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_TotalRunningTimeType (*this, f, c);
  }

  CompositionPlaylistType_TotalRunningTimeType::
  ~CompositionPlaylistType_TotalRunningTimeType ()
  {
  }

  // CompositionPlaylistType_LocaleListType
  //

  CompositionPlaylistType_LocaleListType::
  CompositionPlaylistType_LocaleListType ()
  : ::xml_schema::Type (),
    Locale_ (this)
  {
  }

  CompositionPlaylistType_LocaleListType::
  CompositionPlaylistType_LocaleListType (const CompositionPlaylistType_LocaleListType& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Locale_ (x.Locale_, f, this)
  {
  }

  CompositionPlaylistType_LocaleListType::
  CompositionPlaylistType_LocaleListType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Locale_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType_LocaleListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Locale
      //
      if (n.name () == "Locale" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LocaleType > r (
          LocaleTraits::create (i, f, this));

        this->Locale_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompositionPlaylistType_LocaleListType* CompositionPlaylistType_LocaleListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_LocaleListType (*this, f, c);
  }

  CompositionPlaylistType_LocaleListType& CompositionPlaylistType_LocaleListType::
  operator= (const CompositionPlaylistType_LocaleListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Locale_ = x.Locale_;
    }

    return *this;
  }

  CompositionPlaylistType_LocaleListType::
  ~CompositionPlaylistType_LocaleListType ()
  {
  }

  // CompositionPlaylistType_ExtensionPropertiesType
  //

  CompositionPlaylistType_ExtensionPropertiesType::
  CompositionPlaylistType_ExtensionPropertiesType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ())
  {
  }

  CompositionPlaylistType_ExtensionPropertiesType::
  CompositionPlaylistType_ExtensionPropertiesType (const CompositionPlaylistType_ExtensionPropertiesType& x,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  CompositionPlaylistType_ExtensionPropertiesType::
  CompositionPlaylistType_ExtensionPropertiesType (const ::xercesc::DOMElement& e,
                                                   ::xml_schema::Flags f,
                                                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType_ExtensionPropertiesType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.smpte-ra.org/schemas/2067-3/2013"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }
  }

  CompositionPlaylistType_ExtensionPropertiesType* CompositionPlaylistType_ExtensionPropertiesType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_ExtensionPropertiesType (*this, f, c);
  }

  CompositionPlaylistType_ExtensionPropertiesType& CompositionPlaylistType_ExtensionPropertiesType::
  operator= (const CompositionPlaylistType_ExtensionPropertiesType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->any_ = x.any_;
    }

    return *this;
  }

  CompositionPlaylistType_ExtensionPropertiesType::
  ~CompositionPlaylistType_ExtensionPropertiesType ()
  {
  }

  // CompositionPlaylistType_SegmentListType
  //

  CompositionPlaylistType_SegmentListType::
  CompositionPlaylistType_SegmentListType ()
  : ::xml_schema::Type (),
    Segment_ (this)
  {
  }

  CompositionPlaylistType_SegmentListType::
  CompositionPlaylistType_SegmentListType (const CompositionPlaylistType_SegmentListType& x,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Segment_ (x.Segment_, f, this)
  {
  }

  CompositionPlaylistType_SegmentListType::
  CompositionPlaylistType_SegmentListType (const ::xercesc::DOMElement& e,
                                           ::xml_schema::Flags f,
                                           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Segment_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void CompositionPlaylistType_SegmentListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Segment
      //
      if (n.name () == "Segment" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< SegmentType > r (
          SegmentTraits::create (i, f, this));

        this->Segment_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  CompositionPlaylistType_SegmentListType* CompositionPlaylistType_SegmentListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CompositionPlaylistType_SegmentListType (*this, f, c);
  }

  CompositionPlaylistType_SegmentListType& CompositionPlaylistType_SegmentListType::
  operator= (const CompositionPlaylistType_SegmentListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Segment_ = x.Segment_;
    }

    return *this;
  }

  CompositionPlaylistType_SegmentListType::
  ~CompositionPlaylistType_SegmentListType ()
  {
  }

  // LocaleType_LanguageListType
  //

  LocaleType_LanguageListType::
  LocaleType_LanguageListType ()
  : ::xml_schema::Type (),
    Language_ (this)
  {
  }

  LocaleType_LanguageListType::
  LocaleType_LanguageListType (const LocaleType_LanguageListType& x,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Language_ (x.Language_, f, this)
  {
  }

  LocaleType_LanguageListType::
  LocaleType_LanguageListType (const ::xercesc::DOMElement& e,
                               ::xml_schema::Flags f,
                               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Language_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LocaleType_LanguageListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Language
      //
      if (n.name () == "Language" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< LanguageType > r (
          LanguageTraits::create (i, f, this));

        this->Language_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LocaleType_LanguageListType* LocaleType_LanguageListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocaleType_LanguageListType (*this, f, c);
  }

  LocaleType_LanguageListType& LocaleType_LanguageListType::
  operator= (const LocaleType_LanguageListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Language_ = x.Language_;
    }

    return *this;
  }

  LocaleType_LanguageListType::
  ~LocaleType_LanguageListType ()
  {
  }

  // LocaleType_RegionListType
  //

  LocaleType_RegionListType::
  LocaleType_RegionListType ()
  : ::xml_schema::Type (),
    Region_ (this)
  {
  }

  LocaleType_RegionListType::
  LocaleType_RegionListType (const LocaleType_RegionListType& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Region_ (x.Region_, f, this)
  {
  }

  LocaleType_RegionListType::
  LocaleType_RegionListType (const ::xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Region_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LocaleType_RegionListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Region
      //
      if (n.name () == "Region" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< RegionType > r (
          RegionTraits::create (i, f, this));

        this->Region_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LocaleType_RegionListType* LocaleType_RegionListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocaleType_RegionListType (*this, f, c);
  }

  LocaleType_RegionListType& LocaleType_RegionListType::
  operator= (const LocaleType_RegionListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Region_ = x.Region_;
    }

    return *this;
  }

  LocaleType_RegionListType::
  ~LocaleType_RegionListType ()
  {
  }

  // LocaleType_ContentMaturityRatingListType
  //

  LocaleType_ContentMaturityRatingListType::
  LocaleType_ContentMaturityRatingListType ()
  : ::xml_schema::Type (),
    ContentMaturityRating_ (this)
  {
  }

  LocaleType_ContentMaturityRatingListType::
  LocaleType_ContentMaturityRatingListType (const LocaleType_ContentMaturityRatingListType& x,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ContentMaturityRating_ (x.ContentMaturityRating_, f, this)
  {
  }

  LocaleType_ContentMaturityRatingListType::
  LocaleType_ContentMaturityRatingListType (const ::xercesc::DOMElement& e,
                                            ::xml_schema::Flags f,
                                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ContentMaturityRating_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LocaleType_ContentMaturityRatingListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ContentMaturityRating
      //
      if (n.name () == "ContentMaturityRating" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< ContentMaturityRatingType > r (
          ContentMaturityRatingTraits::create (i, f, this));

        this->ContentMaturityRating_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LocaleType_ContentMaturityRatingListType* LocaleType_ContentMaturityRatingListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LocaleType_ContentMaturityRatingListType (*this, f, c);
  }

  LocaleType_ContentMaturityRatingListType& LocaleType_ContentMaturityRatingListType::
  operator= (const LocaleType_ContentMaturityRatingListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ContentMaturityRating_ = x.ContentMaturityRating_;
    }

    return *this;
  }

  LocaleType_ContentMaturityRatingListType::
  ~LocaleType_ContentMaturityRatingListType ()
  {
  }

  // ContentMaturityRatingType_AudienceType
  //

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const ScopeType& scope)
  : ::xml_schema::String (),
    scope_ (scope, this)
  {
  }

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const char* _xsd_String_base,
                                          const ScopeType& scope)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (scope, this)
  {
  }

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const ::std::string& _xsd_String_base,
                                          const ScopeType& scope)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (scope, this)
  {
  }

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const ::xml_schema::String& _xsd_String_base,
                                          const ScopeType& scope)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (scope, this)
  {
  }

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const ContentMaturityRatingType_AudienceType& x,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    scope_ (x.scope_, f, this)
  {
  }

  ContentMaturityRatingType_AudienceType::
  ContentMaturityRatingType_AudienceType (const ::xercesc::DOMElement& e,
                                          ::xml_schema::Flags f,
                                          ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContentMaturityRatingType_AudienceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "scope",
        "");
    }
  }

  ContentMaturityRatingType_AudienceType* ContentMaturityRatingType_AudienceType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContentMaturityRatingType_AudienceType (*this, f, c);
  }

  ContentMaturityRatingType_AudienceType& ContentMaturityRatingType_AudienceType::
  operator= (const ContentMaturityRatingType_AudienceType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  ContentMaturityRatingType_AudienceType::
  ~ContentMaturityRatingType_AudienceType ()
  {
  }

  // SegmentType_SequenceListType
  //

  SegmentType_SequenceListType::
  SegmentType_SequenceListType ()
  : ::xml_schema::Type (),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    MarkerSequence_ (this),
    any_ (this->getDomDocument ())
  {
  }

  SegmentType_SequenceListType::
  SegmentType_SequenceListType (const SegmentType_SequenceListType& x,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    MarkerSequence_ (x.MarkerSequence_, f, this),
    any_ (x.any_, this->getDomDocument ())
  {
  }

  SegmentType_SequenceListType::
  SegmentType_SequenceListType (const ::xercesc::DOMElement& e,
                                ::xml_schema::Flags f,
                                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
    MarkerSequence_ (this),
    any_ (this->getDomDocument ())
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SegmentType_SequenceListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MarkerSequence
      //
      if (n.name () == "MarkerSequence" && n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
      {
        ::std::unique_ptr< MarkerSequenceType > r (
          MarkerSequenceTraits::create (i, f, this));

        if (!this->MarkerSequence_)
        {
          this->MarkerSequence_.set (::std::move (r));
          continue;
        }
      }

      // any
      //
      if ((!n.namespace_ ().empty () && n.namespace_ () != "http://www.smpte-ra.org/schemas/2067-3/2013"))
      {
        ::xercesc::DOMElement* r (
          static_cast< ::xercesc::DOMElement* > (
            this->getDomDocument ().importNode (
              const_cast< ::xercesc::DOMElement* > (&i), true)));
        this->any_.push_back (r);
        continue;
      }

      break;
    }
  }

  SegmentType_SequenceListType* SegmentType_SequenceListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SegmentType_SequenceListType (*this, f, c);
  }

  SegmentType_SequenceListType& SegmentType_SequenceListType::
  operator= (const SegmentType_SequenceListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->MarkerSequence_ = x.MarkerSequence_;
      this->any_ = x.any_;
    }

    return *this;
  }

  SegmentType_SequenceListType::
  ~SegmentType_SequenceListType ()
  {
  }

  // SequenceType_ResourceListType
  //

  SequenceType_ResourceListType::
  SequenceType_ResourceListType ()
  : ::xml_schema::Type (),
    Resource_ (this)
  {
  }

  SequenceType_ResourceListType::
  SequenceType_ResourceListType (const SequenceType_ResourceListType& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    Resource_ (x.Resource_, f, this)
  {
  }

  SequenceType_ResourceListType::
  SequenceType_ResourceListType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    Resource_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SequenceType_ResourceListType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Resource
      //
      {
        ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "Resource",
            "http://www.smpte-ra.org/schemas/2067-3/2013",
            &::xsd::cxx::tree::factory_impl< ResourceType >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          ::std::unique_ptr< ResourceType > r (
            dynamic_cast< ResourceType* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Resource_.push_back (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SequenceType_ResourceListType* SequenceType_ResourceListType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SequenceType_ResourceListType (*this, f, c);
  }

  SequenceType_ResourceListType& SequenceType_ResourceListType::
  operator= (const SequenceType_ResourceListType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->Resource_ = x.Resource_;
    }

    return *this;
  }

  SequenceType_ResourceListType::
  ~SequenceType_ResourceListType ()
  {
  }

  // MarkerType_LabelType
  //

  const MarkerType_LabelType::ScopeType MarkerType_LabelType::scope_default_value_ (
    "http://www.smpte-ra.org/schemas/2067-3/2013#standard-markers");

  MarkerType_LabelType::
  MarkerType_LabelType ()
  : ::xml_schema::String (),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  MarkerType_LabelType::
  MarkerType_LabelType (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  MarkerType_LabelType::
  MarkerType_LabelType (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  MarkerType_LabelType::
  MarkerType_LabelType (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    scope_ (getScopeDefaultValue (), this)
  {
  }

  MarkerType_LabelType::
  MarkerType_LabelType (const MarkerType_LabelType& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    scope_ (x.scope_, f, this)
  {
  }

  MarkerType_LabelType::
  MarkerType_LabelType (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    scope_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MarkerType_LabelType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "scope" && n.namespace_ ().empty ())
      {
        this->scope_.set (ScopeTraits::create (i, f, this));
        continue;
      }
    }

    if (!scope_.present ())
    {
      this->scope_.set (getScopeDefaultValue ());
    }
  }

  MarkerType_LabelType* MarkerType_LabelType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MarkerType_LabelType (*this, f, c);
  }

  MarkerType_LabelType& MarkerType_LabelType::
  operator= (const MarkerType_LabelType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->scope_ = x.scope_;
    }

    return *this;
  }

  MarkerType_LabelType::
  ~MarkerType_LabelType ()
  {
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace cpl
{
  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    if (i.getAnnotation ())
    {
      o << ::std::endl << "Annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "IssueDate: " << i.getIssueDate ();
    if (i.getIssuer ())
    {
      o << ::std::endl << "Issuer: " << *i.getIssuer ();
    }

    if (i.getCreator ())
    {
      o << ::std::endl << "Creator: " << *i.getCreator ();
    }

    if (i.getContentOriginator ())
    {
      o << ::std::endl << "ContentOriginator: " << *i.getContentOriginator ();
    }

    o << ::std::endl << "ContentTitle: " << i.getContentTitle ();
    if (i.getContentKind ())
    {
      o << ::std::endl << "ContentKind: " << *i.getContentKind ();
    }

    if (i.getContentVersionList ())
    {
      o << ::std::endl << "ContentVersionList: " << *i.getContentVersionList ();
    }

    if (i.getEssenceDescriptorList ())
    {
      o << ::std::endl << "EssenceDescriptorList: " << *i.getEssenceDescriptorList ();
    }

    if (i.getCompositionTimecode ())
    {
      o << ::std::endl << "CompositionTimecode: " << *i.getCompositionTimecode ();
    }

    o << ::std::endl << "EditRate: " << i.getEditRate ();
    if (i.getTotalRunningTime ())
    {
      o << ::std::endl << "TotalRunningTime: " << *i.getTotalRunningTime ();
    }

    if (i.getLocaleList ())
    {
      o << ::std::endl << "LocaleList: " << *i.getLocaleList ();
    }

    if (i.getExtensionProperties ())
    {
      o << ::std::endl << "ExtensionProperties: " << *i.getExtensionProperties ();
    }

    o << ::std::endl << "SegmentList: " << i.getSegmentList ();
    if (i.getSigner ())
    {
      o << ::std::endl << "Signer: " << *i.getSigner ();
    }

    if (i.getSignature ())
    {
      o << ::std::endl << "Signature: " << *i.getSignature ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionTimecodeType& i)
  {
    o << ::std::endl << "TimecodeDropFrame: " << i.getTimecodeDropFrame ();
    o << ::std::endl << "TimecodeRate: " << i.getTimecodeRate ();
    o << ::std::endl << "TimecodeStartAddress: " << i.getTimecodeStartAddress ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const TimecodeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContentKindType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LocaleType& i)
  {
    if (i.getAnnotation ())
    {
      o << ::std::endl << "Annotation: " << *i.getAnnotation ();
    }

    if (i.getLanguageList ())
    {
      o << ::std::endl << "LanguageList: " << *i.getLanguageList ();
    }

    if (i.getRegionList ())
    {
      o << ::std::endl << "RegionList: " << *i.getRegionList ();
    }

    if (i.getContentMaturityRatingList ())
    {
      o << ::std::endl << "ContentMaturityRatingList: " << *i.getContentMaturityRatingList ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContentMaturityRatingType& i)
  {
    o << ::std::endl << "Agency: " << i.getAgency ();
    o << ::std::endl << "Rating: " << i.getRating ();
    if (i.getAudience ())
    {
      o << ::std::endl << "Audience: " << *i.getAudience ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const EssenceDescriptorBaseType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContentVersionType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    o << ::std::endl << "LabelText: " << i.getLabelText ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SegmentType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    if (i.getAnnotation ())
    {
      o << ::std::endl << "Annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "SequenceList: " << i.getSequenceList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SequenceType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    o << ::std::endl << "TrackId: " << i.getTrackId ();
    o << ::std::endl << "ResourceList: " << i.getResourceList ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const BaseResourceType& i)
  {
    o << ::std::endl << "Id: " << i.getId ();
    if (i.getAnnotation ())
    {
      o << ::std::endl << "Annotation: " << *i.getAnnotation ();
    }

    if (i.getEditRate ())
    {
      o << ::std::endl << "EditRate: " << *i.getEditRate ();
    }

    o << ::std::endl << "IntrinsicDuration: " << i.getIntrinsicDuration ();
    if (i.getEntryPoint ())
    {
      o << ::std::endl << "EntryPoint: " << *i.getEntryPoint ();
    }

    if (i.getSourceDuration ())
    {
      o << ::std::endl << "SourceDuration: " << *i.getSourceDuration ();
    }

    if (i.getRepeatCount ())
    {
      o << ::std::endl << "RepeatCount: " << *i.getRepeatCount ();
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, BaseResourceType >
  _xsd_BaseResourceType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const TrackFileResourceType& i)
  {
    o << static_cast< const ::cpl::BaseResourceType& > (i);

    o << ::std::endl << "SourceEncoding: " << i.getSourceEncoding ();
    o << ::std::endl << "TrackFileId: " << i.getTrackFileId ();
    if (i.getKeyId ())
    {
      o << ::std::endl << "KeyId: " << *i.getKeyId ();
    }

    if (i.getHash ())
    {
      o << ::std::endl << "Hash: " << *i.getHash ();
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TrackFileResourceType >
  _xsd_TrackFileResourceType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerResourceType& i)
  {
    o << static_cast< const ::cpl::BaseResourceType& > (i);

    for (MarkerResourceType::MarkerConstIterator
         b (i.getMarker ().begin ()), e (i.getMarker ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Marker: " << *b;
    }

    return o;
  }

  static
  const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MarkerResourceType >
  _xsd_MarkerResourceType_std_ostream_init;

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerType& i)
  {
    if (i.getAnnotation ())
    {
      o << ::std::endl << "Annotation: " << *i.getAnnotation ();
    }

    o << ::std::endl << "Label: " << i.getLabel ();
    o << ::std::endl << "Offset: " << i.getOffset ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_ContentVersionListType& i)
  {
    for (CompositionPlaylistType_ContentVersionListType::ContentVersionConstIterator
         b (i.getContentVersion ().begin ()), e (i.getContentVersion ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ContentVersion: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_EssenceDescriptorListType& i)
  {
    for (CompositionPlaylistType_EssenceDescriptorListType::EssenceDescriptorConstIterator
         b (i.getEssenceDescriptor ().begin ()), e (i.getEssenceDescriptor ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "EssenceDescriptor: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_TotalRunningTimeType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_LocaleListType& i)
  {
    for (CompositionPlaylistType_LocaleListType::LocaleConstIterator
         b (i.getLocale ().begin ()), e (i.getLocale ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Locale: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_ExtensionPropertiesType&)
  {
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const CompositionPlaylistType_SegmentListType& i)
  {
    for (CompositionPlaylistType_SegmentListType::SegmentConstIterator
         b (i.getSegment ().begin ()), e (i.getSegment ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Segment: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LocaleType_LanguageListType& i)
  {
    for (LocaleType_LanguageListType::LanguageConstIterator
         b (i.getLanguage ().begin ()), e (i.getLanguage ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Language: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LocaleType_RegionListType& i)
  {
    for (LocaleType_RegionListType::RegionConstIterator
         b (i.getRegion ().begin ()), e (i.getRegion ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "Region: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const LocaleType_ContentMaturityRatingListType& i)
  {
    for (LocaleType_ContentMaturityRatingListType::ContentMaturityRatingConstIterator
         b (i.getContentMaturityRating ().begin ()), e (i.getContentMaturityRating ().end ());
         b != e; ++b)
    {
      o << ::std::endl << "ContentMaturityRating: " << *b;
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const ContentMaturityRatingType_AudienceType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SegmentType_SequenceListType& i)
  {
    if (i.getMarkerSequence ())
    {
      o << ::std::endl << "MarkerSequence: " << *i.getMarkerSequence ();
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const SequenceType_ResourceListType& i)
  {
    {
      ::xsd::cxx::tree::std_ostream_map< char >& om (
        ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

      for (SequenceType_ResourceListType::ResourceConstIterator
           b (i.getResource ().begin ()), e (i.getResource ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "Resource: ";
        om.insert (o, *b);
      }
    }

    return o;
  }

  ::std::ostream&
  operator<< (::std::ostream& o, const MarkerType_LabelType& i)
  {
    o << static_cast< const ::xml_schema::String& > (i);

    o << ::std::endl << "scope: " << i.getScope ();
    return o;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace cpl
{
  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& u,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& u,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::std::string& u,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cpl::parseCompositionPlaylist (isrc, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cpl::parseCompositionPlaylist (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cpl::parseCompositionPlaylist (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cpl::parseCompositionPlaylist (isrc, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& sid,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cpl::parseCompositionPlaylist (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::std::istream& is,
                            const ::std::string& sid,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cpl::parseCompositionPlaylist (isrc, h, f, p);
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& i,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& i,
                            ::xml_schema::ErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xercesc::InputSource& i,
                            ::xercesc::DOMErrorHandler& h,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
      ::cpl::parseCompositionPlaylist (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (const ::xercesc::DOMDocument& doc,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::cpl::CompositionPlaylistType > (
        ::cpl::parseCompositionPlaylist (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CompositionPlaylist" &&
        n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
    {
      ::std::unique_ptr< ::cpl::CompositionPlaylistType > r (
        ::xsd::cxx::tree::traits< ::cpl::CompositionPlaylistType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CompositionPlaylist",
      "http://www.smpte-ra.org/schemas/2067-3/2013");
  }

  ::std::unique_ptr< ::cpl::CompositionPlaylistType >
  parseCompositionPlaylist (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
                            ::xml_schema::Flags f,
                            const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CompositionPlaylist" &&
        n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
    {
      ::std::unique_ptr< ::cpl::CompositionPlaylistType > r (
        ::xsd::cxx::tree::traits< ::cpl::CompositionPlaylistType, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CompositionPlaylist",
      "http://www.smpte-ra.org/schemas/2067-3/2013");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace cpl
{
  void
  serializeCompositionPlaylist (::std::ostream& o,
                                const ::cpl::CompositionPlaylistType& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeCompositionPlaylist (::std::ostream& o,
                                const ::cpl::CompositionPlaylistType& s,
                                ::xml_schema::ErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeCompositionPlaylist (::std::ostream& o,
                                const ::cpl::CompositionPlaylistType& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& t,
                                const ::cpl::CompositionPlaylistType& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& t,
                                const ::cpl::CompositionPlaylistType& s,
                                ::xml_schema::ErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeCompositionPlaylist (::xercesc::XMLFormatTarget& t,
                                const ::cpl::CompositionPlaylistType& s,
                                ::xercesc::DOMErrorHandler& h,
                                const ::xml_schema::NamespaceInfomap& m,
                                const ::std::string& e,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::cpl::serializeCompositionPlaylist (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  serializeCompositionPlaylist (::xercesc::DOMDocument& d,
                                const ::cpl::CompositionPlaylistType& s,
                                ::xml_schema::Flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CompositionPlaylist" &&
        n.namespace_ () == "http://www.smpte-ra.org/schemas/2067-3/2013")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CompositionPlaylist",
        "http://www.smpte-ra.org/schemas/2067-3/2013");
    }
  }

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
  serializeCompositionPlaylist (const ::cpl::CompositionPlaylistType& s,
                                const ::xml_schema::NamespaceInfomap& m,
                                ::xml_schema::Flags f)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "CompositionPlaylist",
        "http://www.smpte-ra.org/schemas/2067-3/2013",
        m, f));

    ::cpl::serializeCompositionPlaylist (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // Annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAnnotation ();
    }

    // IssueDate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IssueDate",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getIssueDate ();
    }

    // Issuer
    //
    if (i.getIssuer ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Issuer",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getIssuer ();
    }

    // Creator
    //
    if (i.getCreator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Creator",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getCreator ();
    }

    // ContentOriginator
    //
    if (i.getContentOriginator ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentOriginator",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getContentOriginator ();
    }

    // ContentTitle
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentTitle",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getContentTitle ();
    }

    // ContentKind
    //
    if (i.getContentKind ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentKind",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getContentKind ();
    }

    // ContentVersionList
    //
    if (i.getContentVersionList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentVersionList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getContentVersionList ();
    }

    // EssenceDescriptorList
    //
    if (i.getEssenceDescriptorList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceDescriptorList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getEssenceDescriptorList ();
    }

    // CompositionTimecode
    //
    if (i.getCompositionTimecode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CompositionTimecode",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getCompositionTimecode ();
    }

    // EditRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EditRate",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getEditRate ();
    }

    // TotalRunningTime
    //
    if (i.getTotalRunningTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TotalRunningTime",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getTotalRunningTime ();
    }

    // LocaleList
    //
    if (i.getLocaleList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LocaleList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getLocaleList ();
    }

    // ExtensionProperties
    //
    if (i.getExtensionProperties ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ExtensionProperties",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getExtensionProperties ();
    }

    // SegmentList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SegmentList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getSegmentList ();
    }

    // Signer
    //
    if (i.getSigner ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Signer",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getSigner ();
    }

    // Signature
    //
    if (i.getSignature ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Signature",
          "http://www.w3.org/2000/09/xmldsig#",
          e));

      s << *i.getSignature ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionTimecodeType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // TimecodeDropFrame
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimecodeDropFrame",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getTimecodeDropFrame ();
    }

    // TimecodeRate
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimecodeRate",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getTimecodeRate ();
    }

    // TimecodeStartAddress
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TimecodeStartAddress",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getTimecodeStartAddress ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TimecodeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TimecodeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const TimecodeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContentKindType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LocaleType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAnnotation ();
    }

    // LanguageList
    //
    if (i.getLanguageList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LanguageList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getLanguageList ();
    }

    // RegionList
    //
    if (i.getRegionList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RegionList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getRegionList ();
    }

    // ContentMaturityRatingList
    //
    if (i.getContentMaturityRatingList ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentMaturityRatingList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getContentMaturityRatingList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContentMaturityRatingType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Agency
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Agency",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getAgency ();
    }

    // Rating
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Rating",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getRating ();
    }

    // Audience
    //
    if (i.getAudience ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Audience",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAudience ();
    }

    // any
    //
    for (ContentMaturityRatingType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const EssenceDescriptorBaseType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // any
    //
    for (EssenceDescriptorBaseType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContentVersionType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // LabelText
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LabelText",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getLabelText ();
    }

    // any
    //
    for (ContentVersionType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SegmentType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // Annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAnnotation ();
    }

    // SequenceList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SequenceList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getSequenceList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SequenceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // TrackId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TrackId",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getTrackId ();
    }

    // ResourceList
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ResourceList",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getResourceList ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BaseResourceType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Id
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Id",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getId ();
    }

    // Annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAnnotation ();
    }

    // EditRate
    //
    if (i.getEditRate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EditRate",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getEditRate ();
    }

    // IntrinsicDuration
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "IntrinsicDuration",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getIntrinsicDuration ();
    }

    // EntryPoint
    //
    if (i.getEntryPoint ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EntryPoint",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getEntryPoint ();
    }

    // SourceDuration
    //
    if (i.getSourceDuration ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SourceDuration",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getSourceDuration ();
    }

    // RepeatCount
    //
    if (i.getRepeatCount ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RepeatCount",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getRepeatCount ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, BaseResourceType >
  _xsd_BaseResourceType_type_serializer_init (
    "BaseResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");


  void
  operator<< (::xercesc::DOMElement& e, const TrackFileResourceType& i)
  {
    e << static_cast< const ::cpl::BaseResourceType& > (i);

    // SourceEncoding
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SourceEncoding",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getSourceEncoding ();
    }

    // TrackFileId
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TrackFileId",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getTrackFileId ();
    }

    // KeyId
    //
    if (i.getKeyId ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "KeyId",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getKeyId ();
    }

    // Hash
    //
    if (i.getHash ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Hash",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getHash ();
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TrackFileResourceType >
  _xsd_TrackFileResourceType_type_serializer_init (
    "TrackFileResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");


  void
  operator<< (::xercesc::DOMElement& e, const MarkerResourceType& i)
  {
    e << static_cast< const ::cpl::BaseResourceType& > (i);

    // Marker
    //
    for (MarkerResourceType::MarkerConstIterator
         b (i.getMarker ().begin ()), n (i.getMarker ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Marker",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, MarkerResourceType >
  _xsd_MarkerResourceType_type_serializer_init (
    "MarkerResourceType",
    "http://www.smpte-ra.org/schemas/2067-3/2013");


  void
  operator<< (::xercesc::DOMElement& e, const MarkerType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Annotation
    //
    if (i.getAnnotation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Annotation",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getAnnotation ();
    }

    // Label
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Label",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getLabel ();
    }

    // Offset
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Offset",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << i.getOffset ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_ContentVersionListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ContentVersion
    //
    for (CompositionPlaylistType_ContentVersionListType::ContentVersionConstIterator
         b (i.getContentVersion ().begin ()), n (i.getContentVersion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentVersion",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_EssenceDescriptorListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // EssenceDescriptor
    //
    for (CompositionPlaylistType_EssenceDescriptorListType::EssenceDescriptorConstIterator
         b (i.getEssenceDescriptor ().begin ()), n (i.getEssenceDescriptor ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "EssenceDescriptor",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_TotalRunningTimeType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const CompositionPlaylistType_TotalRunningTimeType& i)
  {
    a << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xml_schema::ListStream& l,
              const CompositionPlaylistType_TotalRunningTimeType& i)
  {
    l << static_cast< const ::xml_schema::String& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_LocaleListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Locale
    //
    for (CompositionPlaylistType_LocaleListType::LocaleConstIterator
         b (i.getLocale ().begin ()), n (i.getLocale ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Locale",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_ExtensionPropertiesType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // any
    //
    for (CompositionPlaylistType_ExtensionPropertiesType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CompositionPlaylistType_SegmentListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Segment
    //
    for (CompositionPlaylistType_SegmentListType::SegmentConstIterator
         b (i.getSegment ().begin ()), n (i.getSegment ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Segment",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LocaleType_LanguageListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Language
    //
    for (LocaleType_LanguageListType::LanguageConstIterator
         b (i.getLanguage ().begin ()), n (i.getLanguage ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Language",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LocaleType_RegionListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Region
    //
    for (LocaleType_RegionListType::RegionConstIterator
         b (i.getRegion ().begin ()), n (i.getRegion ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Region",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const LocaleType_ContentMaturityRatingListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // ContentMaturityRating
    //
    for (LocaleType_ContentMaturityRatingListType::ContentMaturityRatingConstIterator
         b (i.getContentMaturityRating ().begin ()), n (i.getContentMaturityRating ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ContentMaturityRating",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ContentMaturityRatingType_AudienceType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SegmentType_SequenceListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // MarkerSequence
    //
    if (i.getMarkerSequence ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MarkerSequence",
          "http://www.smpte-ra.org/schemas/2067-3/2013",
          e));

      s << *i.getMarkerSequence ();
    }

    // any
    //
    for (SegmentType_SequenceListType::AnyConstIterator
         b (i.getAny ().begin ()), n (i.getAny ().end ());
         b != n; ++b)
    {
      e.appendChild (
        e.getOwnerDocument ()->importNode (
          const_cast< ::xercesc::DOMElement* > (&(*b)), true));
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SequenceType_ResourceListType& i)
  {
    e << static_cast< const ::xml_schema::Type& > (i);

    // Resource
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      for (SequenceType_ResourceListType::ResourceConstIterator
           b (i.getResource ().begin ()), n (i.getResource ().end ());
           b != n; ++b)
      {
        if (typeid (SequenceType_ResourceListType::ResourceType) == typeid (*b))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "Resource",
              "http://www.smpte-ra.org/schemas/2067-3/2013",
              e));

          s << *b;
        }
        else
          tsm.serialize (
            "Resource",
            "http://www.smpte-ra.org/schemas/2067-3/2013",
            false, true, e, *b);
      }
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MarkerType_LabelType& i)
  {
    e << static_cast< const ::xml_schema::String& > (i);

    // scope
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "scope",
          e));

      a << i.getScope ();
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

